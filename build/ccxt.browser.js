(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*  A entry point for the browser bundle version. This gets compiled by:
        
        browserify --debug ./ccxt.browser.js > ./build/ccxt.browser.js
 */

window.ccxt = require ('./ccxt')
},{"./ccxt":2}],2:[function(require,module,exports){
(function (process){
"use strict";

/*

MIT License

Copyright (c) 2017 Igor Kroitor

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

(function () {

//-----------------------------------------------------------------------------
// dependencies

const CryptoJS = require ('crypto-js')
    , qs       = require ('qs') // querystring
    // , ws       = require ('ws') // websocket

//-----------------------------------------------------------------------------
// this is updated by vss.js when building

const version = '1.7.123'

//-----------------------------------------------------------------------------
// platform detection

const isNode     = (typeof window === 'undefined')
    , isCommonJS = (typeof module !== 'undefined') && (typeof require !== 'undefined')

//-----------------------------------------------------------------------------

class CCXTError extends Error {
    constructor (message) {
        super (message)
        // a workaround to make `instanceof CCXTError` work in ES5
        this.constructor = CCXTError
        this.__proto__   = CCXTError.prototype
        this.message     = message
    }
}

class ExchangeError extends CCXTError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeError
        this.__proto__   = ExchangeError.prototype
        this.message     = message
    }
}

class NotSupported extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = NotSupported
        this.__proto__   = NotSupported.prototype
        this.message     = message
    }
}

class AuthenticationError extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = AuthenticationError
        this.__proto__   = AuthenticationError.prototype
        this.message     = message
    }
}

class InsufficientFunds extends ExchangeError {
    constructor (message) {
        super (message)
        this.constructor = InsufficientFunds
        this.__proto__   = InsufficientFunds.prototype
        this.message     = message
    }
}

class NetworkError extends CCXTError {
    constructor (message) {
        super (message)
        this.constructor = NetworkError
        this.__proto__   = NetworkError.prototype
        this.message     = message
    }
}

class DDoSProtection extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = DDoSProtection
        this.__proto__   = DDoSProtection.prototype
        this.message     = message
    }
}

class RequestTimeout extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = RequestTimeout
        this.__proto__   = RequestTimeout.prototype
        this.message     = message
    }
}

class ExchangeNotAvailable extends NetworkError {
    constructor (message) {
        super (message)
        this.constructor = ExchangeNotAvailable
        this.__proto__   = ExchangeNotAvailable.prototype
        this.message     = message
    }
}

//-----------------------------------------------------------------------------
// utility helpers

const setTimeout_safe = (done, ms, targetTime = Date.now () + ms) => { // setTimeout can fire earlier than specified, so we need to ensure it does not happen...

    setTimeout (() => {
        const rest = targetTime - Date.now ()
        if (rest > 0) {
            setTimeout_safe (done, rest, targetTime) // try sleep more
        } else {
            done ()
        }
    }, ms)
}

const sleep = ms => new Promise (resolve => setTimeout_safe (resolve, ms))

const decimal = float => parseFloat (float).toString ()

const timeout = (ms, promise) =>
        Promise.race ([
            promise,
            sleep (ms).then (() => { throw new RequestTimeout ('request timed out') })
        ])

const capitalize = string => string.length ? (string.charAt (0).toUpperCase () + string.slice (1)) : string

const keysort = object => {
    const result = {}
    Object.keys (object).sort ().forEach (key => result[key] = object[key])
    return result
}

const extend = (...args) => Object.assign ({}, ...args)

const omit = (object, ...args) => {
    const result = extend (object)
    for (const x of args) {
        if (typeof x === 'string') {
            delete result[x]
        } else if (Array.isArray (x)) {
            for (const k of x)
                delete result[k]
        }
    }
    return result
}

const indexBy = (array, key) => {
    const result = {}
    if (Array.isArray (array)) {
        for (let i = 0; i < array.length; i++) {
            let element = array[i]
            if (typeof element[key] != 'undefined') {
                result[element[key]] = element
            }
        }
    } else {
        let ids = Object.keys (array);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let element = array[id];
            if (typeof element[key] != 'undefined') {
                result[element[key]] = element
            }
        }
    }
    return result
}

const sortBy = (array, key, descending = false) => {
    descending = descending ? -1 : 1
    return array.sort ((a, b) => ((a[key] < b[key]) ? -descending : ((a[key] > b[key]) ? descending : 0)))
}

const flatten = (array, result = []) => {
    for (let i = 0, length = array.length; i < length; i++) {
        const value = array[i]
        if (Array.isArray (value)) {
            flatten (value, result)
        } else {
            result.push (value)
        }
    }
    return result
}

const unique = array => array.filter ((value, index, self) => (self.indexOf (value) == index))

const pluck = (array, key) => array
                                .filter (element => (typeof element[key] != 'undefined'))
                                .map (element => element[key])

const urlencode = object => qs.stringify (object)

const sum = (...args) => {
    const result = args.filter (arg => typeof arg != 'undefined')
    return (result.length > 0) ?
        result.reduce ((sum, value) => sum + value, 0) : undefined
}

const safeFloat = (object, key, defaultValue = undefined) => {
    return ((key in object) && (object[key])) ? parseFloat (object[key]) : defaultValue
}

const ordered = x => x // a stub to keep assoc keys in order, in JS it does nothing, it's mostly for Python

//-----------------------------------------------------------------------------
// a cross-platform Fetch API

const nodeFetch   = isNode && module.require ('node-fetch')         // using module.require to prevent Webpack / React Native from trying to include it
    , windowFetch = (typeof window !== 'undefined' && window.fetch) // native Fetch API (in newer browsers)
    , xhrFetch    = (url, options, verbose = false) =>              // a quick ad-hoc polyfill (for older browsers)
                        new Promise ((resolve, reject) => {

                            if (verbose)
                                console.log (url, options)

                            const xhr = new XMLHttpRequest ()
                            const method = options.method || 'GET'

                            xhr.open (method, url, true)
                            xhr.onreadystatechange = () => {
                                if (xhr.readyState == 4) {
                                    if (xhr.status == 200)
                                        resolve (xhr.responseText)
                                    else { // [403, 404, ...].indexOf (xhr.status) >= 0
                                        throw new Error (method, url, xhr.status, xhr.responseText)
                                    }
                                }
                            }

                            if (typeof options.headers != 'undefined')
                                for (var header in options.headers)
                                    xhr.setRequestHeader (header, options.headers[header])

                            xhr.send (options.body)
                        })

const fetch = nodeFetch || windowFetch || xhrFetch

//-----------------------------------------------------------------------------
// string ←→ binary ←→ base64 conversion routines

const stringToBinary = str => {
    const arr = new Uint8Array (str.length)
    for (let i = 0; i < str.length; i++) { arr[i] = str.charCodeAt(i); }
    return CryptoJS.lib.WordArray.create (arr)
}

const stringToBase64 = string => CryptoJS.enc.Latin1.parse (string).toString (CryptoJS.enc.Base64)
    , utf16ToBase64  = string => CryptoJS.enc.Utf16 .parse (string).toString (CryptoJS.enc.Base64)
    , base64ToBinary = string => CryptoJS.enc.Base64.parse (string)
    , base64ToString = string => CryptoJS.enc.Base64.parse (string).toString (CryptoJS.enc.Utf8)
    , binaryToString = string => string

const binaryConcat = (...args) => args.reduce ((a, b) => a.concat (b))

// url-safe-base64 without equals signs, with + replaced by - and slashes replaced by underscores
const urlencodeBase64 = base64string => base64string.replace (/[=]+$/, '')
                                                    .replace (/\+/g, '-')
                                                    .replace (/\//g, '_')

//-----------------------------------------------------------------------------
// cryptography

const hash = (request, hash = 'md5', digest = 'hex') => {
    const result = CryptoJS[hash.toUpperCase ()] (request)
    return (digest == 'binary') ? result : result.toString (CryptoJS.enc[capitalize (digest)])
}

const hmac = (request, secret, hash = 'sha256', digest = 'hex') => {
    const encoding = (digest == 'binary') ? 'Latin1' : capitalize (digest)
    return CryptoJS['Hmac' + hash.toUpperCase ()] (request, secret).toString (CryptoJS.enc[capitalize (encoding)])
}

//-----------------------------------------------------------------------------
// a JSON Web Token authentication method

const jwt = (request, secret, alg = 'HS256', hash = 'sha256') => {
    const encodedHeader = urlencodeBase64 (stringToBase64 (JSON.stringify ({ 'alg': alg, 'typ': 'JWT' })))
        , encodedData = urlencodeBase64 (stringToBase64 (JSON.stringify (request)))
        , token = [ encodedHeader, encodedData ].join ('.')
        , signature = urlencodeBase64 (utf16ToBase64 (hmac (token, secret, hash, 'utf16')))
    return [ token, signature ].join ('.')
}

//-----------------------------------------------------------------------------
// const WebSocket = require('ws')
// const ws = new WebSocket (this.urls['websocket'])
// ws.on ('open', function open () {
//     console.log ('connected')
//     // ws.send (Date.now ())
// })
// ws.on ('close', function close () {
//     console.log ('disconnected')
// });
// ws.on ('message', function incoming (data) {
//     // console.log (`Roundtrip time: ${Date.now() - data} ms`);
//     setTimeout (function timeout () {
//         ws.send (Date.now ())
//     }, 500)
// })
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// the base class

const Exchange = function (config) {

    this.hash = hash
    this.hmac = hmac
    this.jwt = jwt // JSON Web Token
    this.binaryConcat = binaryConcat
    this.stringToBinary = stringToBinary
    this.stringToBase64 = stringToBase64
    this.base64ToBinary = base64ToBinary
    this.base64ToString = base64ToString
    this.binaryToString = binaryToString
    this.utf16ToBase64 = utf16ToBase64
    this.urlencode = urlencode
    this.encodeURIComponent = encodeURIComponent
    this.omit = omit
    this.pluck = pluck
    this.unique = unique
    this.extend = extend
    this.flatten = flatten
    this.indexBy = indexBy
    this.sortBy = sortBy
    this.keysort = keysort
    this.decimal = decimal
    this.safeFloat = safeFloat
    this.capitalize = capitalize
    this.json = JSON.stringify
    this.sum = sum
    this.ordered = ordered

    this.encode = string => string
    this.decode = string => string

    if (isNode)
        this.nodeVersion = process.version.match (/\d+\.\d+.\d+/) [0]

    this.init = function () {
        this.orders = {}
        this.trades = {}
        if (this.api)
            this.defineRestApi (this.api, 'request');
        if (this.markets)
            this.setMarkets (this.markets);
    }

    this.defineRestApi = function (api, methodName, options = {}) {
        Object.keys (api).forEach (type => {
            Object.keys (api[type]).forEach (httpMethod => {
                let urls = api[type][httpMethod]
                for (let i = 0; i < urls.length; i++) {
                    let url = urls[i].trim ()
                    let splitPath = url.split (/[^a-zA-Z0-9]/)

                    let uppercaseMethod  = httpMethod.toUpperCase ()
                    let lowercaseMethod  = httpMethod.toLowerCase ()
                    let camelcaseMethod  = capitalize (lowercaseMethod)
                    let camelcaseSuffix  = splitPath.map (capitalize).join ('')
                    let underscoreSuffix = splitPath.map (x => x.trim ().toLowerCase ()).filter (x => x.length > 0).join ('_')

                    if (camelcaseSuffix.indexOf (camelcaseMethod) === 0)
                        camelcaseSuffix = camelcaseSuffix.slice (camelcaseMethod.length)

                    if (underscoreSuffix.indexOf (lowercaseMethod) === 0)
                        underscoreSuffix = underscoreSuffix.slice (lowercaseMethod.length)

                    let camelcase  = type + camelcaseMethod + capitalize (camelcaseSuffix)
                    let underscore = type + '_' + lowercaseMethod + '_' + underscoreSuffix

                    if ('suffixes' in options) {
                        if ('camelcase' in options['suffixes'])
                            camelcase += options['suffixes']['camelcase']
                        if ('underscore' in options.suffixes)
                            underscore += options['suffixes']['underscore']
                    }

                    if ('underscore_suffix' in options)
                        underscore += options.underscoreSuffix;
                    if ('camelcase_suffix' in options)
                        camelcase += options.camelcaseSuffix;

                    let partial = async params => this[methodName] (url, type, uppercaseMethod, params)

                    this[camelcase]  = partial
                    this[underscore] = partial
                }
            })
        })
    }

    // this.initializeStreamingAPI = function () {
    //     this.ws = new WebSocket (this.urls['websocket'])
    //     ws.on ('open', function open () {
    //         console.log ('connected')
    //         // ws.send (Date.now ())
    //     })
    //     ws.on ('close', function close () {
    //         console.log ('disconnected')
    //     })
    //     ws.on ('message', function incoming (data) {
    //         // console.log (`Roundtrip time: ${Date.now() - data} ms`);
    //         setTimeout (function timeout () {
    //             ws.send (Date.now ())
    //         }, 500)
    //     })
    // },

    // internal rate-limiting REST poller

    let lastRestRequestTimestamp = 0
      , lastRestPollTimestamp = 0
      , restRequestQueue = []
      , restPollerLoopIsRunning = false
      , runRestPollerLoop = async () => {

        if (!restPollerLoopIsRunning) {

            restPollerLoopIsRunning = true
            lastRestPollTimestamp = Math.max (lastRestPollTimestamp, lastRestRequestTimestamp)

            while (restRequestQueue.length > 0) {

                // rate limiter

                let elapsed = this.milliseconds () - lastRestPollTimestamp
                let delay = this.rateLimit - elapsed
                if (delay > 0) {
                    await sleep (delay)
                }

                let { args, resolve, reject } = restRequestQueue.shift ()
                lastRestPollTimestamp = this.milliseconds ()

                this.executeRestRequest (...args)
                     .then (resolve)
                     .catch (reject)
            }

            restPollerLoopIsRunning = false
        }
    }

    const issueRestRequest = (...args) => {

        if (this.enableRateLimit) {
            return new Promise ((resolve, reject) => {
                restRequestQueue.push ({ args, resolve, reject })
                runRestPollerLoop ()
            })
        } else {
            return this.executeRestRequest (...args)
        }
    }

    this.executeRestRequest = function (url, method = 'GET', headers = undefined, body = undefined) {

        lastRestRequestTimestamp = this.milliseconds ()

        let promise =
            fetch (url, { 'method': method, 'headers': headers, 'body': body })
                .catch (e => {
                    if (isNode)
                        throw new ExchangeNotAvailable ([ this.id, method, url, e.type, e.message ].join (' '))
                    throw e // rethrow all unknown errors
                })
                .then (response => this.handleRestErrors (response, url, method, headers, body))
                .then (response => this.handleRestResponse (response, url, method, headers, body))

        return timeout (this.timeout, promise)
    }

    this.fetch = function (url, method = 'GET', headers = undefined, body = undefined) {

        if (isNode && this.userAgent)
            if (typeof this.userAgent == 'string')
                headers = extend ({ 'User-Agent': this.userAgent }, headers)
            else if ((typeof this.userAgent == 'object') && ('User-Agent' in this.userAgent))
                headers = extend (this.userAgent, headers)

        if (this.proxy.length)
            headers = extend ({ 'Origin': '*' }, headers)

        url = this.proxy + url

        if (this.verbose)
            console.log (this.id, method, url, "\nRequest:\n", headers, body)

        return issueRestRequest (url, method, headers, body)
    }

    this.handleRestErrors = function (response, url, method = 'GET', headers = undefined, body = undefined) {

        if (typeof response == 'string')
            return response

        return response.text ().then (text => {
            if (this.verbose)
                console.log (this.id, method, url, text ? ("\nResponse:\n" + text) : '')
            if ((response.status >= 200) && (response.status <= 300))
                return text
            let error = undefined
            let details = text
            if ([ 429 ].indexOf (response.status) >= 0) {
                error = DDoSProtection
            } else if ([ 404, 409, 422, 500, 501, 502, 520, 521, 522, 525 ].indexOf (response.status) >= 0) {
                error = ExchangeNotAvailable
            } else if ([ 400, 403, 405, 503 ].indexOf (response.status) >= 0) {
                let ddosProtection = text.match (/cloudflare|incapsula/i)
                if (ddosProtection) {
                    error = DDoSProtection
                } else {
                    error = ExchangeNotAvailable
                    details = text + ' (possible reasons: ' + [
                        'invalid API keys',
                        'bad or old nonce',
                        'exchange is down or offline',
                        'on maintenance',
                        'DDoS protection',
                        'rate-limiting',
                    ].join (', ') + ')'
                }
            } else if ([ 408, 504 ].indexOf (response.status) >= 0) {
                error = RequestTimeout
            } else if ([ 401, 511 ].indexOf (response.status) >= 0) {
                error = AuthenticationError
            } else {
                error = ExchangeError
            }
            throw new error ([ this.id, method, url, response.status, response.statusText, details ].join (' '))
        })
    }

    this.handleRestResponse = function (response, url, method = 'GET', headers = undefined, body = undefined) {

        try {

            if ((typeof response != 'string') || (response.length < 2))
                throw new ExchangeError ([this.id, method, url, 'returned empty response'].join (' '))

            return JSON.parse (response)

        } catch (e) {

            let maintenance = response.match (/offline|busy|retry|wait|unavailable|maintain|maintenance|maintenancing/i)
            let ddosProtection = response.match (/cloudflare|incapsula|overload/i)

            if (e instanceof SyntaxError) {

                let error = ExchangeNotAvailable
                let details = 'not accessible from this location at the moment'
                if (maintenance)
                    details = 'offline, on maintenance or unreachable from this location at the moment'
                if (ddosProtection)
                    error = DDoSProtection
                throw new error ([ this.id, method, url, details ].join (' '))
            }

            if (this.verbose)
                console.log (this.id, method, url, 'error', e, "response body:\n'" + response + "'")

            throw e
        }
    }

    this.setMarkets = function (markets) {
        let values = Object.values (markets)
        this.markets = indexBy (values, 'symbol')
        this.marketsById = indexBy (markets, 'id')
        this.markets_by_id = this.marketsById
        this.symbols = Object.keys (this.markets).sort ()
        this.ids = Object.keys (this.markets_by_id).sort ()
        let base = this.pluck (values.filter (market => 'base' in market), 'base')
        let quote = this.pluck (values.filter (market => 'quote' in market), 'quote')
        this.currencies = this.unique (base.concat (quote))
        return this.markets
    }

    this.loadMarkets = function (reload = false) {
        if (!reload && this.markets) {
            if (!this.marketsById) {
                return new Promise ((resolve, reject) => resolve (this.setMarkets (this.markets)))
            }
            return new Promise ((resolve, reject) => resolve (this.markets))
        }
        return this.fetchMarkets ().then (markets => {
            return this.setMarkets (markets)
        })
    }

    this.fetchTickers = function (symbols = undefined) {
        throw new NotSupported (this.id + ' fetchTickers not supported yet')
    }

    this.fetchOrder = function (id, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not supported yet');
    }

    this.fetchOrders = function (params = {}) {
        throw new NotSupported (this.id + ' fetchOrders not supported yet');
    }

    this.fetchOpenOrders = function (symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOpenOrders not supported yet');
    }

    this.fetchClosedOrders = function (symbol = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchClosedOrders not supported yet');
    }

    this.fetchMarkets = function () {
        return new Promise ((resolve, reject) => resolve (this.markets))
    }

    this.fetchOrderStatus = async function (id, market = undefined) {
        let order = await fetchOrder (id)
        return order['status']
    }

    this.account = function () {
        return {
            'free': 0.0,
            'used': 0.0,
            'total': 0.0,
        }
    }

    this.commonCurrencyCode = function (currency) {
        if (!this.substituteCommonCurrencyCodes)
            return currency
        if (currency == 'XBT')
            return 'BTC'
        if (currency == 'BCC')
            return 'BCH'
        if (currency == 'DRK')
            return 'DASH'
        return currency
    }

    this.market = function (symbol) {
        return (((typeof symbol === 'string') &&
            (typeof this.markets != 'undefined') &&
            (typeof this.markets[symbol] != 'undefined')) ?
                this.markets[symbol] :
                symbol)
    }

    this.market_id =
    this.marketId = function (symbol) {
        return this.market (symbol).id || symbol
    }

    this.market_ids =
    this.marketIds = function (symbols) {
        return symbols.map (symbol => this.marketId(symbol));
    }

    this.symbol = function (symbol) {
        return this.market (symbol).symbol || symbol
    }

    this.extract_params =
    this.extractParams = function (string) {
        var re = /{([a-zA-Z0-9_]+?)}/g
        var matches = []
        let match
        while (match = re.exec (string))
            matches.push (match[1])
        return matches
    }

    this.implode_params =
    this.implodeParams = function (string, params) {
        for (var property in params)
            string = string.replace ('{' + property + '}', params[property])
        return string
    }

    this.url = function (path, params = {}) {
        let result = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path))
        if (Object.keys (query).length)
            result += '?' + this.urlencode (query)
        return result
    }

    this.parseBidAsk = function (bidask, priceKey = 0, amountKey = 1) {
        let price = parseFloat (bidask[priceKey])
        let amount = parseFloat (bidask[amountKey])
        return [ price, amount ]
    }

    this.parseBidAsks = function (bidasks, priceKey = 0, amountKey = 1) {
        return Object.values (bidasks).map (bidask => this.parseBidAsk (bidask, priceKey, amountKey))
    }

    this.parseOrderBook = function (orderbook, timestamp = undefined, bidsKey = 'bids', asksKey = 'asks', priceKey = 0, amountKey = 1) {
        timestamp = timestamp || this.milliseconds ();
        return {
            'bids': (bidsKey in orderbook) ? this.parseBidAsks (orderbook[bidsKey], priceKey, amountKey) : [],
            'asks': (asksKey in orderbook) ? this.parseBidAsks (orderbook[asksKey], priceKey, amountKey) : [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    },

    this.parseTrades = function (trades, market = undefined) {
        return Object.values (trades).map (trade => this.parseTrade (trade, market))
    }

    this.parseOrders = function (orders, market = undefined) {
        return Object.values (orders).map (order => this.parseOrder (order, market))
    }

    this.parseOHLCV = function (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return ohlcv
    }

    this.parseOHLCVs = function (ohlcvs, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return Object.values (ohlcvs).map (ohlcv => this.parseOHLCV (ohlcv, market, timeframe, since, limit))
    }

    this.createLimitBuyOrder = function (market, amount, price, params = {}) {
        return this.createOrder  (market, 'limit', 'buy', amount, price, params)
    }

    this.createLimitSellOrder = function (market, amount, price, params = {}) {
        return this.createOrder (market, 'limit', 'sell', amount, price, params)
    }

    this.createMarketBuyOrder = function (market, amount, params = {}) {
        return this.createOrder (market, 'market', 'buy', amount, undefined, params)
    }

    this.createMarketSellOrder = function (market, amount, params = {}) {
        return this.createOrder (market, 'market', 'sell', amount, undefined, params)
    }

    this.calculateFeeRate = function (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        const market = this.markets[symbol]
        return { 'currency': market['quote'], 'rate': market[takerOrMaker] }
    }

    this.calculateFee = function (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let fee = this.calculateFeeRate (symbol, type, side, amount, price, takerOrMaker, params)
        fee['cost'] = amount * price * fee['rate']
        return fee
    }

    this.iso8601         = timestamp => new Date (timestamp).toISOString ()
    this.parse8601       = Date.parse
    this.seconds         = () => Math.floor (this.milliseconds () / 1000)
    this.microseconds    = () => Math.floor (this.milliseconds () * 1000)
    this.milliseconds    = Date.now
    this.nonce           = this.seconds
    this.id              = undefined
    this.enableRateLimit = false
    this.rateLimit       = 2000  // milliseconds = seconds * 1000
    this.timeout         = 10000 // milliseconds = seconds * 1000
    this.verbose         = false
    this.userAgent       = false
    this.twofa           = false // two-factor authentication
    this.substituteCommonCurrencyCodes = true
    this.timeframes      = undefined
    this.hasPublicAPI         = true
    this.hasPrivateAPI        = true
    this.hasCORS              = false
    this.hasFetchTickers      = false
    this.hasFetchOHLCV        = false
    this.hasFetchOrder        = false
    this.hasFetchOrders       = false
    this.hasFetchOpenOrders   = false
    this.hasFetchClosedOrders = false
    this.hasDeposit           = false
    this.hasWithdraw          = false

    this.balance    = {}
    this.orderbooks = {}
    this.fees       = {}
    this.orders     = {}
    this.trades     = {}

    this.YmdHMS = function (timestamp, infix = ' ') {
        let date = new Date (timestamp)
        let Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        let H = date.getUTCHours ()
        let M = date.getUTCMinutes ()
        let S = date.getUTCSeconds ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        H = H < 10 ? ('0' + H) : H
        M = M < 10 ? ('0' + M) : M
        S = S < 10 ? ('0' + S) : S
        return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S
    }

    if (isNode)
        this.userAgent = {
            'User-Agent': 'ccxt/' + version +
                ' (+https://github.com/kroitor/ccxt)' +
                ' Node.js/' + this.nodeVersion + ' (JavaScript)'
        }

    // prepended to URL, like https://proxy.com/https://exchange.com/api...
    this.proxy = ''

    for (var property in config)
        this[property] = config[property]

    this.account                  = this.account
    this.fetch_balance            = this.fetchBalance
    this.fetch_order_book         = this.fetchOrderBook
    this.fetch_tickers            = this.fetchTickers
    this.fetch_ticker             = this.fetchTicker
    this.fetch_trades             = this.fetchTrades
    this.fetch_order              = this.fetchOrder
    this.fetch_orders             = this.fetchOrders
    this.fetch_open_orders        = this.fetchOpenOrders
    this.fetch_closed_orders      = this.fetchClosedOrders
    this.fetch_order_status       = this.fetchOrderStatus
    this.fetch_markets            = this.fetchMarkets
    this.load_markets             = this.loadMarkets
    this.set_markets              = this.setMarkets
    this.parse_bidask             = this.parseBidAsk
    this.parse_bidasks            = this.parseBidAsks
    this.parse_order_book         = this.parseOrderBook
    this.parse_trades             = this.parseTrades
    this.parse_orders             = this.parseOrders
    this.parse_ohlcv              = this.parseOHLCV
    this.parse_ohlcvs             = this.parseOHLCVs
    this.create_limit_buy_order   = this.createLimitBuyOrder
    this.create_limit_sell_order  = this.createLimitBuyOrder
    this.create_market_buy_order  = this.createLimitBuyOrder
    this.create_market_sell_order = this.createLimitBuyOrder
    this.create_order             = this.createOrder
    this.calculate_fee            = this.calculateFee
    this.calculate_fee_rate       = this.calculateFeeRate

    this.init ()
}

//=============================================================================

var _1broker = {

    'id': '_1broker',
    'name': '1Broker',
    'countries': 'US',
    'rateLimit': 1500,
    'version': 'v2',
    'hasPublicAPI': false,
    'hasCORS': true,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '60',
        '15m': '900',
        '1h': '3600',
        '1d': '86400',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766021-420bd9fc-5ecb-11e7-8ed6-56d0081efed2.jpg',
        'api': 'https://1broker.com/api',
        'www': 'https://1broker.com',
        'doc': 'https://1broker.com/?c=en/content/api-documentation',
    },
    'api': {
        'private': {
            'get': [
                'market/bars',
                'market/categories',
                'market/details',
                'market/list',
                'market/quotes',
                'market/ticks',
                'order/cancel',
                'order/create',
                'order/open',
                'position/close',
                'position/close_cancel',
                'position/edit',
                'position/history',
                'position/open',
                'position/shared/get',
                'social/profile_statistics',
                'social/profile_trades',
                'user/bitcoin_deposit_address',
                'user/details',
                'user/overview',
                'user/quota_status',
                'user/transaction_log',
            ],
        },
    },

    async fetchCategories () {
        let response = await this.privateGetMarketCategories ();
        // they return an empty string among their categories, wtf?
        let categories = response['response'];
        let result = [];
        for (let i = 0; i < categories.length; i++) {
            if (categories[i])
                result.push (categories[i]);
        }
        return result;
    },

    async fetchMarkets () {
        let this_ = this; // workaround for Babel bug (not passing `this` to _recursive() call)
        let categories = await this.fetchCategories ();
        let result = [];
        for (let c = 0; c < categories.length; c++) {
            let category = categories[c];
            let markets = await this_.privateGetMarketList ({
                'category': category.toLowerCase (),
            });
            for (let p = 0; p < markets['response'].length; p++) {
                let market = markets['response'][p];
                let id = market['symbol'];
                let symbol = undefined;
                let base = undefined;
                let quote = undefined;
                if ((category == 'FOREX') || (category == 'CRYPTO')) {
                    symbol = market['name'];
                    let parts = symbol.split ('/');
                    base = parts[0];
                    quote = parts[1];
                } else {
                    base = id;
                    quote = 'USD';
                    symbol = base + '/' + quote;
                }
                base = this_.commonCurrencyCode (base);
                quote = this_.commonCurrencyCode (quote);
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                });
            }
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privateGetUserOverview ();
        let response = balance['response'];
        let result = {
            'info': response,
        };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            result[currency] = this.account ();
        }
        let total = parseFloat (response['balance']);
        result['BTC']['free'] = total;
        result['BTC']['total'] = total;
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMarketQuotes (this.extend ({
            'symbols': this.marketId (symbol),
        }, params));
        let orderbook = response['response'][0];
        let timestamp = this.parse8601 (orderbook['updated']);
        let bidPrice = parseFloat (orderbook['bid']);
        let askPrice = parseFloat (orderbook['ask']);
        let bid = [ bidPrice, undefined ];
        let ask = [ askPrice, undefined ];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'bids': [ bid ],
            'asks': [ ask ],
        };
    },

    async fetchTrades (symbol) {
        throw new ExchangeError (this.id + ' fetchTrades () method not implemented yet');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let result = await this.privateGetMarketBars ({
            'symbol': this.marketId (symbol),
            'resolution': 60,
            'limit': 1,
        });
        let orderbook = await this.fetchOrderBook (symbol);
        let ticker = result['response'][0];
        let timestamp = this.parse8601 (ticker['date']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h']),
            'low': parseFloat (ticker['l']),
            'bid': orderbook['bids'][0][0],
            'ask': orderbook['asks'][0][0],
            'vwap': undefined,
            'open': parseFloat (ticker['o']),
            'close': parseFloat (ticker['c']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
        };
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date']),
            parseFloat (ohlcv['o']),
            parseFloat (ohlcv['h']),
            parseFloat (ohlcv['l']),
            parseFloat (ohlcv['c']),
            undefined,
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'resolution': this.timeframes[timeframe],
        };
        if (since)
            request['date_start'] = this.iso8601 (since); // they also support date_end
        if (limit)
            request['limit'] = limit;
        let result = await this.privateGetMarketBars (this.extend (request, params));
        return this.parseOHLCVs (result['response'], market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'margin': amount,
            'direction': (side == 'sell') ? 'short' : 'long',
            'leverage': 1,
            'type': side,
        };
        if (type == 'limit')
            order['price'] = price;
        else
            order['type'] += '_market';
        let result = await this.privateGetOrderCreate (this.extend (order, params));
        return {
            'info': result,
            'id': result['response']['order_id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostOrderCancel ({ 'order_id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests');
        let url = this.urls['api'] + '/' + this.version + '/' + path + '.php';
        let query = this.extend ({ 'token': this.apiKey }, params);
        url += '?' + this.urlencode (query);
        let response = await this.fetch (url, method);
        if ('warning' in response)
            if (response['warning'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var cryptocapital = {

    'id': 'cryptocapital',
    'name': 'Crypto Capital',
    'comment': 'Crypto Capital API',
    'countries': 'PA', // Panama
    'hasFetchOHLCV': true,
    'hasWithdraw': true,
    'timeframes': {
        '1d': '1year',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27993158-7a13f140-64ac-11e7-89cc-a3b441f0b0f8.jpg',
        'www': 'https://cryptocapital.co',
        'doc': 'https://github.com/cryptocap',
    },
    'api': {
        'public': {
            'get': [
                'stats',
                'historical-prices',
                'order-book',
                'transactions',
            ],
        },
        'private': {
            'post': [
                'balances-and-info',
                'open-orders',
                'user-transactions',
                'btc-deposit-address/get',
                'btc-deposit-address/new',
                'deposits/get',
                'withdrawals/get',
                'orders/new',
                'orders/edit',
                'orders/cancel',
                'orders/status',
                'withdrawals/new',
            ],
        },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalancesAndInfo ();
        let balance = response['balances-and-info'];
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            account['free'] = this.safeFloat (balance['available'], currency, 0.0);
            account['used'] = this.safeFloat (balance['on_hold'], currency, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currency': this.marketId (market),
        }, params));
        let timestamp = this.milliseconds ();
        let orderbook = response['order-book'];
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask', 'price', 'order_amount');
    },

    async fetchTicker (market) {
        let response = await this.publicGetStats ({
            'currency': this.marketId (market),
        });
        let ticker = response['stats'];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['max']),
            'low': parseFloat (ticker['min']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['daily_change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['total_btc_traded']),
        };
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        return [
            this.parse8601 (ohlcv['date'] + ' 00:00:00'),
            undefined,
            undefined,
            undefined,
            parseFloat (ohlcv['price']),
            undefined,
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetHistoricalPrices (this.extend ({
            'currency': market['id'],
            'timeframe': this.timeframes[timeframe],
        }, params));
        let ohlcvs = this.omit (response['historical-prices'], 'request_currency');
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['timestamp']) * 1000;
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['maker_type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currency': market['id'],
        }, params));
        let trades = this.omit (response['transactions'], 'request_currency');
        return this.parseTrades (trades, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'side': side,
            'type': type,
            'currency': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'limit')
            order['limit_price'] = price;
        let result = await this.privatePostOrdersNew (this.extend (order, params));
        return {
            'info': result,
            'id': result,
        };
    },

    cancelOrder (id) {
        return this.privatePostOrdersCancel ({ 'id': id });
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawalsNew (this.extend ({
            'currency': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'cryptocapital')
            throw new ExchangeError (this.id + ' is an abstract base API for _1btcxe');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let query = this.extend ({
                'api_key': this.apiKey,
                'nonce': this.nonce (),
            }, params);
            let request = this.json (query);
            query['signature'] = this.hmac (this.encode (request), this.encode (this.secret));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('errors' in response) {
            let errors = [];
            for (let e = 0; e < response['errors'].length; e++) {
                let error = response['errors'][e];
                errors.push (error['code'] + ': ' + error['message']);
            }
            errors = errors.join (' ');
            throw new ExchangeError (this.id + ' ' + errors);
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var _1btcxe = extend (cryptocapital, {

    'id': '_1btcxe',
    'name': '1BTCXE',
    'countries': 'PA', // Panama
    'comment': 'Crypto Capital API',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766049-2b294408-5ecc-11e7-85cc-adaff013dc1a.jpg',
        'api': 'https://1btcxe.com/api',
        'www': 'https://1btcxe.com',
        'doc': 'https://1btcxe.com/api-docs.php',
    },
    'markets': {
        'BTC/USD': { 'id': 'USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/EUR': { 'id': 'EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'BTC/CNY': { 'id': 'CNY', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
        'BTC/RUB': { 'id': 'RUB', 'symbol': 'BTC/RUB', 'base': 'BTC', 'quote': 'RUB' },
        'BTC/CHF': { 'id': 'CHF', 'symbol': 'BTC/CHF', 'base': 'BTC', 'quote': 'CHF' },
        'BTC/JPY': { 'id': 'JPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
        'BTC/GBP': { 'id': 'GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
        'BTC/CAD': { 'id': 'CAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
        'BTC/AUD': { 'id': 'AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
        'BTC/AED': { 'id': 'AED', 'symbol': 'BTC/AED', 'base': 'BTC', 'quote': 'AED' },
        'BTC/BGN': { 'id': 'BGN', 'symbol': 'BTC/BGN', 'base': 'BTC', 'quote': 'BGN' },
        'BTC/CZK': { 'id': 'CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK' },
        'BTC/DKK': { 'id': 'DKK', 'symbol': 'BTC/DKK', 'base': 'BTC', 'quote': 'DKK' },
        'BTC/HKD': { 'id': 'HKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
        'BTC/HRK': { 'id': 'HRK', 'symbol': 'BTC/HRK', 'base': 'BTC', 'quote': 'HRK' },
        'BTC/HUF': { 'id': 'HUF', 'symbol': 'BTC/HUF', 'base': 'BTC', 'quote': 'HUF' },
        'BTC/ILS': { 'id': 'ILS', 'symbol': 'BTC/ILS', 'base': 'BTC', 'quote': 'ILS' },
        'BTC/INR': { 'id': 'INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
        'BTC/MUR': { 'id': 'MUR', 'symbol': 'BTC/MUR', 'base': 'BTC', 'quote': 'MUR' },
        'BTC/MXN': { 'id': 'MXN', 'symbol': 'BTC/MXN', 'base': 'BTC', 'quote': 'MXN' },
        'BTC/NOK': { 'id': 'NOK', 'symbol': 'BTC/NOK', 'base': 'BTC', 'quote': 'NOK' },
        'BTC/NZD': { 'id': 'NZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
        'BTC/PLN': { 'id': 'PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
        'BTC/RON': { 'id': 'RON', 'symbol': 'BTC/RON', 'base': 'BTC', 'quote': 'RON' },
        'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
        'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
        'BTC/THB': { 'id': 'THB', 'symbol': 'BTC/THB', 'base': 'BTC', 'quote': 'THB' },
        'BTC/TRY': { 'id': 'TRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY' },
        'BTC/ZAR': { 'id': 'ZAR', 'symbol': 'BTC/ZAR', 'base': 'BTC', 'quote': 'ZAR' },
    },
})

//-----------------------------------------------------------------------------

var acx = {

    'id': 'acx',
    'name': 'ACX',
    'countries': 'AU',
    'rateLimit': 1000,
    'version': 'v2',
    'hasCORS': true,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1',
        '5m': '5',
        '15m': '15',
        '30m': '30',
        '1h': '60',
        '2h': '120',
        '4h': '240',
        '12h': '720',
        '1d': '1440',
        '3d': '4320',
        '1w': '10080',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30247614-1fe61c74-9621-11e7-9e8c-f1a627afa279.jpg',
        'api': 'https://acx.io/api',
        'www': 'https://acx.io',
        'doc': 'https://acx.io/documents/api_v2',
    },
    'api': {
        'public': {
            'get': [
                'markets', // Get all available markets
                'tickers', // Get ticker of all markets
                'tickers/{market}', // Get ticker of specific market
                'trades', // Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                'order_book', // Get the order book of specified market
                'depth', // Get depth or specified market Both asks and bids are sorted from highest price to lowest.
                'k', // Get OHLC(k line) of specific market
                'k_with_pending_trades', // Get K data with pending trades, which are the trades not included in K data yet, because there's delay between trade generated and processed by K data generator
                'timestamp', // Get server current time, in seconds since Unix epoch
            ],
        },
        'private': {
            'get': [
                'members/me', // Get your profile and accounts info
                'deposits', // Get your deposits history
                'deposit', // Get details of specific deposit
                'deposit_address', // Where to deposit The address field could be empty when a new address is generating (e.g. for bitcoin), you should try again later in that case.
                'orders', // Get your orders, results is paginated
                'order', // Get information of specified order
                'trades/my', // Get your executed trades Trades are sorted in reverse creation order.
                'withdraws', // Get your cryptocurrency withdraws
                'withdraw', // Get your cryptocurrency withdraw
            ],
            'post': [
                'orders', // Create a Sell/Buy order
                'orders/multi', // Create multiple sell/buy orders
                'orders/clear', // Cancel all my orders
                'order/delete', // Cancel an order
                'withdraw', // Create a withdraw
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetMembersMe ();
        let balances = response['accounts'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': parseFloat (balance['balance']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'market': market['id'],
            'limit': 300,
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['at'] * 1000;
        ticker = ticker['ticker'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers ();
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                base = base.toUpperCase ();
                quote = quote.toUpperCase ();
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                let symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTickersMarket ({
            'market': market['id'],
        });
        return this.parseTicker (response, market);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        // looks like they switched this endpoint off
        // it returns 503 Service Temporarily Unavailable always
        // return this.parseTrades (reponse, market);
        return response;
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[5],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!limit)
            limit = 500; // default is 30
        let request = {
            'market': market['id'],
            'period': this.timeframes[timeframe],
            'limit': limit,
        };
        if (since)
            request['timestamp'] = since;
        let response = await this.publicGetK (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'market': this.marketId (symbol),
            'side': side,
            'volume': amount.toString (),
            'ord_type': type,
        };
        if (type == 'limit') {
            order['price'] = price.toString ();
        }
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostOrderDelete ({ 'id': id });
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'sum': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': undefined,
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/api' + '/' + this.version + '/' + this.implodeParams (path, params) + '.json';
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            let query = this.urlencode (this.keysort (this.extend ({
                'access_key': this.apiKey,
                'tonce': nonce,
            }, params)));
            let auth = method + '|' + request + '|' + query;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            let suffix = query + '&signature=' + signature;
            if (method == 'GET') {
                url += '?' + suffix;
            } else {
                body = suffix;
                headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
            }
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var anxpro = {

    'id': 'anxpro',
    'name': 'ANXPro',
    'countries': [ 'JP', 'SG', 'HK', 'NZ' ],
    'version': '2',
    'rateLimit': 1500,
    'hasCORS': false,
    'hasWithdraw': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27765983-fd8595da-5ec9-11e7-82e3-adb3ab8c2612.jpg',
        'api': 'https://anxpro.com/api',
        'www': 'https://anxpro.com',
        'doc': [
            'http://docs.anxv2.apiary.io',
            'https://anxpro.com/pages/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{currency_pair}/money/ticker',
                '{currency_pair}/money/depth/full',
                '{currency_pair}/money/trade/fetch', // disabled by ANXPro
            ],
        },
        'private': {
            'post': [
                '{currency_pair}/money/order/add',
                '{currency_pair}/money/order/cancel',
                '{currency_pair}/money/order/quote',
                '{currency_pair}/money/order/result',
                '{currency_pair}/money/orders',
                'money/{currency}/address',
                'money/{currency}/send_simple',
                'money/info',
                'money/trade/list',
                'money/wallet/history',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/HKD': { 'id': 'BTCHKD', 'symbol': 'BTC/HKD', 'base': 'BTC', 'quote': 'HKD' },
        'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'BTC/CAD': { 'id': 'BTCCAD', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
        'BTC/AUD': { 'id': 'BTCAUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
        'BTC/SGD': { 'id': 'BTCSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
        'BTC/JPY': { 'id': 'BTCJPY', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY' },
        'BTC/GBP': { 'id': 'BTCGBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
        'BTC/NZD': { 'id': 'BTCNZD', 'symbol': 'BTC/NZD', 'base': 'BTC', 'quote': 'NZD' },
        'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'DOGE/BTC': { 'id': 'DOGEBTC', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
        'STR/BTC': { 'id': 'STRBTC', 'symbol': 'STR/BTC', 'base': 'STR', 'quote': 'BTC' },
        'XRP/BTC': { 'id': 'XRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostMoneyInfo ();
        let balance = response['data'];
        let currencies = Object.keys (balance['Wallets']);
        let result = { 'info': balance };
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = this.account ();
            if (currency in balance['Wallets']) {
                let wallet = balance['Wallets'][currency];
                account['free'] = parseFloat (wallet['Available_Balance']['value']);
                account['total'] = parseFloat (wallet['Balance']['value']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let response = await this.publicGetCurrencyPairMoneyDepthFull (this.extend ({
            'currency_pair': this.marketId (market),
        }, params));
        let orderbook = response['data'];
        let t = parseInt (orderbook['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (market) {
        let response = await this.publicGetCurrencyPairMoneyTicker ({
            'currency_pair': this.marketId (market),
        });
        let ticker = response['data'];
        let t = parseInt (ticker['dataUpdateTime']);
        let timestamp = parseInt (t / 1000);
        let bid = this.safeFloat (ticker['buy'], 'value');
        let ask = this.safeFloat (ticker['sell'], 'value');;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']['value']),
            'low': parseFloat (ticker['low']['value']),
            'bid': bid,
            'ask': ask,
            'vwap': parseFloat (ticker['vwap']['value']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']['value']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']['value']),
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']['value']),
        };
    },

    async fetchTrades (market, params = {}) {
        let error = this.id + ' switched off the trades endpoint, see their docs at http://docs.anxv2.apiary.io/reference/market-data/currencypairmoneytradefetch-disabled';
        throw new ExchangeError (error);
        return this.publicGetCurrencyPairMoneyTradeFetch (this.extend ({
            'currency_pair': this.marketId (market),
        }, params));
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let order = {
            'currency_pair': this.marketId (market),
            'amount_int': parseInt (amount * 100000000), // 10^8
            'type': side,
        };
        if (type == 'limit')
            order['price_int'] = parseInt (price * 100000); // 10^5
        let result = await this.privatePostCurrencyPairOrderAdd (this.extend (order, params));
        return {
            'info': result,
            'id': result['data']
        };
    },

    async cancelOrder (id) {
        return this.privatePostCurrencyPairOrderCancel ({ 'oid': id });
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostMoneyCurrencySendSimple (this.extend ({
            'currency': currency,
            'amount_int': parseInt (amount * 100000000), // 10^8
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': this.decode (signature),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response)
            if (response['result'] == 'success')
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var binance = {

    'id': 'binance',
    'name': 'Binance',
    'countries': 'CN', // China
    'rateLimit': 1000,
    'version': 'v1',
    'hasCORS': false,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1m',
        '3m': '3m',
        '5m': '5m',
        '15m': '15m',
        '30m': '30m',
        '1h': '1h',
        '2h': '2h',
        '4h': '4h',
        '6h': '6h',
        '8h': '8h',
        '12h': '12h',
        '1d': '1d',
        '3d': '3d',
        '1w': '1w',
        '1M': '1M',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
        'api': 'https://www.binance.com/api',
        'www': 'https://www.binance.com',
        'doc': 'https://www.binance.com/restapipub.html',
        'fees': 'https://binance.zendesk.com/hc/en-us/articles/115000429332',
    },
    'api': {
        'public': {
            'get': [
                'ping',
                'time',
                'depth',
                'aggTrades',
                'klines',
                'ticker/24hr',
            ],
        },
        'private': {
            'get': [
                'order',
                'openOrders',
                'allOrders',
                'account',
                'myTrades',
            ],
            'post': [
                'order',
                'order/test',
                'userDataStream',
            ],
            'put': [
                'userDataStream'
            ],
            'delete': [
                'order',
                'userDataStream',
            ],
        },
    },
    'fees': {
        'trading': {
            'taker': 0.001,
            'maker': 0.001,
        },
        'funding': {
            'withdraw': {
                'BNB': 1.0,
                'BTC': 0.0005,
                'ETH': 0.005,
                'LTC': 0.001,
                'NEO': 0.0,
                'QTUM': 0.1,
                'SNT': 1.0,
                'EOS': 0.1,
                'BCC': undefined,
                'GAS': 0.0,
                'USDT': 5.0,
                'HSR': 0.0001,
                'OAX': 0.1,
                'DNT': 1.0,
                'MCO': 0.1,
                'ICN': 0.1,
                'WTC': 0.1,
                'OMG': 0.1,
                'ZRX': 1.0,
                'STRAT': 0.1,
                'SNGLS': 1.0,
                'BQX': 1.0,
            },
        },
    },
    'markets': {
        'BNB/BTC': { 'id': 'BNBBTC', 'symbol': 'BNB/BTC', 'base': 'BNB', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'NEO/BTC': { 'id': 'NEOBTC', 'symbol': 'NEO/BTC', 'base': 'NEO', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'HSR/BTC': { 'id': 'HSRBTC', 'symbol': 'HSR/BTC', 'base': 'HSR', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'GAS/BTC': { 'id': 'GASBTC', 'symbol': 'GAS/BTC', 'base': 'GAS', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'HCC/BTC': { 'id': 'HCCBTC', 'symbol': 'HCC/BTC', 'base': 'HCC', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'BCH/BTC': { 'id': 'BCCBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'taker': 0.001, 'maker': 0.001 },
        'BNB/ETH': { 'id': 'BNBETH', 'symbol': 'BNB/ETH', 'base': 'BNB', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'DNT/ETH': { 'id': 'DNTETH', 'symbol': 'DNT/ETH', 'base': 'DNT', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'OAX/ETH': { 'id': 'OAXETH', 'symbol': 'OAX/ETH', 'base': 'OAX', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'MCO/ETH': { 'id': 'MCOETH', 'symbol': 'MCO/ETH', 'base': 'MCO', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'BTM/ETH': { 'id': 'BTMETH', 'symbol': 'BTM/ETH', 'base': 'BTM', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'SNT/ETH': { 'id': 'SNTETH', 'symbol': 'SNT/ETH', 'base': 'SNT', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'EOS/ETH': { 'id': 'EOSETH', 'symbol': 'EOS/ETH', 'base': 'EOS', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'BNT/ETH': { 'id': 'BNTETH', 'symbol': 'BNT/ETH', 'base': 'BNT', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'ICN/ETH': { 'id': 'ICNETH', 'symbol': 'ICN/ETH', 'base': 'ICN', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
        'BTC/USDT': { 'id': 'BTCUSDT', 'symbol': 'BTC/USDT', 'base': 'BTC', 'quote': 'USDT', 'taker': 0.001, 'maker': 0.001 },
        'ETH/USDT': { 'id': 'ETHUSDT', 'symbol': 'ETH/USDT', 'base': 'ETH', 'quote': 'USDT', 'taker': 0.001, 'maker': 0.001 },
        'QTUM/ETH': { 'id': 'QTUMETH', 'symbol': 'QTUM/ETH', 'base': 'QTUM', 'quote': 'ETH', 'taker': 0.001, 'maker': 0.001 },
    },

    calculateFeeRate (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let key = (side == 'sell') ? 'base' : 'quote';
        let market = this.markets[symbol];
        return { 'currency': market[key], 'rate': market[takerOrMaker] };
    },

    async fetchBalance (params = {}) {
        let response = await this.privateGetAccount ();
        let result = { 'info': response };
        let balances = response['balances'];
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let asset = balance['asset'];
            let currency = this.commonCurrencyCode (asset);
            let account = {
                'free': parseFloat (balance['free']),
                'used': parseFloat (balance['locked']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'symbol': market['id'],
            'limit': 100, // default = maximum = 100
        }, params));
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['closeTime'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['highPrice']),
            'low': parseFloat (ticker['lowPrice']),
            'bid': parseFloat (ticker['bidPrice']),
            'ask': parseFloat (ticker['askPrice']),
            'vwap': parseFloat (ticker['weightedAvgPrice']),
            'open': parseFloat (ticker['openPrice']),
            'close': parseFloat (ticker['prevClosePrice']),
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': parseFloat (ticker['priceChangePercent']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let response = await this.publicGetTicker24hr ({
            'symbol': market['id'],
        });
        return this.parseTicker (response, market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0],
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[5]),
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'interval': this.timeframes[timeframe],
        };
        request['limit'] = (limit) ? limit : 500; // default == max == 500
        if (since)
            request['startTime'] = since;
        let response = await this.publicGetKlines (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    parseTrade (trade, market = undefined) {
        let timestampField = ('T' in trade) ? 'T' : 'time';
        let timestamp = trade[timestampField];
        let priceField = ('p' in trade) ? 'p' : 'price';
        let price = parseFloat (trade[priceField]);
        let amountField = ('q' in trade) ? 'q' : 'qty';
        let amount = parseFloat (trade[amountField]);
        let idField = ('a' in trade) ? 'a' : 'id';
        let id = trade[idField].toString ();
        let side = undefined;
        if ('m' in trade) {
            side = 'sell';
            if (trade['m'])
                side = 'buy';
        } else {
            let isBuyer = trade['isBuyer'];
            let isMaker = trade['isMaker'];
            if (isBuyer) {
                side = isMaker ? 'sell' : 'buy';
            } else {
                side = isMaker ? 'buy' : 'sell';
            }
        }
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'type': undefined,
            'side': side,
            'price': price,
            'amount': amount,
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetAggTrades (this.extend ({
            'symbol': market['id'],
            // 'fromId': 123,    // ID to get aggregate trades from INCLUSIVE.
            // 'startTime': 456, // Timestamp in ms to get aggregate trades from INCLUSIVE.
            // 'endTime': 789,   // Timestamp in ms to get aggregate trades until INCLUSIVE.
            'limit': 500,        // default = maximum = 500
        }, params));
        return this.parseTrades (response, market);
    },

    parseOrderStatus (status) {
        if (status == 'NEW')
            return 'open';
        if (status == 'PARTIALLY_FILLED')
            return 'open';
        if (status == 'FILLED')
            return 'closed';
        if (status == 'CANCELED')
            return 'canceled';
        return status.toLowerCase ();
    },

    parseOrder (order, market = undefined) {
        let status = this.parseOrderStatus (order['status']);
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let id = order['symbol'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = order['time'];
        let amount = parseFloat (order['origQty']);
        let filled = this.safeFloat (order, 'executedQty', 0.0);
        let remaining = Math.max (amount - filled, 0.0);
        let result = {
            'info': order,
            'id': order['orderId'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': order['type'].toLowerCase (),
            'side': order['side'].toLowerCase (),
            'price': parseFloat (order['price']),
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
        };
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        price = parseFloat (price);
        let order = {
            'symbol': this.marketId (symbol),
            'quantity': amount.toFixed (8),
            'price': price.toFixed (8),
            'type': type.toUpperCase (),
            'side': side.toUpperCase (),
            'timeInForce': 'GTC', // Good To Cancel (default)
            // 'timeInForce': 'IOC', // Immediate Or Cancel
        };
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderId'].toString (),
        };
    },

    async fetchOrder (id, params = {}) {
        let symbol = ('symbol' in params);
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOrder requires a symbol param');
        symbol = params['symbol'];
        let market = this.market (symbol);
        let query = this.omit (params, 'symbol');
        let response = await this.privateGetOrder (this.extend ({
            'symbol': market['id'],
            'orderId': id.toString (),
        }, query));
        return this.parseOrder (response, market);
    },

    async fetchOrders (params = {}) {
        if ('symbol' in params) {
            let symbol = params['symbol'];
            let market = this.market (symbol);
            let query = this.omit (params, 'symbol');
            let response = await this.privateGetAllOrders (this.extend ({
                'symbol': market['id'],
            }, query));
            return this.parseOrders (response, market);
        }
        throw new ExchangeError (this.id + ' fetchOrders requires a symbol param');
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        let market = this.market (symbol);
        let response = await this.privateGetOpenOrders (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseOrders (response, market);
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostOrderCancel (this.extend ({
            'orderId': parseInt (id),
            // 'origClientOrderId': id,
        }, params));
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            let query = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            let auth = this.secret + '|' + query;
            let signature = this.hash (this.encode (auth), 'sha256');
            query += '&' + 'signature=' + signature;
            headers = {
                'X-MBX-APIKEY': this.apiKey,
            };
            if (method == 'GET') {
                url += '?' + query;
            } else {
                body = query;
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }
        let response = await this.fetch (url, method, headers, body);
        if ('code' in response) {
            if (response['code'] < 0)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var bit2c = {

    'id': 'bit2c',
    'name': 'Bit2C',
    'countries': 'IL', // Israel
    'rateLimit': 3000,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
        'api': 'https://www.bit2c.co.il',
        'www': 'https://www.bit2c.co.il',
        'doc': [
            'https://www.bit2c.co.il/home/api',
            'https://github.com/OferE/bit2c',
        ],
    },
    'api': {
        'public': {
            'get': [
                'Exchanges/{pair}/Ticker',
                'Exchanges/{pair}/orderbook',
                'Exchanges/{pair}/trades',
            ],
        },
        'private': {
            'post': [
                'Account/Balance',
                'Account/Balance/v2',
                'Merchant/CreateCheckout',
                'Order/AccountHistory',
                'Order/AddCoinFundsRequest',
                'Order/AddFund',
                'Order/AddOrder',
                'Order/AddOrderMarketPriceBuy',
                'Order/AddOrderMarketPriceSell',
                'Order/CancelOrder',
                'Order/MyOrders',
                'Payment/GetMyId',
                'Payment/Send',
            ],
        },
    },
    'markets': {
        'BTC/NIS': { 'id': 'BtcNis', 'symbol': 'BTC/NIS', 'base': 'BTC', 'quote': 'NIS' },
        'LTC/BTC': { 'id': 'LtcBtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'LTC/NIS': { 'id': 'LtcNis', 'symbol': 'LTC/NIS', 'base': 'LTC', 'quote': 'NIS' },
    },

    async fetchBalance (params = {}) {
        let balance = await this.privatePostAccountBalanceV2 ();
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balance) {
                let available = 'AVAILABLE_' + currency;
                account['free'] = balance[available];
                account['total'] = balance[currency];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let orderbook = await this.publicGetExchangesPairOrderbook (this.extend ({
            'pair': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (market) {
        let ticker = await this.publicGetExchangesPairTicker ({
            'pair': this.marketId (market),
        });
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h']),
            'low': parseFloat (ticker['l']),
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ll']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['av']),
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['a']),
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetExchangesPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostOrderAddOrder';
        let order = {
            'Amount': amount,
            'Pair': this.marketId (symbol),
        };
        if (type == 'market') {
            method += 'MarketPrice' + this.capitalize (side);
        } else {
            order['Price'] = price;
            order['Total'] = amount * price;
            order['IsBid'] = (side == 'buy');
        }
        let result = await this[method] (this.extend (order, params));
        return {
            'info': result,
            'id': result['NewOrder']['id'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostOrderCancelOrder ({ 'id': id });
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        if (api == 'public') {
            url += '.json';
        } else {
            let nonce = this.nonce ();
            let query = this.extend ({ 'nonce': nonce }, params);
            body = this.urlencode (query);
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sign': this.decode (signature),
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bitbay = {

    'id': 'bitbay',
    'name': 'BitBay',
    'countries': [ 'PL', 'EU' ], // Poland
    'rateLimit': 1000,
    'hasCORS': true,
    'hasWithdraw': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
        'www': 'https://bitbay.net',
        'api': {
            'public': 'https://bitbay.net/API/Public',
            'private': 'https://bitbay.net/API/Trading/tradingApi.php',
        },
        'doc': [
            'https://bitbay.net/public-api',
            'https://bitbay.net/account/tab-api',
            'https://github.com/BitBayNet/API',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{id}/all',
                '{id}/market',
                '{id}/orderbook',
                '{id}/ticker',
                '{id}/trades',
            ],
        },
        'private': {
            'post': [
                'info',
                'trade',
                'cancel',
                'orderbook',
                'orders',
                'transfer',
                'withdraw',
                'history',
                'transactions',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'BTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
        'LTC/USD': { 'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
        'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
        'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
        'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'ETH/USD': { 'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
        'ETH/EUR': { 'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR' },
        'ETH/PLN': { 'id': 'ETHPLN', 'symbol': 'ETH/PLN', 'base': 'ETH', 'quote': 'PLN' },
        'ETH/BTC': { 'id': 'ETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
        'LSK/USD': { 'id': 'LSKUSD', 'symbol': 'LSK/USD', 'base': 'LSK', 'quote': 'USD' },
        'LSK/EUR': { 'id': 'LSKEUR', 'symbol': 'LSK/EUR', 'base': 'LSK', 'quote': 'EUR' },
        'LSK/PLN': { 'id': 'LSKPLN', 'symbol': 'LSK/PLN', 'base': 'LSK', 'quote': 'PLN' },
        'LSK/BTC': { 'id': 'LSKBTC', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        let balance = response['balances'];
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balance) {
                account['free'] = parseFloat (balance[currency]['available']);
                account['used'] = parseFloat (balance[currency]['locked']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let orderbook = await this.publicGetIdOrderbook (this.extend ({
            'id': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (market) {
        let ticker = await this.publicGetIdTicker ({
            'id': this.marketId (market),
        });
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['max']),
            'low': parseFloat (ticker['min']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['average']),
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        return this.privatePostTrade (this.extend ({
            'type': side,
            'currency': market['base'],
            'amount': amount,
            'payment_currency': market['quote'],
            'rate': price,
        }, params));
    },

    async cancelOrder (id) {
        return this.privatePostCancel ({ 'id': id });
    },

    isFiat (currency) {
        let fiatCurrencies = {
            'USD': true,
            'EUR': true,
            'PLN': true,
        };
        if (currency in fiatCurrencies)
            return true;
        return false;
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdraw';
            // request['account'] = params['account']; // they demand an account number
            // request['express'] = params['express']; // whatever it means, they don't explain
            // request['bic'] = '';
        } else {
            method = 'privatePostTransfer';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': undefined,
        };
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params) + '.json';
        } else {
            body = this.urlencode (this.extend ({
                'method': path,
                'moment': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bitcoincoid = {

    'id': 'bitcoincoid',
    'name': 'Bitcoin.co.id',
    'countries': 'ID', // Indonesia
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766138-043c7786-5ecf-11e7-882b-809c14f38b53.jpg',
        'api': {
            'public': 'https://vip.bitcoin.co.id/api',
            'private': 'https://vip.bitcoin.co.id/tapi',
        },
        'www': 'https://www.bitcoin.co.id',
        'doc': [
            'https://vip.bitcoin.co.id/downloads/BITCOINCOID-API-DOCUMENTATION.pdf',
            'https://vip.bitcoin.co.id/trade_api',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{pair}/ticker',
                '{pair}/trades',
                '{pair}/depth',
            ],
        },
        'private': {
            'post': [
                'getInfo',
                'transHistory',
                'trade',
                'tradeHistory',
                'openOrders',
                'cancelOrder',
            ],
        },
    },
    'markets': {
        'BTC/IDR':  { 'id': 'btc_idr', 'symbol': 'BTC/IDR', 'base': 'BTC', 'quote': 'IDR', 'baseId': 'btc', 'quoteId': 'idr' },
        'BCH/IDR':  { 'id': 'bch_idr', 'symbol': 'BCH/IDR', 'base': 'BCH', 'quote': 'IDR', 'baseId': 'bch', 'quoteId': 'idr' },
        'ETH/IDR':  { 'id': 'eth_idr', 'symbol': 'ETH/IDR', 'base': 'ETH', 'quote': 'IDR', 'baseId': 'eth', 'quoteId': 'idr' },
        'ETC/IDR':  { 'id': 'etc_idr', 'symbol': 'ETC/IDR', 'base': 'ETC', 'quote': 'IDR', 'baseId': 'etc', 'quoteId': 'idr' },
        'XRP/IDR':  { 'id': 'xrp_idr', 'symbol': 'XRP/IDR', 'base': 'XRP', 'quote': 'IDR', 'baseId': 'xrp', 'quoteId': 'idr' },
        'XZC/IDR':  { 'id': 'xzc_idr', 'symbol': 'XZC/IDR', 'base': 'XZC', 'quote': 'IDR', 'baseId': 'xzc', 'quoteId': 'idr' },
        'BTS/BTC':  { 'id': 'bts_btc', 'symbol': 'BTS/BTC', 'base': 'BTS', 'quote': 'BTC', 'baseId': 'bts', 'quoteId': 'btc' },
        'DASH/BTC': { 'id': 'drk_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'drk', 'quoteId': 'btc' },
        'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'baseId': 'doge', 'quoteId': 'btc' },
        'ETH/BTC':  { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc' },
        'LTC/BTC':  { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc' },
        'NXT/BTC':  { 'id': 'nxt_btc', 'symbol': 'NXT/BTC', 'base': 'NXT', 'quote': 'BTC', 'baseId': 'nxt', 'quoteId': 'btc' },
        'XLM/BTC':  { 'id': 'str_btc', 'symbol': 'XLM/BTC', 'base': 'XLM', 'quote': 'BTC', 'baseId': 'str', 'quoteId': 'btc' },
        'XEM/BTC':  { 'id': 'nem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC', 'baseId': 'nem', 'quoteId': 'btc' },
        'XRP/BTC':  { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetInfo ();
        let balance = response['return'];
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balance['balance'], lowercase, 0.0);
            account['used'] = this.safeFloat (balance['balance_hold'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetPairDepth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell');
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTicker ({
            'pair': market['id'],
        });
        let ticker = response['ticker'];
        let timestamp = parseFloat (ticker['server_time']) * 1000;
        let baseVolume = 'vol_' + market['baseId'].toLowerCase ();
        let quoteVolume = 'vol_' + market['quoteId'].toLowerCase ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker[baseVolume]),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetPairTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'pair': market['id'],
            'type': side,
            'price': price,
        };
        let base = market['base'].toLowerCase ();
        order[base] = amount;
        let result = this.privatePostTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['return']['order_id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path, params);
        } else {
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': this.nonce (),
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        return response;
    },
}

//-----------------------------------------------------------------------------

var bitfinex = {

    'id': 'bitfinex',
    'name': 'Bitfinex',
    'countries': 'US',
    'version': 'v1',
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchTickers': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
        'api': 'https://api.bitfinex.com',
        'www': 'https://www.bitfinex.com',
        'doc': [
            'https://bitfinex.readme.io/v1/docs',
            'https://github.com/bitfinexcom/bitfinex-api-node',
        ],
    },
    'api': {
        'public': {
            'get': [
                'book/{symbol}',
                // 'candles/{symbol}',
                'lendbook/{currency}',
                'lends/{currency}',
                'pubticker/{symbol}',
                'stats/{symbol}',
                'symbols',
                'symbols_details',
                'today',
                'trades/{symbol}',
            ],
        },
        'private': {
            'post': [
                'account_infos',
                'balances',
                'basket_manage',
                'credits',
                'deposit/new',
                'funding/close',
                'history',
                'history/movements',
                'key_info',
                'margin_infos',
                'mytrades',
                'mytrades_funding',
                'offer/cancel',
                'offer/new',
                'offer/status',
                'offers',
                'offers/hist',
                'order/cancel',
                'order/cancel/all',
                'order/cancel/multi',
                'order/cancel/replace',
                'order/new',
                'order/new/multi',
                'order/status',
                'orders',
                'orders/hist',
                'position/claim',
                'positions',
                'summary',
                'taken_funds',
                'total_taken_funds',
                'transfer',
                'unused_taken_funds',
                'withdraw',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetSymbolsDetails ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['pair'].toUpperCase ();
            let baseId = id.slice (0, 3);
            let quoteId = id.slice (3, 6);
            let base = baseId;
            let quote = quoteId;
            // issue #4 Bitfinex names Dash as DSH, instead of DASH
            if (base == 'DSH')
                base = 'DASH';
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance () {
        await this.loadMarkets ();
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            if (balance['type'] == 'exchange') {
                let currency = balance['currency'];
                let uppercase = currency.toUpperCase ();
                // issue #4 Bitfinex names dash as dsh
                if (uppercase == 'DSH')
                    uppercase = 'DASH';
                let account = this.account ();
                account['free'] = parseFloat (balance['available']);
                account['total'] = parseFloat (balance['amount']);
                account['used'] = account['total'] - account['free'];
                result[uppercase] = account;
            }
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let ticker = await this.publicGetPubtickerSymbol ({
            'symbol': this.marketId (symbol),
        });
        let timestamp = parseFloat (ticker['timestamp']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['mid']),
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['timestamp'] * 1000;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = type;
        if ((type == 'limit') || (type == 'market'))
            orderType = 'exchange ' + type;
        let order = {
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'side': side,
            'type': orderType,
            'ocoorder': false,
            'buy_price_oco': 0,
            'sell_price_oco': 0,
        };
        if (type == 'market') {
            order['price'] = this.nonce ().toString ();
        } else {
            order['price'] = price.toString ();
        }
        let result = await this.privatePostOrderNew (this.extend (order, params));
        return {
            'info': result,
            'id': result['order_id'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostOrderCancel ({ 'order_id': parseInt (id) });
    },

    parseOrder (order, market = undefined) {
        let side = order['side'];
        let open = order['is_live'];
        let canceled = order['is_cancelled'];
        let status = undefined;
        if (open) {
            status = 'open';
        } else if (canceled) {
            status = 'canceled';
        } else {
            status = 'closed';
        }
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let exchange = order['symbol'].toUpperCase ();
            if (exchange in this.markets_by_id) {
                market = this.markets_by_id[exchange];
                symbol = market['symbol'];
            }
        }
        let orderType = order['type'];
        let exchange = orderType.indexOf ('exchange ') >= 0;
        if (exchange) {
            let [ prefix, orderType ] = order['type'].split (' ');
        }
        let timestamp = parseInt (parseFloat (order['timestamp']) * 1000);
        let result = {
            'info': order,
            'id': order['id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': orderType,
            'side': side,
            'price': parseFloat (order['price']),
            'amount': parseFloat (order['original_amount']),
            'remaining': parseFloat (order['remaining_amount']),
            'status': status,
        };
        return result;
    },

    async fetchOrder (id, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus (this.extend ({
            'order_id': parseInt (id),
        }, params));
        return this.parseOrder (response);
    },

    getCurrencyName (currency) {
        if (currency == 'BTC') {
            return 'bitcoin';
        } else if (currency == 'LTC') {
            return 'litecoin';
        } else if (currency == 'ETH') {
            return 'ethereum';
        } else if (currency == 'ETC') {
            return 'ethereumc';
        } else if (currency == 'OMNI') {
            return 'mastercoin'; // ???
        } else if (currency == 'ZEC') {
            return 'zcash';
        } else if (currency == 'XMR') {
            return 'monero';
        } else if (currency == 'USD') {
            return 'wire';
        } else if (currency == 'DASH') {
            return 'dash';
        } else if (currency == 'XRP') {
            return 'ripple';
        } else if (currency == 'EOS') {
            return 'eos';
        }
        throw new NotSupported (this.id + ' ' + currency + ' not supported for withdrawal');
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let name = this.getCurrencyName (currency);
        let response = await this.privatePostWithdraw (this.extend ({
            'withdraw_type': name,
            'walletselected': 'exchange',
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['withdrawal_id'],
        };
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            query = this.extend ({
                'nonce': nonce.toString (),
                'request': request,
            }, query);
            query = this.json (query);
            query = this.encode (query);
            let payload = this.stringToBase64 (query);
            let secret = this.encode (this.secret);
            let signature = this.hmac (payload, secret, 'sha384');
            headers = {
                'X-BFX-APIKEY': this.apiKey,
                'X-BFX-PAYLOAD': this.decode (payload),
                'X-BFX-SIGNATURE': signature,
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('message' in response) {
            if (response['message'].indexOf ('not enough exchange balance') >= 0)
                throw new InsufficientFunds (this.id + ' ' + this.json (response));
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var bitfinex2 = extend (bitfinex, {

    'id': 'bitfinex2',
    'name': 'Bitfinex v2',
    'countries': 'US',
    'version': 'v2',
    'hasCORS': true,
    'hasFetchTickers': false, // true but at least one pair is required
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1m',
        '5m': '5m',
        '15m': '15m',
        '30m': '30m',
        '1h': '1h',
        '3h': '3h',
        '6h': '6h',
        '12h': '12h',
        '1d': '1D',
        '1w': '7D',
        '2w': '14D',
        '1M': '1M',
    },
    'rateLimit': 1500,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
        'api': 'https://api.bitfinex.com',
        'www': 'https://www.bitfinex.com',
        'doc': [
            'https://bitfinex.readme.io/v2/docs',
            'https://github.com/bitfinexcom/bitfinex-api-node',
        ],
    },
    'api': {
        'public': {
            'get': [
                'platform/status',
                'tickers', // replies with an empty list :\
                'ticker/{symbol}',
                'trades/{symbol}/hist',
                'book/{symbol}/{precision}',
                'book/{symbol}/P0',
                'book/{symbol}/P1',
                'book/{symbol}/P2',
                'book/{symbol}/P3',
                'book/{symbol}/R0',
                'symbols_details',
                'stats1/{key}:{size}:{symbol}/{side}/{section}',
                'stats1/{key}:{size}:{symbol}/long/last',
                'stats1/{key}:{size}:{symbol}/long/hist',
                'stats1/{key}:{size}:{symbol}/short/last',
                'stats1/{key}:{size}:{symbol}/short/hist',
                'candles/trade:{timeframe}:{symbol}/{section}',
                'candles/trade:{timeframe}:{symbol}/last',
                'candles/trade:{timeframe}:{symbol}/hist',
            ],
            'post': [
                'calc/trade/avg',
            ],
        },
        'private': {
            'post': [
                'auth/r/wallets',
                'auth/r/orders/{symbol}',
                'auth/r/orders/{symbol}/new',
                'auth/r/orders/{symbol}/hist',
                'auth/r/order/{symbol}:{id}/trades',
                'auth/r/trades/{symbol}/hist',
                'auth/r/funding/offers/{symbol}',
                'auth/r/funding/offers/{symbol}/hist',
                'auth/r/funding/loans/{symbol}',
                'auth/r/funding/loans/{symbol}/hist',
                'auth/r/funding/credits/{symbol}',
                'auth/r/funding/credits/{symbol}/hist',
                'auth/r/funding/trades/{symbol}/hist',
                'auth/r/info/margin/{key}',
                'auth/r/info/funding/{key}',
                'auth/r/movements/{currency}/hist',
                'auth/r/stats/perf:{timeframe}/hist',
                'auth/r/alerts',
                'auth/w/alert/set',
                'auth/w/alert/{type}:{symbol}:{price}/del',
                'auth/calc/order/avail',
            ],
        },
    },
    'markets': {
        'BCC/BTC': { 'id': 'tBCCBTC', 'symbol': 'BCC/BTC', 'base': 'BCC', 'quote': 'BTC' },
        'BCC/USD': { 'id': 'tBCCUSD', 'symbol': 'BCC/USD', 'base': 'BCC', 'quote': 'USD' },
        'BCH/BTC': { 'id': 'tBCHBTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
        'BCH/ETH': { 'id': 'tBCHETH', 'symbol': 'BCH/ETH', 'base': 'BCH', 'quote': 'ETH' },
        'BCH/USD': { 'id': 'tBCHUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD' },
        'BCU/BTC': { 'id': 'tBCUBTC', 'symbol': 'BCU/BTC', 'base': 'BCU', 'quote': 'BTC' },
        'BCU/USD': { 'id': 'tBCUUSD', 'symbol': 'BCU/USD', 'base': 'BCU', 'quote': 'USD' },
        'BTC/USD': { 'id': 'tBTCUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'DASH/BTC': { 'id': 'tDSHBTC', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
        'DASH/USD': { 'id': 'tDSHUSD', 'symbol': 'DASH/USD', 'base': 'DASH', 'quote': 'USD' },
        'EOS/BTC': { 'id': 'tEOSBTC', 'symbol': 'EOS/BTC', 'base': 'EOS', 'quote': 'BTC' },
        'EOS/ETH': { 'id': 'tEOSETH', 'symbol': 'EOS/ETH', 'base': 'EOS', 'quote': 'ETH' },
        'EOS/USD': { 'id': 'tEOSUSD', 'symbol': 'EOS/USD', 'base': 'EOS', 'quote': 'USD' },
        'ETC/BTC': { 'id': 'tETCBTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
        'ETC/USD': { 'id': 'tETCUSD', 'symbol': 'ETC/USD', 'base': 'ETC', 'quote': 'USD' },
        'ETH/BTC': { 'id': 'tETHBTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
        'ETH/USD': { 'id': 'tETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
        'IOT/BTC': { 'id': 'tIOTBTC', 'symbol': 'IOT/BTC', 'base': 'IOT', 'quote': 'BTC' },
        'IOT/ETH': { 'id': 'tIOTETH', 'symbol': 'IOT/ETH', 'base': 'IOT', 'quote': 'ETH' },
        'IOT/USD': { 'id': 'tIOTUSD', 'symbol': 'IOT/USD', 'base': 'IOT', 'quote': 'USD' },
        'LTC/BTC': { 'id': 'tLTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'LTC/USD': { 'id': 'tLTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
        'OMG/BTC': { 'id': 'tOMGBTC', 'symbol': 'OMG/BTC', 'base': 'OMG', 'quote': 'BTC' },
        'OMG/ETH': { 'id': 'tOMGETH', 'symbol': 'OMG/ETH', 'base': 'OMG', 'quote': 'ETH' },
        'OMG/USD': { 'id': 'tOMGUSD', 'symbol': 'OMG/USD', 'base': 'OMG', 'quote': 'USD' },
        'RRT/BTC': { 'id': 'tRRTBTC', 'symbol': 'RRT/BTC', 'base': 'RRT', 'quote': 'BTC' },
        'RRT/USD': { 'id': 'tRRTUSD', 'symbol': 'RRT/USD', 'base': 'RRT', 'quote': 'USD' },
        'SAN/BTC': { 'id': 'tSANBTC', 'symbol': 'SAN/BTC', 'base': 'SAN', 'quote': 'BTC' },
        'SAN/ETH': { 'id': 'tSANETH', 'symbol': 'SAN/ETH', 'base': 'SAN', 'quote': 'ETH' },
        'SAN/USD': { 'id': 'tSANUSD', 'symbol': 'SAN/USD', 'base': 'SAN', 'quote': 'USD' },
        'XMR/BTC': { 'id': 'tXMRBTC', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC' },
        'XMR/USD': { 'id': 'tXMRUSD', 'symbol': 'XMR/USD', 'base': 'XMR', 'quote': 'USD' },
        'XRP/BTC': { 'id': 'tXRPBTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
        'XRP/USD': { 'id': 'tXRPUSD', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD' },
        'ZEC/BTC': { 'id': 'tZECBTC', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC' },
        'ZEC/USD': { 'id': 'tZECUSD', 'symbol': 'ZEC/USD', 'base': 'ZEC', 'quote': 'USD' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostAuthRWallets ();
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let [ type, currency, total, interest, available ] = balance;
            if (currency[0] == 't')
                currency = currency.slice (1);
            let uppercase = currency.toUpperCase ();
            // issue #4 Bitfinex names Dash as DSH, instead of DASH
            if (uppercase == 'DSH')
                uppercase = 'DASH';
            let account = this.account ();
            account['free'] = available;
            account['total'] = total;
            if (account['free'])
                account['used'] = account['total'] - account['free'];
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetBookSymbolPrecision (this.extend ({
            'symbol': this.marketId (symbol),
            'precision': 'R0',
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let i = 0; i < orderbook.length; i++) {
            let order = orderbook[i];
            let [ timestamp, price, amount ] = order;
            let side = (amount > 0) ? 'bids' : 'asks';
            amount = Math.abs (amount);
            result[side].push ([ price, amount, timestamp ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTickerSymbol ({
            'symbol': this.marketId (symbol),
        });
        let timestamp = this.milliseconds ();
        let [ bid, bidSize, ask, askSize, change, percentage, last, volume, high, low ] = ticker;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': high,
            'low': low,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': change,
            'percentage': percentage,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let [ id, timestamp, amount, price ] = trade;
        let side = (amount < 0) ? 'sell' : 'buy';
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': price,
            'amount': amount,
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbolHist (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['limit'] = limit;
        if (since)
            request['start'] = since;
        request = this.extend (request, params);
        let response = await this.publicGetCandlesTradeTimeframeSymbolHist (request);
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        throw new NotSupported (this.id + ' createOrder not implemented yet');
    },

    async cancelOrder (id) {
        throw new NotSupported (this.id + ' cancelOrder not implemented yet');
    },

    async fetchOrder (id, params = {}) {
        throw new NotSupported (this.id + ' fetchOrder not implemented yet');
    },

    async withdraw (currency, amount, address, params = {}) {
        throw new NotSupported (this.id + ' withdraw not implemented yet');
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        let url = this.urls['api'] + '/' + request;
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let auth = '/api' + '/' + request + nonce + body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha384');
            headers = {
                'bfx-nonce': nonce,
                'bfx-apikey': this.apiKey,
                'bfx-signature': signature,
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('message' in response) {
            if (response['message'].indexOf ('not enough exchange balance') >= 0)
                throw new InsufficientFunds (this.id + ' ' + this.json (response));
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
})

//-----------------------------------------------------------------------------

var bitflyer = {

    'id': 'bitflyer',
    'name': 'bitFlyer',
    'countries': 'JP',
    'version': 'v1',
    'rateLimit': 500,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg',
        'api': 'https://api.bitflyer.jp',
        'www': 'https://bitflyer.jp',
        'doc': 'https://bitflyer.jp/API',
    },
    'api': {
        'public': {
            'get': [
                'getmarkets',    // or 'markets'
                'getboard',      // or 'board'
                'getticker',     // or 'ticker'
                'getexecutions', // or 'executions'
                'gethealth',
                'getchats',
            ],
        },
        'private': {
            'get': [
                'getpermissions',
                'getbalance',
                'getcollateral',
                'getcollateralaccounts',
                'getaddresses',
                'getcoinins',
                'getcoinouts',
                'getbankaccounts',
                'getdeposits',
                'getwithdrawals',
                'getchildorders',
                'getparentorders',
                'getparentorder',
                'getexecutions',
                'getpositions',
                'gettradingcommission',
            ],
            'post': [
                'sendcoin',
                'withdraw',
                'sendchildorder',
                'cancelchildorder',
                'sendparentorder',
                'cancelparentorder',
                'cancelallchildorders',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['product_code'];
            let currencies = id.split ('_');
            let base = undefined;
            let quote = undefined;
            let symbol = id;
            let numCurrencies = currencies.length;
            if (numCurrencies == 1) {
                base = symbol.slice (0, 3);
                quote = symbol.slice (3, 6);
            } else if (numCurrencies == 2) {
                base = currencies[0];
                quote = currencies[1];
                symbol = base + '/' + quote;
            } else {
                base = currencies[1];
                quote = currencies[2];
            }
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = {};
        for (let b = 0; b < response.length; b++) {
            let account = response[b];
            let currency = account['currency_code'];
            balances[currency] = account;
        }
        let result = { 'info': response };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balances) {
                account['total'] = balances[currency]['amount'];
                account['free'] = balances[currency]['available'];
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBoard (this.extend ({
            'product_code': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'size');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTicker ({
            'product_code': this.marketId (symbol),
        });
        let timestamp = this.parse8601 (ticker['timestamp']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['ltp']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_by_product']),
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('side' in trade)
            if (trade['side']) {
                side = trade['side'].toLowerCase ();
                let id = side + '_child_order_acceptance_id';
                if (id in trade)
                    order = trade[id];
            }
        let timestamp = this.parse8601 (trade['exec_date']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['size'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExecutions (this.extend ({
            'product_code': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'product_code': this.marketId (symbol),
            'child_order_type': type.toUpperCase (),
            'side': side.toUpperCase (),
            'price': price,
            'size': amount,
        };
        let result = await this.privatePostSendchildorder (this.extend (order, params));
        return {
            'info': result,
            'id': result['child_order_acceptance_id'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostCancelchildorder (this.extend ({
            'parent_order_id': id,
        }, params));
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdraw (this.extend ({
            'currency_code': currency,
            'amount': amount,
            // 'bank_account_id': 1234,
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.version + '/';
        if (api == 'private')
            request += 'me/';
        request += path;
        if (method == 'GET') {
            if (Object.keys (params).length)
                request += '?' + this.urlencode (params);
        }
        let url = this.urls['api'] + request;
        if (api == 'private') {
            let nonce = this.nonce ().toString ();
            body = this.json (params);
            let auth = [ nonce, method, request, body ].join ('');
            headers = {
                'ACCESS-KEY': this.apiKey,
                'ACCESS-TIMESTAMP': nonce,
                'ACCESS-SIGN': this.hmac (this.encode (auth), this.secret),
                'Content-Type': 'application/json',
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bithumb = {

    'id': 'bithumb',
    'name': 'Bithumb',
    'countries': 'KR', // South Korea
    'rateLimit': 500,
    'hasCORS': true,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
        'api': {
            'public': 'https://api.bithumb.com/public',
            'private': 'https://api.bithumb.com',
        },
        'www': 'https://www.bithumb.com',
        'doc': 'https://www.bithumb.com/u1/US127',
    },
    'api': {
        'public': {
            'get': [
                'ticker/{currency}',
                'ticker/all',
                'orderbook/{currency}',
                'orderbook/all',
                'recent_transactions/{currency}',
                'recent_transactions/all',
            ],
        },
        'private': {
            'post': [
                'info/account',
                'info/balance',
                'info/wallet_address',
                'info/ticker',
                'info/orders',
                'info/user_transactions',
                'trade/place',
                'info/order_detail',
                'trade/cancel',
                'trade/btc_withdrawal',
                'trade/krw_deposit',
                'trade/krw_withdrawal',
                'trade/market_buy',
                'trade/market_sell',
            ],
        },
    },
    'markets': {
        'BTC/KRW': { 'id': 'BTC', 'symbol': 'BTC/KRW', 'base': 'BTC', 'quote': 'KRW' },
        'ETH/KRW': { 'id': 'ETH', 'symbol': 'ETH/KRW', 'base': 'ETH', 'quote': 'KRW' },
        'LTC/KRW': { 'id': 'LTC', 'symbol': 'LTC/KRW', 'base': 'LTC', 'quote': 'KRW' },
        'ETC/KRW': { 'id': 'ETC', 'symbol': 'ETC/KRW', 'base': 'ETC', 'quote': 'KRW' },
        'XRP/KRW': { 'id': 'XRP', 'symbol': 'XRP/KRW', 'base': 'XRP', 'quote': 'KRW' },
        'BCH/KRW': { 'id': 'BCH', 'symbol': 'BCH/KRW', 'base': 'BCH', 'quote': 'KRW' },
        'XMR/KRW': { 'id': 'XMR', 'symbol': 'XMR/KRW', 'base': 'XMR', 'quote': 'KRW' },
        'DASH/KRW': { 'id': 'DASH', 'symbol': 'DASH/KRW', 'base': 'DASH', 'quote': 'KRW' },
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfoBalance ();
        let result = { 'info': response };
        let balances = response['data'];
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            let lowercase = currency.toLowerCase ();
            account['total'] = this.safeFloat (balances, 'total_' + lowercase);
            account['used'] = this.safeFloat (balances, 'in_use_' + lowercase);
            account['free'] = this.safeFloat (balances, 'available_' + lowercase);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetOrderbookCurrency (this.extend ({
            'count': 50, // max = 50
            'currency': market['base'],
        }, params));
        let orderbook = response['data'];
        let timestamp = parseInt (orderbook['timestamp']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'quantity');
    },

    parseTicker (ticker, market) {
        let timestamp = parseInt (ticker['date']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'max_price'),
            'low': this.safeFloat (ticker, 'min_price'),
            'bid': this.safeFloat (ticker, 'buy_price'),
            'ask': this.safeFloat (ticker, 'sell_price'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'opening_price'),
            'close': this.safeFloat (ticker, 'closing_price'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last_trade'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'average_price'),
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'volume_1day'),
            'info': ticker,
        };
    },

    async fetchTickers (currency = 'BTC') {
        let response = await this.publicGetTickerAll ();
        let result = {};
        let timestamp = response['data']['date'];
        let tickers = this.omit (response['data'], 'date');
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            ticker['date'] = timestamp;
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let response = await this.publicGetTickerCurrency ({
            'currency': market['base'],
        });
        return this.parseTicker (response['data'], market);
    },

    parseTrade (trade, market) {
        // a workaround for their bug in date format, hours are not 0-padded
        let [ transaction_date, transaction_time ] = trade['transaction_date'].split (' ');
        let transaction_time_short = transaction_time.length < 8;
        if (transaction_time_short)
            transaction_time = '0' + transaction_time;
        let timestamp = this.parse8601 (transaction_date + ' ' + transaction_time);
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['units_traded']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetRecentTransactionsCurrency (this.extend ({
            'currency': market['base'],
            'count': 100, // max = 100
        }, params));
        return this.parseTrades (response['data'], market);
    },

    createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        throw new NotSupported (this.id + ' private API not implemented yet');
        // let prefix = '';
        // if (type == 'market')
        //     prefix = 'market_';
        // let order = {
        //     'pair': this.marketId (symbol),
        //     'quantity': amount,
        //     'price': price || 0,
        //     'type': prefix + side,
        // };
        // let response = await this.privatePostOrderCreate (this.extend (order, params));
        // return {
        //     'info': response,
        //     'id': response['order_id'].toString (),
        // };
    },

    cancelOrder (id, params = {}) {
        let side = ('side' in params);
        if (!side)
            throw new ExchangeError (this.id + ' cancelOrder requires a side parameter (sell or buy)');
        side = (side == 'buy') ? 'purchase' : 'sales';
        let currency = ('currency' in params);
        if (!currency)
            throw new ExchangeError (this.id + ' cancelOrder requires a currency parameter');
        return this.privatePostTradeCancel ({
            'order_id': id,
            'type': params['side'],
            'currency': params['currency'],
        });
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let endpoint = '/' + this.implodeParams (path, params);
        let url = this.urls['api'][api] + endpoint;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            body = this.urlencode (this.extend ({
                'endPoint': endpoint,
            }, query));
            let nonce = this.nonce ().toString ();
            let auth = endpoint + "\0" + body + "\0" + nonce;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Api-Key': this.apiKey,
                'Api-Sign': signature,
                'Api-Nonce': nonce,
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response) {
            if (response['status'] == '0000')
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var bitlish = {

    'id': 'bitlish',
    'name': 'bitlish',
    'countries': [ 'GB', 'EU', 'RU' ],
    'rateLimit': 1500,
    'version': 'v1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766275-dcfc6c30-5ed3-11e7-839d-00a846385d0b.jpg',
        'api': 'https://bitlish.com/api',
        'www': 'https://bitlish.com',
        'doc': 'https://bitlish.com/api',
    },
    'api': {
        'public': {
            'get': [
                'instruments',
                'ohlcv',
                'pairs',
                'tickers',
                'trades_depth',
                'trades_history',
            ],
            'post': [
                'instruments',
                'ohlcv',
                'pairs',
                'tickers',
                'trades_depth',
                'trades_history',
            ],
        },
        'private': {
            'post': [
                'accounts_operations',
                'balance',
                'cancel_trade',
                'cancel_trades_by_ids',
                'cancel_all_trades',
                'create_bcode',
                'create_template_wallet',
                'create_trade',
                'deposit',
                'list_accounts_operations_from_ts',
                'list_active_trades',
                'list_bcodes',
                'list_my_matches_from_ts',
                'list_my_trades',
                'list_my_trads_from_ts',
                'list_payment_methods',
                'list_payments',
                'redeem_code',
                'resign',
                'signin',
                'signout',
                'trade_details',
                'trade_options',
                'withdraw',
                'withdraw_by_id',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetPairs ();
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['id'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            // issue #4 bitlish names Dash as DSH, instead of DASH
            if (base == 'DSH')
                base = 'DASH';
            symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['max']),
            'low': parseFloat (ticker['min']),
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': parseFloat (ticker['first']),
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers ();
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickers ();
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let now = this.seconds ();
        let start = now - 86400 * 30; // last 30 days
        let interval = [ start.toString (), undefined ];
        return await this.publicPostOhlcv (this.extend ({
            'time_range': interval,
        }, params));
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetTradesDepth (this.extend ({
            'pair_id': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (parseInt (orderbook['last']) / 1000);
        return this.parseOrderBook (orderbook, timestamp, 'bid', 'ask', 'price', 'volume');
    },

    parseTrade (trade, market = undefined) {
        let side = (trade['dir'] == 'bid') ? 'buy' : 'sell';
        let symbol = undefined;
        let timestamp = parseInt (trade['created'] / 1000);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesHistory (this.extend ({
            'pair_id': market['id'],
        }, params));
        return this.parseTrades (response['list'], market);
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        let currencies = Object.keys (response);
        let balance = {};
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = response[currency];
            currency = currency.toUpperCase ();
            // issue #4 bitlish names Dash as DSH, instead of DASH
            if (currency == 'DSH')
                currency = 'DASH';
            balance[currency] = account;
        }
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balance) {
                account['free'] = parseFloat (balance[currency]['funds']);
                account['used'] = parseFloat (balance[currency]['holded']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return result;
    },

    signIn () {
        return this.privatePostSignin ({
            'login': this.login,
            'passwd': this.password,
        });
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair_id': this.marketId (symbol),
            'dir': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let result = await this.privatePostCreateTrade (this.extend (order, params));
        return {
            'info': result,
            'id': result['id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return await this.privatePostCancelTrade ({ 'id': id });
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC') {
            // they did not document other types...
            throw new NotSupported (this.id + ' currently supports BTC withdrawals only, until they document other currencies...');
        }
        let response = await this.privatePostWithdraw (this.extend ({
            'currency': currency.toLowerCase (),
            'amount': parseFloat (amount),
            'account': address,
            'payment_method': 'bitcoin', // they did not document other types...
        }, params));
        return {
            'info': response,
            'id': response['message_id'],
        };
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (method == 'GET') {
                if (Object.keys (params).length)
                    url += '?' + this.urlencode (params);
            }
            else {
                body = this.json (params);
                headers = { 'Content-Type': 'application/json' };
            }
        } else {
            body = this.json (this.extend ({ 'token': this.apiKey }, params));
            headers = { 'Content-Type': 'application/json' };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bitmarket = {

    'id': 'bitmarket',
    'name': 'BitMarket',
    'countries': [ 'PL', 'EU' ],
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchOHLCV': true,
    'hasWithdraw': true,
    'timeframes': {
        '90m': '90m',
        '6h': '6h',
        '1d': '1d',
        '1w': '7d',
        '1M': '1m',
        '3M': '3m',
        '6M': '6m',
        '1y': '1y',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27767256-a8555200-5ef9-11e7-96fd-469a65e2b0bd.jpg',
        'api': {
            'public': 'https://www.bitmarket.net',
            'private': 'https://www.bitmarket.pl/api2/', // last slash is critical
        },
        'www': [
            'https://www.bitmarket.pl',
            'https://www.bitmarket.net',
        ],
        'doc': [
            'https://www.bitmarket.net/docs.php?file=api_public.html',
            'https://www.bitmarket.net/docs.php?file=api_private.html',
            'https://github.com/bitmarket-net/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                'json/{market}/ticker',
                'json/{market}/orderbook',
                'json/{market}/trades',
                'json/ctransfer',
                'graphs/{market}/90m',
                'graphs/{market}/6h',
                'graphs/{market}/1d',
                'graphs/{market}/7d',
                'graphs/{market}/1m',
                'graphs/{market}/3m',
                'graphs/{market}/6m',
                'graphs/{market}/1y',
            ],
        },
        'private': {
            'post': [
                'info',
                'trade',
                'cancel',
                'orders',
                'trades',
                'history',
                'withdrawals',
                'tradingdesk',
                'tradingdeskStatus',
                'tradingdeskConfirm',
                'cryptotradingdesk',
                'cryptotradingdeskStatus',
                'cryptotradingdeskConfirm',
                'withdraw',
                'withdrawFiat',
                'withdrawPLNPP',
                'withdrawFiatFast',
                'deposit',
                'transfer',
                'transfers',
                'marginList',
                'marginOpen',
                'marginClose',
                'marginCancel',
                'marginModify',
                'marginBalanceAdd',
                'marginBalanceRemove',
                'swapList',
                'swapOpen',
                'swapClose',
            ],
        },
    },
    'markets': {
        'BTC/PLN': { 'id': 'BTCPLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
        'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'LTC/PLN': { 'id': 'LTCPLN', 'symbol': 'LTC/PLN', 'base': 'LTC', 'quote': 'PLN' },
        'LTC/BTC': { 'id': 'LTCBTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'LiteMineX/BTC': { 'id': 'LiteMineXBTC', 'symbol': 'LiteMineX/BTC', 'base': 'LiteMineX', 'quote': 'BTC' },
        'PlnX/BTC': { 'id': 'PlnxBTC', 'symbol': 'PlnX/BTC', 'base': 'PlnX', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostInfo ();
        let data = response['data'];
        let balance = data['balances'];
        let result = { 'info': data };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balance['available'])
                account['free'] = balance['available'][currency];
            if (currency in balance['blocked'])
                account['used'] = balance['blocked'][currency];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetJsonMarketOrderbook (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': orderbook['asks'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetJsonMarketTicker ({
            'market': this.marketId (symbol),
        });
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetJsonMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '90m', since = undefined, limit = undefined) {
        return [
            ohlcv['time'] * 1000,
            parseFloat (ohlcv['open']),
            parseFloat (ohlcv['high']),
            parseFloat (ohlcv['low']),
            parseFloat (ohlcv['close']),
            parseFloat (ohlcv['vol']),
        ];
    },

    async fetchOHLCV (symbol, timeframe = '90m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'publicGetGraphsMarket' + this.timeframes[timeframe];
        let market = this.market (symbol);
        let response = await this[method] (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'market': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        let result = {
            'info': response,
        };
        if ('id' in response['order'])
            result['id'] = response['id'];
        return result;
    },

    async cancelOrder (id) {
        return this.privatePostCancel ({ 'id': id });
    },

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let method = undefined;
        let request = {
            'currency': currency,
            'quantity': amount,
        };
        if (this.isFiat (currency)) {
            method = 'privatePostWithdrawFiat';
            if ('account' in params) {
                request['account'] = params['account']; // bank account code for withdrawal
            } else {
                throw new ExchangeError (this.id + ' requires account parameter to withdraw fiat currency');
            }
            if ('account2' in params) {
                request['account2'] = params['account2']; // bank SWIFT code (EUR only)
            } else {
                if (currency == 'EUR')
                    throw new ExchangeError (this.id + ' requires account2 parameter to withdraw EUR');
            }
            if ('withdrawal_note' in params) {
                request['withdrawal_note'] = params['withdrawal_note']; // a 10-character user-specified withdrawal note (PLN only)
            } else {
                if (currency == 'PLN')
                    throw new ExchangeError (this.id + ' requires withdrawal_note parameter to withdraw PLN');
            }
        } else {
            method = 'privatePostWithdraw';
            request['address'] = address;
        }
        let response = await this[method] (this.extend (request, params));
        return {
            'info': response,
            'id': response,
        };
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.implodeParams (path + '.json', params);
        } else {
            let nonce = this.nonce ();
            let query = this.extend ({
                'tonce': nonce,
                'method': path,
            }, params);
            body = this.urlencode (query);
            headers = {
                'API-Key': this.apiKey,
                'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bitmex = {

    'id': 'bitmex',
    'name': 'BitMEX',
    'countries': 'SC', // Seychelles
    'version': 'v1',
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1m',
        '5m': '5m',
        '1h': '1h',
        '1d': '1d',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
        'api': 'https://www.bitmex.com',
        'www': 'https://www.bitmex.com',
        'doc': [
            'https://www.bitmex.com/app/apiOverview',
            'https://github.com/BitMEX/api-connectors/tree/master/official-http',
        ],
    },
    'api': {
        'public': {
            'get': [
                'announcement',
                'announcement/urgent',
                'funding',
                'instrument',
                'instrument/active',
                'instrument/activeAndIndices',
                'instrument/activeIntervals',
                'instrument/compositeIndex',
                'instrument/indices',
                'insurance',
                'leaderboard',
                'liquidation',
                'orderBook',
                'orderBook/L2',
                'quote',
                'quote/bucketed',
                'schema',
                'schema/websocketHelp',
                'settlement',
                'stats',
                'stats/history',
                'trade',
                'trade/bucketed',
            ],
        },
        'private': {
            'get': [
                'apiKey',
                'chat',
                'chat/channels',
                'chat/connected',
                'execution',
                'execution/tradeHistory',
                'notification',
                'order',
                'position',
                'user',
                'user/affiliateStatus',
                'user/checkReferralCode',
                'user/commission',
                'user/depositAddress',
                'user/margin',
                'user/minWithdrawalFee',
                'user/wallet',
                'user/walletHistory',
                'user/walletSummary',
            ],
            'post': [
                'apiKey',
                'apiKey/disable',
                'apiKey/enable',
                'chat',
                'order',
                'order/bulk',
                'order/cancelAllAfter',
                'order/closePosition',
                'position/isolate',
                'position/leverage',
                'position/riskLimit',
                'position/transferMargin',
                'user/cancelWithdrawal',
                'user/confirmEmail',
                'user/confirmEnableTFA',
                'user/confirmWithdrawal',
                'user/disableTFA',
                'user/logout',
                'user/logoutAll',
                'user/preferences',
                'user/requestEnableTFA',
                'user/requestWithdrawal',
            ],
            'put': [
                'order',
                'order/bulk',
                'user',
            ],
            'delete': [
                'apiKey',
                'order',
                'order/all',
            ],
        }
    },

    async fetchMarkets () {
        let markets = await this.publicGetInstrumentActiveAndIndices ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['symbol'];
            let base = market['underlying'];
            let quote = market['quoteCurrency'];
            let isFuturesContract = id != (base + quote);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = isFuturesContract ? id : (base + '/' + quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetUserMargin ({ 'currency': 'all' });
        let result = { 'info': response };
        for (let b = 0; b < response.length; b++) {
            let balance = response[b];
            let currency = balance['currency'].toUpperCase ();
            currency = this.commonCurrencyCode (currency);
            let account = {
                'free': balance['availableMargin'],
                'used': 0.0,
                'total': balance['amount'],
            };
            if (currency == 'BTC') {
                account['free'] = account['free'] * 0.00000001;
                account['total'] = account['total'] * 0.00000001;
            }
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookL2 (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        let timestamp = this.milliseconds ();
        let result = {
            'bids': [],
            'asks': [],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        for (let o = 0; o < orderbook.length; o++) {
            let order = orderbook[o];
            let side = (order['side'] == 'Sell') ? 'asks' : 'bids';
            let amount = order['size'];
            let price = order['price'];
            result[side].push ([ price, amount ]);
        }
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let request = {
            'symbol': this.marketId (symbol),
            'binSize': '1d',
            'partial': true,
            'count': 1,
            'reverse': true,
        };
        let quotes = await this.publicGetQuoteBucketed (request);
        let quotesLength = quotes.length;
        let quote = quotes[quotesLength - 1];
        let tickers = await this.publicGetTradeBucketed (request);
        let ticker = tickers[0];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (quote['bidPrice']),
            'ask': parseFloat (quote['askPrice']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['homeNotional']),
            'quoteVolume': parseFloat (ticker['foreignNotional']),
            'info': ticker,
        };
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['timestamp']);
        return [
            timestamp,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['volume'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        // send JSON key/value pairs, such as {"key": "value"}
        // filter by individual fields and do advanced queries on timestamps
        let filter = { 'key': 'value' };
        // send a bare series (e.g. XBU) to nearest expiring contract in that series
        // you can also send a timeframe, e.g. XBU:monthly
        // timeframes: daily, weekly, monthly, quarterly, and biquarterly
        let market = this.market (symbol);
        let request = {
            'symbol': market['id'],
            'binSize': this.timeframes[timeframe],
            'partial': true,     // true == include yet-incomplete current bins
            // 'filter': filter, // filter by individual fields and do advanced queries
            // 'columns': [],    // will return all columns if omitted
            // 'start': 0,       // starting point for results (wtf?)
            // 'reverse': false, // true == newest first
            // 'endTime': '',    // ending date filter for results
        };
        if (since)
            request['startTime'] = since; // starting date filter for results
        if (limit)
            request['count'] = limit; // default 100
        let response = await this.publicGetTradeBucketed (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let symbol = undefined;
        if (!market) {
            if ('symbol' in trade)
                market = this.markets_by_id[trade['symbol']];
        }
        return {
            'id': trade['trdMatchID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'symbol': this.marketId (symbol),
            'side': this.capitalize (side),
            'orderQty': amount,
            'ordType': this.capitalize (type),
        };
        if (type == 'limit')
            order['rate'] = price;
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privateDeleteOrder ({ 'orderID': id });
    },

    isFiat (currency) {
        if (currency == 'EUR')
            return true;
        if (currency == 'PLN')
            return true;
        return false;
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency != 'BTC')
            throw new ExchangeError (this.id + ' supoprts BTC withdrawals only, other currencies coming soon...');
        let request = {
            'currency': 'XBt', // temporarily
            'amount': amount,
            'address': address,
            // 'otpToken': '123456', // requires if two-factor auth (OTP) is enabled
            // 'fee': 0.001, // bitcoin network fee
        };
        let response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
        return {
            'info': response,
            'id': response['transactID'],
        };
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/api' + '/' + this.version + '/' + path;
        if (Object.keys (params).length)
            query += '?' + this.urlencode (params);
        let url = this.urls['api'] + query;
        if (api == 'private') {
            let nonce = this.nonce ().toString ();
            if (method == 'POST')
                if (Object.keys (params).length)
                    body = this.json (params);
            let request = [ method, query, nonce, body || ''].join ('');
            headers = {
                'Content-Type': 'application/json',
                'api-nonce': nonce,
                'api-key': this.apiKey,
                'api-signature': this.hmac (this.encode (request), this.encode (this.secret)),
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bitso = {

    'id': 'bitso',
    'name': 'Bitso',
    'countries': 'MX', // Mexico
    'rateLimit': 2000, // 30 requests per minute
    'version': 'v3',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766335-715ce7aa-5ed5-11e7-88a8-173a27bb30fe.jpg',
        'api': 'https://api.bitso.com',
        'www': 'https://bitso.com',
        'doc': 'https://bitso.com/api_info',
    },
    'api': {
        'public': {
            'get': [
                'available_books',
                'ticker',
                'order_book',
                'trades',
            ],
        },
        'private': {
            'get': [
                'account_status',
                'balance',
                'fees',
                'fundings',
                'fundings/{fid}',
                'funding_destination',
                'kyc_documents',
                'ledger',
                'ledger/trades',
                'ledger/fees',
                'ledger/fundings',
                'ledger/withdrawals',
                'mx_bank_codes',
                'open_orders',
                'order_trades/{oid}',
                'orders/{oid}',
                'user_trades',
                'user_trades/{tid}',
                'withdrawals/',
                'withdrawals/{wid}',
            ],
            'post': [
                'bitcoin_withdrawal',
                'debit_card_withdrawal',
                'ether_withdrawal',
                'orders',
                'phone_number',
                'phone_verification',
                'phone_withdrawal',
                'spei_withdrawal',
            ],
            'delete': [
                'orders/{oid}',
                'orders/all',
            ],
        }
    },

    async fetchMarkets () {
        let markets = await this.publicGetAvailableBooks ();
        let result = [];
        for (let p = 0; p < markets['payload'].length; p++) {
            let market = markets['payload'][p];
            let id = market['book'];
            let symbol = id.toUpperCase ().replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['payload']['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'].toUpperCase ();
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['locked']),
                'total': parseFloat (balance['total']),
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let orderbook = response['payload'];
        let timestamp = this.parse8601 (orderbook['updated_at']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker ({
            'book': this.marketId (symbol),
        });
        let ticker = response['payload'];
        let timestamp = this.parse8601 (ticker['created_at']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['created_at']);
        let symbol = undefined;
        if (!market) {
            if ('book' in trade)
                market = this.markets_by_id[trade['book']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['maker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'book': this.marketId (market),
        }, params));
        return this.parseTrades (response['payload'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'book': this.marketId (symbol),
            'side': side,
            'type': type,
            'major': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['payload']['oid'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privateDeleteOrders ({ 'oid': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let query = '/' + this.version + '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + query;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            if (Object.keys (params).length)
                body = this.json (params);
            let nonce = this.nonce ().toString ();
            let request = [ nonce, method, query, body || '' ].join ('');
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let auth = this.apiKey + ':' + nonce + ':' + signature;
            headers = { 'Authorization': "Bitso " + auth };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var bitstamp1 = {

    'id': 'bitstamp1',
    'name': 'Bitstamp v1',
    'countries': 'GB',
    'rateLimit': 1000,
    'version': 'v1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
        'api': 'https://www.bitstamp.net/api',
        'www': 'https://www.bitstamp.net',
        'doc': 'https://www.bitstamp.net/api',
    },
    'api': {
        'public': {
            'get': [
                'ticker',
                'ticker_hour',
                'order_book',
                'transactions',
                'eur_usd',
            ],
        },
        'private': {
            'post': [
                'balance',
                'user_transactions',
                'open_orders',
                'order_status',
                'cancel_order',
                'cancel_all_orders',
                'buy',
                'sell',
                'bitcoin_deposit_address',
                'unconfirmed_btc',
                'ripple_withdrawal',
                'ripple_address',
                'withdrawal_requests',
                'bitcoin_withdrawal',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD' },
        'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD' },
        'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR' },
        'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
        'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
        'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
        'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
        'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR' },
        'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
    },

    async fetchOrderBook (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only');
        let orderbook = await this.publicGetOrderBook (params);
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    },

    async fetchTicker (symbol) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only');
        let ticker = await this.publicGetTicker ();
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']);
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']);
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        if (symbol != 'BTC/USD')
            throw new ExchangeError (this.id + ' ' + this.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only');
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market);
    },

    async fetchBalance (params = {}) {
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            account['free'] = this.safeFloat (balance, free, 0.0);
            account['used'] = this.safeFloat (balance, used, 0.0);
            account['total'] = this.safeFloat (balance, total, 0.0);
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type != 'limit')
            throw new ExchangeError (this.id + ' ' + this.version + ' accepts limit orders only');
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'id': this.marketId (symbol),
            'amount': amount,
            'price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancelOrder ({ 'id': id });
    },

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    },

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    },

    async fetchMyTrades (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'id': pair }, params);
        let response = await this.privatePostOpenOrdersId (request);
        let result = this.parseTrades (response, market);
    },

    async fetchOrder (id) {
        throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        await this.loadMarkets ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var bitstamp = {

    'id': 'bitstamp',
    'name': 'Bitstamp',
    'countries': 'GB',
    'rateLimit': 1000,
    'version': 'v2',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
        'api': 'https://www.bitstamp.net/api',
        'www': 'https://www.bitstamp.net',
        'doc': 'https://www.bitstamp.net/api',
    },
    'api': {
        'public': {
            'get': [
                'order_book/{pair}/',
                'ticker_hour/{pair}/',
                'ticker/{pair}/',
                'transactions/{pair}/',
            ],
        },
        'private': {
            'post': [
                'balance/',
                'balance/{pair}/',
                'user_transactions/',
                'user_transactions/{pair}/',
                'open_orders/all/',
                'open_orders/{pair}',
                'order_status/',
                'cancel_order/',
                'buy/{pair}/',
                'buy/market/{pair}/',
                'sell/{pair}/',
                'sell/market/{pair}/',
                'ltc_withdrawal',
                'ltc_address',
                'eth_withdrawal',
                'eth_address',
                'transfer-to-main/',
                'transfer-from-main/',
                'xrp_withdrawal/',
                'xrp_address/',
                'withdrawal/open/',
                'withdrawal/status/',
                'withdrawal/cancel/',
                'liquidation_address/new/',
                'liquidation_address/info/',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD' },
        'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD' },
        'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR' },
        'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
        'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD' },
        'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
        'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
        'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR' },
        'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTickerPair ({
            'pair': this.marketId (symbol),
        });
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = undefined;
        if ('date' in trade) {
            timestamp = parseInt (trade['date']);
        } else if ('datetime' in trade) {
            // timestamp = this.parse8601 (trade['datetime']);
            timestamp = parseInt (trade['datetime']);
        }
        let side = (trade['type'] == 0) ? 'buy' : 'sell';
        let order = undefined;
        if ('order_id' in trade)
            order = trade['order_id'].toString ();
        if ('currency_pair' in trade) {
            if (trade['currency_pair'] in this.markets_by_id)
                market = this.markets_by_id[trade['currency_pair']];
        }
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': order,
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsPair (this.extend ({
            'pair': market['id'],
            'time': 'minute',
        }, params));
        return this.parseTrades (response, market);
    },

    async fetchBalance (params = {}) {
        let balance = await this.privatePostBalance ();
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let total = lowercase + '_balance';
            let free = lowercase + '_available';
            let used = lowercase + '_reserved';
            let account = this.account ();
            if (free in balance)
                account['free'] = parseFloat (balance[free]);
            if (used in balance)
                account['used'] = parseFloat (balance[used]);
            if (total in balance)
                account['total'] = parseFloat (balance[total]);
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'pair': this.marketId (symbol),
            'amount': amount,
        };
        if (type == 'market')
            method += 'Market';
        else
            order['price'] = price;
        method += 'Pair';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancelOrder ({ 'id': id });
    },

    parseOrderStatus (order) {
        if ((order['status'] == 'Queue') || (order['status'] == 'Open'))
            return 'open';
        if (order['status'] == 'Finished')
            return 'closed';
        return order['status'];
    },

    async fetchOrderStatus (id, symbol = undefined) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderStatus ({ 'id': id });
        return this.parseOrderStatus (response);
    },

    async fetchMyTrades (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({ 'pair': pair }, params);
        let response = await this.privatePostOpenOrdersPair (request);
        let result = this.parseTrades (response, market);
    },

    async fetchOrder (id) {
        throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        await this.loadMarkets ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
            query = this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var bittrex = {

    'id': 'bittrex',
    'name': 'Bittrex',
    'countries': 'US',
    'version': 'v1.1',
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'hasFetchOrders': true,
    'hasFetchOpenOrders': true,
    'timeframes': {
        '1m': 'oneMin',
        '5m': 'fiveMin',
        '30m': 'thirtyMin',
        '1h': 'hour',
        '1d': 'day',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766352-cf0b3c26-5ed5-11e7-82b7-f3826b7a97d8.jpg',
        'api': {
            'public': 'https://bittrex.com/api',
            'account': 'https://bittrex.com/api',
            'market': 'https://bittrex.com/api',
            'v2': 'https://bittrex.com/api/v2.0/pub',
        },
        'www': 'https://bittrex.com',
        'doc': [
            'https://bittrex.com/Home/Api',
            'https://www.npmjs.org/package/node.bittrex.api',
        ],
        'fees': [
            'https://bittrex.com/Fees',
            'https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-',
        ],
    },
    'api': {
        'v2': {
            'get': [
                'currencies/GetBTCPrice',
                'market/GetTicks',
                'market/GetLatestTick',
                'Markets/GetMarketSummaries',
                'market/GetLatestTick',
            ],
        },
        'public': {
            'get': [
                'currencies',
                'markethistory',
                'markets',
                'marketsummaries',
                'marketsummary',
                'orderbook',
                'ticker',
            ],
        },
        'account': {
            'get': [
                'balance',
                'balances',
                'depositaddress',
                'deposithistory',
                'order',
                'orderhistory',
                'withdrawalhistory',
                'withdraw',
            ],
        },
        'market': {
            'get': [
                'buylimit',
                'buymarket',
                'cancel',
                'openorders',
                'selllimit',
                'sellmarket',
            ],
        },
    },
    'fees': {
        'trading': {
            'maker': 0.0025,
            'taker': 0.0025,
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets['result'].length; p++) {
            let market = markets['result'][p];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            }));
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.accountGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        let indexed = this.indexBy (balances, 'Currency');
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in indexed) {
                let balance = indexed[currency];
                account['free'] = balance['Available'];
                account['used'] = balance['Balance'] - balance['Available'];
                account['total'] = balance['Balance'];
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (market),
            'type': 'both',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    },

    parseTicker (ticker, market) {
        let timestamp = this.parse8601 (ticker['TimeStamp']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['Bid']),
            'ask': parseFloat (ticker['Ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['Last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['BaseVolume']),
            'quoteVolume': parseFloat (ticker['Volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetMarketsummaries ();
        let tickers = response['result'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['MarketName'];
            let market = undefined;
            let symbol = id;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let [ quote, base ] = id.split ('-');
                base = this.commonCurrencyCode (base);
                quote = this.commonCurrencyCode (quote);
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketsummary ({
            'market': market['id'],
        });
        let ticker = response['result'][0];
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        let side = undefined;
        if (trade['OrderType'] == 'BUY') {
            side = 'buy';
        } else if (trade['OrderType'] == 'SELL') {
            side = 'sell';
        }
        let type = undefined;
        let id = undefined;
        if ('Id' in trade)
            id = trade['Id'].toString ();
        return {
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['Price'],
            'amount': trade['Quantity'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response['result'], market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['T']);
        return [
            timestamp,
            ohlcv['O'],
            ohlcv['H'],
            ohlcv['L'],
            ohlcv['C'],
            ohlcv['V'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'tickInterval': this.timeframes[timeframe],
            'marketName': market['id'],
        };
        let response = await this.v2GetMarketGetTicks (this.extend (request, params));
        return this.parseOHLCVs (response['result'], market, timeframe, since, limit);
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let request = {};
        let market = undefined;
        if (symbol) {
            market = this.market (symbol);
            request['market'] = market['id'];
        }
        let response = await this.marketGetOpenorders (this.extend (request, params));
        return this.parseOrders (response['result'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'marketGet' + this.capitalize (side) + type;
        let order = {
            'market': this.marketId (symbol),
            'quantity': amount,
        };
        if (type == 'limit')
            order['rate'] = price;
        let response = await this[method] (this.extend (order, params));
        let result = {
            'info': response,
            'id': response['result']['uuid'],
        };
        return result;
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return await this.marketGetCancel ({ 'uuid': id });
    },

    parseOrder (order, market = undefined) {
        let side = undefined;
        if ('OrderType' in order)
            side = (order['OrderType'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        if ('Type' in order)
            side = (order['Type'] == 'LIMIT_BUY') ? 'buy' : 'sell';
        let status = 'open';
        if (order['Closed']) {
            status = 'closed';
        } else if (order['CancelInitiated']) {
            status = 'canceled';
        }
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else {
            let exchange = order['Exchange'];
            if (exchange in this.markets_by_id) {
                market = this.markets_by_id[exchange];
                symbol = market['symbol'];
            }
        }
        let timestamp = undefined;
        if ('Opened' in order)
            timestamp = this.parse8601 (order['Opened']);
        if ('TimeStamp' in order)
            timestamp = this.parse8601 (order['TimeStamp']);
        let amount = order['Quantity'];
        let remaining = order['QuantityRemaining'];
        let filled = amount - remaining;
        let result = {
            'info': order,
            'id': order['OrderUuid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'type': 'limit',
            'side': side,
            'price': order['Price'],
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
        };
        return result;
    },

    async fetchOrder (id) {
        await this.loadMarkets ();
        let response = await this.accountGetOrder ({ 'uuid': id });
        return this.parseOrder (response['result']);
    },

    async fetchOrders (params = {}) {
        await this.loadMarkets ();
        let response = await this.accountGetOrderhistory (params);
        return this.parseOrders (response['result']);
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.accountGetWithdraw (this.extend ({
            'currency': currency,
            'quantity': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api != 'v2')
            url += this.version + '/';
        if (api == 'public') {
            url += api + '/' + method.toLowerCase () + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else if (api == 'v2') {
            url += path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            url += api + '/';
            if (((api == 'account') && (path != 'withdraw')) || (path == 'openorders'))
                url += method.toLowerCase ();
            url += path + '?' + this.urlencode (this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, params));
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512');
            headers = { 'apisign': signature };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        if ('message' in response)
            if (response['message'] == "INSUFFICIENT_FUNDS")
                throw new InsufficientFunds (this.id + ' ' + this.json (response));
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var blinktrade = {

    'id': 'blinktrade',
    'name': 'BlinkTrade',
    'countries': [ 'US', 'VE', 'VN', 'BR', 'PK', 'CL' ],
    'rateLimit': 1000,
    'version': 'v1',
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27990968-75d9c884-6470-11e7-9073-46756c8e7e8c.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://blinktrade.com',
        'doc': 'https://blinktrade.com/docs',
    },
    'api': {
        'public': {
            'get': [
                '{currency}/ticker',    // ?crypto_currency=BTC
                '{currency}/orderbook', // ?crypto_currency=BTC
                '{currency}/trades',    // ?crypto_currency=BTC&since=<TIMESTAMP>&limit=<NUMBER>
            ],
        },
        'private': {
            'post': [
                'D',   // order
                'F',   // cancel order
                'U2',  // balance
                'U4',  // my orders
                'U6',  // withdraw
                'U18', // deposit
                'U24', // confirm withdrawal
                'U26', // list withdrawals
                'U30', // list deposits
                'U34', // ledger
                'U70', // cancel withdrawal
            ],
        },
    },
    'markets': {
        'BTC/VEF': { 'id': 'BTCVEF', 'symbol': 'BTC/VEF', 'base': 'BTC', 'quote': 'VEF', 'brokerId': 1, 'broker': 'SurBitcoin' },
        'BTC/VND': { 'id': 'BTCVND', 'symbol': 'BTC/VND', 'base': 'BTC', 'quote': 'VND', 'brokerId': 3, 'broker': 'VBTC' },
        'BTC/BRL': { 'id': 'BTCBRL', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'brokerId': 4, 'broker': 'FoxBit' },
        'BTC/PKR': { 'id': 'BTCPKR', 'symbol': 'BTC/PKR', 'base': 'BTC', 'quote': 'PKR', 'brokerId': 8, 'broker': 'UrduBit' },
        'BTC/CLP': { 'id': 'BTCCLP', 'symbol': 'BTC/CLP', 'base': 'BTC', 'quote': 'CLP', 'brokerId': 9, 'broker': 'ChileBit' },
    },

    async fetchBalance (params = {}) {
        return this.privatePostU2 ({
            'BalanceReqID': this.nonce (),
        });
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetCurrencyOrderbook (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let ticker = await this.publicGetCurrencyTicker ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        });
        let timestamp = this.milliseconds ();
        let lowercaseQuote = market['quote'].toLowerCase ();
        let quoteVolume = 'vol_' + lowercaseQuote;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker[quoteVolume]),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetCurrencyTrades (this.extend ({
            'currency': market['quote'],
            'crypto_currency': market['base'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let order = {
            'ClOrdID': this.nonce (),
            'Symbol': market['id'],
            'Side': this.capitalize (side),
            'OrdType': '2',
            'Price': price,
            'OrderQty': amount,
            'BrokerID': market['brokerId'],
        };
        let response = await this.privatePostD (this.extend (order, params));
        let indexed = this.indexBy (response['Responses'], 'MsgType');
        let execution = indexed['8'];
        return {
            'info': response,
            'id': execution['OrderID'],
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostF (this.extend ({
            'ClOrdID': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            let request = this.extend ({ 'MsgType': path }, query);
            body = this.json (request);
            headers = {
                'APIKey': this.apiKey,
                'Nonce': nonce,
                'Signature': this.hmac (this.encode (nonce), this.encode (this.secret)),
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('Status' in response)
            if (response['Status'] != 200)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var bl3p = {

    'id': 'bl3p',
    'name': 'BL3P',
    'countries': [ 'NL', 'EU' ], // Netherlands, EU
    'rateLimit': 1000,
    'version': '1',
    'comment': 'An exchange market by BitonicNL',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
        'api': 'https://api.bl3p.eu',
        'www': [
            'https://bl3p.eu',
            'https://bitonic.nl',
        ],
        'doc': [
            'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
            'https://bl3p.eu/api',
            'https://bitonic.nl/en/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{market}/ticker',
                '{market}/orderbook',
                '{market}/trades',
            ],
        },
        'private': {
            'post': [
                '{market}/money/depth/full',
                '{market}/money/order/add',
                '{market}/money/order/cancel',
                '{market}/money/order/result',
                '{market}/money/orders',
                '{market}/money/orders/history',
                '{market}/money/trades/fetch',
                'GENMKT/money/info',
                'GENMKT/money/deposit_address',
                'GENMKT/money/new_deposit_address',
                'GENMKT/money/wallet/history',
                'GENMKT/money/withdraw',
            ],
        },
    },
    'markets': {
        'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostGENMKTMoneyInfo ();
        let data = response['data'];
        let balance = data['wallets'];
        let result = { 'info': data };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balance) {
                if ('available' in balance[currency]) {
                    account['free'] = parseFloat (balance[currency]['available']['value']);
                }
            }
            if (currency in balance) {
                if ('balance' in balance[currency]) {
                    account['total'] = parseFloat (balance[currency]['balance']['value']);
                }
            }
            if (account['total']) {
                if (account['free']) {
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[currency] = account;
        }
        return result;
    },

    parseBidAsk (bidask, priceKey = 0, amountKey = 0) {
        return [
            bidask['price_int'] / 100000.0,
            bidask['amount_int'] / 100000000.0,
        ];
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderbook (this.extend ({
            'market': market['id'],
        }, params));
        let orderbook = response['data'];
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetMarketTicker ({
            'market': this.marketId (symbol),
        });
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']['24h']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        return {
            'id': trade['trade_id'],
            'info': trade,
            'timestamp': trade['date'],
            'datetime': this.iso8601 (trade['date']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price_int'] / 100000.0,
            'amount': trade['amount_int'] / 100000000.0,
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketTrades (this.extend ({
            'market': market['id'],
        }, params));
        let result = this.parseTrades (response['data']['trades'], market);
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let order = {
            'market': market['id'],
            'amount_int': amount,
            'fee_currency': market['quote'],
            'type': (side == 'buy') ? 'bid' : 'ask',
        };
        if (type == 'limit')
            order['price_int'] = price;
        let response = await this.privatePostMarketMoneyOrderAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    },

    async cancelOrder (id) {
        return this.privatePostMarketMoneyOrderCancel ({ 'order_id': id });
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = this.implodeParams (path, params);
        let url = this.urls['api'] + '/' + this.version + '/' + request;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let secret = this.base64ToBinary (this.secret);
            let auth = request + "\0" + body;
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Rest-Key': this.apiKey,
                'Rest-Sign': signature,
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var bleutrade = extend (bittrex, {

    'id': 'bleutrade',
    'name': 'Bleutrade',
    'countries': 'BR', // Brazil
    'rateLimit': 1000,
    'version': 'v2',
    'hasCORS': true,
    'hasFetchTickers': true,
    'hasFetchOHLCV': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30303000-b602dbe6-976d-11e7-956d-36c5049c01e7.jpg',
        'api': {
            'public': 'https://bleutrade.com/api',
            'account': 'https://bleutrade.com/api',
            'market': 'https://bleutrade.com/api',
        },
        'www': 'https://bleutrade.com',
        'doc': 'https://bleutrade.com/help/API',
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (market),
            'type': 'ALL',
            'depth': 50,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    },
})

//-----------------------------------------------------------------------------

var btcchina = {

    'id': 'btcchina',
    'name': 'BTCChina',
    'countries': 'CN',
    'rateLimit': 1500,
    'version': 'v1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766368-465b3286-5ed6-11e7-9a11-0f6467e1d82b.jpg',
        'api': {
            'plus': 'https://plus-api.btcchina.com/market',
            'public': 'https://data.btcchina.com/data',
            'private': 'https://api.btcchina.com/api_trade_v1.php',
        },
        'www': 'https://www.btcchina.com',
        'doc': 'https://www.btcchina.com/apidocs'
    },
    'api': {
        'plus': {
            'get': [
                'orderbook',
                'ticker',
                'trade',
            ],
        },
        'public': {
            'get': [
                'historydata',
                'orderbook',
                'ticker',
                'trades',
            ],
        },
        'private': {
            'post': [
                'BuyIcebergOrder',
                'BuyOrder',
                'BuyOrder2',
                'BuyStopOrder',
                'CancelIcebergOrder',
                'CancelOrder',
                'CancelStopOrder',
                'GetAccountInfo',
                'getArchivedOrder',
                'getArchivedOrders',
                'GetDeposits',
                'GetIcebergOrder',
                'GetIcebergOrders',
                'GetMarketDepth',
                'GetMarketDepth2',
                'GetOrder',
                'GetOrders',
                'GetStopOrder',
                'GetStopOrders',
                'GetTransactions',
                'GetWithdrawal',
                'GetWithdrawals',
                'RequestWithdrawal',
                'SellIcebergOrder',
                'SellOrder',
                'SellOrder2',
                'SellStopOrder',
            ],
        },
    },
    'markets': {
        'BTC/CNY': { 'id': 'btccny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
        'LTC/CNY': { 'id': 'ltccny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'api': 'public', 'plus': false },
        'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'api': 'public', 'plus': false },
        'BCH/CNY': { 'id': 'bcccny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
        'ETH/CNY': { 'id': 'ethcny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'api': 'plus', 'plus': true },
    },

    async fetchMarkets () {
        let markets = await this.publicGetTicker ({
            'market': 'all',
        });
        let result = [];
        let keys = Object.keys (markets);
        for (let p = 0; p < keys.length; p++) {
            let key = keys[p];
            let market = markets[key];
            let parts = key.split ('_');
            let id = parts[1];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };

        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances['balance'])
                account['total'] = parseFloat (balances['balance'][lowercase]['amount']);
            if (lowercase in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][lowercase]['amount']);
            account['free'] = account['total'] - account['used'];
            result[currency] = account;
        }
        return result;
    },

    createMarketRequest (market) {
        let request = {};
        let field = (market['plus']) ? 'symbol' : 'market';
        request[field] = market['id'];
        return request;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetOrderbook';
        let request = this.createMarketRequest (market);
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = orderbook['date'] * 1000;
        let result = this.parseOrderBook (orderbook, timestamp);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['date'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['prev_close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    },

    parseTickerPlus (ticker, market) {
        let timestamp = ticker['Timestamp'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['PrevCls']),
            'first': undefined,
            'last': parseFloat (ticker['Last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['Volume24H']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTicker';
        let request = this.createMarketRequest (market);
        let tickers = await this[method] (request);
        let ticker = tickers['ticker'];
        if (market['plus'])
            return this.parseTickerPlus (ticker, market);
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    parseTradePlus (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['size'],
        };
    },

    parseTradesPlus (trades, market = undefined) {
        let result = [];
        for (let i = 0; i < trades.length; i++) {
            result.push (this.parseTradePlus (trades[i], market));
        }
        return result;
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = market['api'] + 'GetTrade';
        let request = this.createMarketRequest (market);
        if (market['plus']) {
            let now = this.milliseconds ();
            request['start_time'] = now - 86400 * 1000;
            request['end_time'] = now;
        } else {
            method += 's'; // trades vs trade
        }
        let response = await this[method] (this.extend (request, params));
        if (market['plus']) {
            return this.parseTradesPlus (response['trades'], market);
        }
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Order2';
        let order = {};
        let id = market['id'].toUpperCase ();
        if (type == 'market') {
            order['params'] = [ undefined, amount, id ];
        } else {
            order['params'] = [ price, amount, id ];
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        let market = params['market']; // TODO fixme
        return this.privatePostCancelOrder (this.extend ({
            'params': [ id, market ],
        }, params));
    },

    nonce () {
        return this.microseconds ();
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            if (!this.apiKey)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.apiKey` property for authentication');
            if (!this.secret)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.secret` property for authentication');
            let p = [];
            if ('params' in params)
                p = params['params'];
            let nonce = this.nonce ();
            let request = {
                'method': path,
                'id': nonce,
                'params': p,
            };
            p = p.join (',');
            body = this.json (request);
            let query = (
                'tonce=' + nonce +
                '&accesskey=' + this.apiKey +
                '&requestmethod=' + method.toLowerCase () +
                '&id=' + nonce +
                '&method=' + path +
                '&params=' + p
            );
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha1');
            let auth = this.apiKey + ':' + signature;
            headers = {
                'Authorization': 'Basic ' + this.stringToBase64 (auth),
                'Json-Rpc-Tonce': nonce,
            };
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var btcmarkets = {

    'id': 'btcmarkets',
    'name': 'BTC Markets',
    'countries': 'AU', // Australia
    'rateLimit': 1000, // market data cached for 1 second (trades cached for 2 seconds)
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/29142911-0e1acfc2-7d5c-11e7-98c4-07d9532b29d7.jpg',
        'api': 'https://api.btcmarkets.net',
        'www': 'https://btcmarkets.net/',
        'doc': 'https://github.com/BTCMarkets/API',
    },
    'api': {
        'public': {
            'get': [
                'market/{id}/tick',
                'market/{id}/orderbook',
                'market/{id}/trades',
            ],
        },
        'private': {
            'get': [
                'account/balance',
                'account/{id}/tradingfee',
            ],
            'post': [
                'fundtransfer/withdrawCrypto',
                'fundtransfer/withdrawEFT',
                'order/create',
                'order/cancel',
                'order/history',
                'order/open',
                'order/trade/history',
                'order/createBatch', // they promise it's coming soon...
                'order/detail',
            ],
        },
    },
    'markets': {
        'BTC/AUD': { 'id': 'BTC/AUD', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
        'LTC/AUD': { 'id': 'LTC/AUD', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD' },
        'ETH/AUD': { 'id': 'ETH/AUD', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD' },
        'ETC/AUD': { 'id': 'ETC/AUD', 'symbol': 'ETC/AUD', 'base': 'ETC', 'quote': 'AUD' },
        'XRP/AUD': { 'id': 'XRP/AUD', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD' },
        'BCH/AUD': { 'id': 'BCH/AUD', 'symbol': 'BCH/AUD', 'base': 'BCH', 'quote': 'AUD' },
        'LTC/BTC': { 'id': 'LTC/BTC', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'ETH/BTC': { 'id': 'ETH/BTC', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
        'ETC/BTC': { 'id': 'ETC/BTC', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
        'XRP/BTC': { 'id': 'XRP/BTC', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC' },
        'BCH/BTC': { 'id': 'BCH/BTC', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let multiplier = 100000000;
            let free = parseFloat (balance['balance'] / multiplier);
            let used = parseFloat (balance['pendingFunds'] / multiplier);
            let account = {
                'free': free,
                'used': used,
                'total': this.sum (free, used),
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetMarketIdOrderbook (this.extend ({
            'id': market['id'],
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bestBid']),
            'ask': parseFloat (ticker['bestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume24h']),
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetMarketIdTick ({
            'id': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketIdTrades (this.extend ({
            // 'since': 59868345231,
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let multiplier = 100000000; // for price and volume
        // does BTC Markets support market orders at all?
        let orderSide = (side == 'buy') ? 'Bid' : 'Ask';
        let order = this.ordered ({
            'currency': market['quote'],
            'instrument': market['base'],
            'price': price * multiplier,
            'volume': amount * multiplier,
            'orderSide': orderSide,
            'ordertype': this.capitalize (type),
            'clientRequestId': this.nonce ().toString (),
        });
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrders (ids) {
        await this.loadMarkets ();
        return this.privatePostOrderCancel ({ 'order_ids': ids });
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.cancelOrders ([ id ]);
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let uri = '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + uri;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ().toString ();
            let auth = uri + "\n" + nonce + "\n";
            headers = {
                'Content-Type': 'application/json',
                'apikey': this.apiKey,
                'timestamp': nonce,
            };
            if (method == 'POST') {
                body = this.urlencode (query);
                auth += body;
            }
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            headers['signature'] = this.decode (signature);
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'private') {
            if ('success' in response)
                if (!response['success'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
            return response;
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var btctrader = {

    'id': 'btctrader',
    'name': 'BTCTrader',
    'countries': [ 'TR', 'GR', 'PH' ], // Turkey, Greece, Philippines
    'rateLimit': 1000,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1d': '1d',
    },
    'comment': 'base API for BTCExchange, BTCTurk',
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27992404-cda1e386-649c-11e7-8dc1-40bbd2897768.jpg',
        'api': 'https://www.btctrader.com/api',
        'www': 'https://www.btctrader.com',
        'doc': 'https://github.com/BTCTrader/broker-api-docs',
    },
    'api': {
        'public': {
            'get': [
                'ohlcdata', // ?last=COUNT
                'orderbook',
                'ticker',
                'trades',   // ?last=COUNT (max 50)
            ],
        },
        'private': {
            'get': [
                'balance',
                'openOrders',
                'userTransactions', // ?offset=0&limit=25&sort=asc
            ],
            'post': [
                'buy',
                'cancelOrder',
                'sell',
            ],
        },
    },

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalance ();
        let result = { 'info': response };
        let base = {
            'free': response['bitcoin_available'],
            'used': response['bitcoin_reserved'],
            'total': response['bitcoin_balance'],
        };
        let quote = {
            'free': response['money_available'],
            'used': response['money_reserved'],
            'total': response['money_balance'],
        };
        let symbol = this.symbols[0];
        let market = this.markets[symbol];
        result[market['base']] = base;
        result[market['quote']] = quote;
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderbook (params);
        let timestamp = parseInt (orderbook['timestamp'] * 1000);
        return this.parseOrderBook (orderbook, timestamp);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTicker ();
        let timestamp = parseInt (ticker['timestamp'] * 1000);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['average']),
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let maxCount = 50;
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1d', since = undefined, limit = undefined) {
        let timestamp = this.parse8601 (ohlcv['Date']);
        return [
            timestamp,
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {};
        if (limit)
            request['last'] = limit;
        let response = await this.publicGetOhlcdata (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'Type': (side == 'buy') ? 'BuyBtc' : 'SelBtc',
            'IsMarketOrder': (type == 'market') ? 1 : 0,
        };
        if (type == 'market') {
            if (side == 'buy')
                order['Total'] = amount;
            else
                order['Amount'] = amount;
        } else {
            order['Price'] = price;
            order['Amount'] = amount;
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancelOrder ({ 'id': id });
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (this.id == 'btctrader')
            throw new ExchangeError (this.id + ' is an abstract base API for BTCExchange, BTCTurk');
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ().toString;
            body = this.urlencode (params);
            let secret = this.base64ToString (this.secret);
            let auth = this.apiKey + nonce;
            headers = {
                'X-PCK': this.apiKey,
                'X-Stamp': nonce.toString (),
                'X-Signature': this.hmac (this.encode (auth), secret, 'sha256', 'base64'),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var btcexchange = extend (btctrader, {

    'id': 'btcexchange',
    'name': 'BTCExchange',
    'countries': 'PH', // Philippines
    'rateLimit': 1500,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27993052-4c92911a-64aa-11e7-96d8-ec6ac3435757.jpg',
        'api': 'https://www.btcexchange.ph/api',
        'www': 'https://www.btcexchange.ph',
        'doc': 'https://github.com/BTCTrader/broker-api-docs',
    },
    'markets': {
        'BTC/PHP': { 'id': 'BTC/PHP', 'symbol': 'BTC/PHP', 'base': 'BTC', 'quote': 'PHP' },
    },
})

//-----------------------------------------------------------------------------

var btctradeua = {

    'id': 'btctradeua',
    'name': 'BTC Trade UA',
    'countries': 'UA', // Ukraine,
    'rateLimit': 3000,
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
        'api': 'https://btc-trade.com.ua/api',
        'www': 'https://btc-trade.com.ua',
        'doc': 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit',
    },
    'api': {
        'public': {
            'get': [
                'deals/{symbol}',
                'trades/sell/{symbol}',
                'trades/buy/{symbol}',
                'japan_stat/high/{symbol}',
            ],
        },
        'private': {
            'post': [
                'auth',
                'ask/{symbol}',
                'balance',
                'bid/{symbol}',
                'buy/{symbol}',
                'my_orders/{symbol}',
                'order/status/{id}',
                'remove/order/{id}',
                'sell/{symbol}',
            ],
        },
    },
    'markets': {
        'BTC/UAH': { 'id': 'btc_uah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH' },
        'ETH/UAH': { 'id': 'eth_uah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH' },
        'LTC/UAH': { 'id': 'ltc_uah', 'symbol': 'LTC/UAH', 'base': 'LTC', 'quote': 'UAH' },
        'DOGE/UAH': { 'id': 'doge_uah', 'symbol': 'DOGE/UAH', 'base': 'DOGE', 'quote': 'UAH' },
        'DASH/UAH': { 'id': 'dash_uah', 'symbol': 'DASH/UAH', 'base': 'DASH', 'quote': 'UAH' },
        'SIB/UAH': { 'id': 'sib_uah', 'symbol': 'SIB/UAH', 'base': 'SIB', 'quote': 'UAH' },
        'KRB/UAH': { 'id': 'krb_uah', 'symbol': 'KRB/UAH', 'base': 'KRB', 'quote': 'UAH' },
        'NVC/UAH': { 'id': 'nvc_uah', 'symbol': 'NVC/UAH', 'base': 'NVC', 'quote': 'UAH' },
        'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'NVC/BTC': { 'id': 'nvc_btc', 'symbol': 'NVC/BTC', 'base': 'NVC', 'quote': 'BTC' },
        'ITI/UAH': { 'id': 'iti_uah', 'symbol': 'ITI/UAH', 'base': 'ITI', 'quote': 'UAH' },
        'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
        'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
    },

    signIn () {
        return this.privatePostAuth ();
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalance ();
        let result = { 'info': response };
        if ('accounts' in result) {
            let accounts = response['accounts'];
            for (let b = 0; b < accounts.length; b++) {
                let account = accounts[b];
                let currency = account['currency'];
                let balance = parseFloat (account['balance']);
                result[currency] = {
                    'free': balance,
                    'used': 0.0,
                    'total': balance,
                };
            }
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let bids = await this.publicGetTradesBuySymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let asks = await this.publicGetTradesSellSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        let orderbook = {
            'bids': [],
            'asks': [],
        };
        if (bids) {
            if ('list' in bids)
                orderbook['bids'] = bids['list'];
        }
        if (asks) {
            if ('list' in asks)
                orderbook['asks'] = asks['list'];
        }
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'currency_trade');
    },

    async fetchTicker (symbol) {
        let response = await this.publicGetJapanStatHighSymbol ({
            'symbol': this.marketId (symbol),
        });
        let ticker = response['trades'];
        let timestamp = this.milliseconds ();
        let result = {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
        let tickerLength = ticker.length;
        if (tickerLength > 0) {
            let start = Math.max (tickerLength - 48, 0);
            for (let t = start; t < ticker.length; t++) {
                let candle = ticker[t];
                if (typeof result['open'] == 'undefined')
                    result['open'] = candle[1];
                if ((typeof result['high'] == 'undefined') || (result['high'] < candle[2]))
                    result['high'] = candle[2];
                if ((typeof result['low'] == 'undefined') || (result['low'] > candle[3]))
                    result['low'] = candle[3];
                if (typeof result['quoteVolume'] == 'undefined')
                    result['quoteVolume'] = -candle[5];
                else
                    result['quoteVolume'] -= candle[5];
            }
            let last = tickerLength - 1;
            result['close'] = ticker[last][4];
            result['quoteVolume'] = -1 * result['quoteVolume'];
        }
        return result;
    },

    parseTrade (trade, market) {
        let timestamp = this.milliseconds (); // until we have a better solution for python
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amnt_base']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDealsSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'Id';
        let order = {
            'count': amount,
            'currency1': market['quote'],
            'currency': market['base'],
            'price': price,
        };
        return this[method] (this.extend (order, params));
    },

    async cancelOrder (id) {
        return this.privatePostRemoveOrderId ({ 'id': id });
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += this.implodeParams (path, query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'out_order_id': nonce,
                'nonce': nonce,
            }, query));
            let auth = body + this.secret;
            headers = {
                'public-key': this.apiKey,
                'api-sign': this.hash (this.encode (auth), 'sha256'),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var btcturk = extend (btctrader, {

    'id': 'btcturk',
    'name': 'BTCTurk',
    'countries': 'TR', // Turkey
    'rateLimit': 1000,
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27992709-18e15646-64a3-11e7-9fa2-b0950ec7712f.jpg',
        'api': 'https://www.btcturk.com/api',
        'www': 'https://www.btcturk.com',
        'doc': 'https://github.com/BTCTrader/broker-api-docs',
    },
    'markets': {
        'BTC/TRY': { 'id': 'BTC/TRY', 'symbol': 'BTC/TRY', 'base': 'BTC', 'quote': 'TRY' },
    },
})

//-----------------------------------------------------------------------------

var btcx = {

    'id': 'btcx',
    'name': 'BTCX',
    'countries': [ 'IS', 'US', 'EU' ],
    'rateLimit': 1500, // support in english is very poor, unable to tell rate limits
    'version': 'v1',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766385-9fdcc98c-5ed6-11e7-8f14-66d5e5cd47e6.jpg',
        'api': 'https://btc-x.is/api',
        'www': 'https://btc-x.is',
        'doc': 'https://btc-x.is/custom/api-document.html',
    },
    'api': {
        'public': {
            'get': [
                'depth/{id}/{limit}',
                'ticker/{id}',
                'trade/{id}/{limit}',
            ],
        },
        'private': {
            'post': [
                'balance',
                'cancel',
                'history',
                'order',
                'redeem',
                'trade',
                'withdraw',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'btc/usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/EUR': { 'id': 'btc/eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
    },

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balances[currency],
                'used': 0.0,
                'total': balances[currency],
            };
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetDepthIdLimit (this.extend ({
            'id': this.marketId (symbol),
            'limit': 1000,
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTickerId ({
            'id': this.marketId (symbol),
        });
        let timestamp = ticker['time'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['sell']),
            'ask': parseFloat (ticker['buy']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTradeIdLimit (this.extend ({
            'id': market['id'],
            'limit': 1000,
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostTrade (this.extend ({
            'type': side.toUpperCase (),
            'market': this.marketId (symbol),
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['order']['id'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancel ({ 'order': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'public') {
            url += this.implodeParams (path, params);
        } else {
            let nonce = this.nonce ();
            url += api;
            body = this.urlencode (this.extend ({
                'Method': path.toUpperCase (),
                'Nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Signature': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response['error']));
        return response;
    },
}

//-----------------------------------------------------------------------------

var bter = {
    'id': 'bter',
    'name': 'Bter',
    'countries': [ 'VG', 'CN' ], // British Virgin Islands, China
    'version': '2',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27980479-cfa3188c-6387-11e7-8191-93fc4184ba5c.jpg',
        'api': {
            'public': 'https://data.bter.com/api',
            'private': 'https://api.bter.com/api',
        },
        'www': 'https://bter.com',
        'doc': 'https://bter.com/api2',
    },
    'api': {
        'public': {
            'get': [
                'pairs',
                'marketinfo',
                'marketlist',
                'tickers',
                'ticker/{id}',
                'orderBook/{id}',
                'trade/{id}',
                'tradeHistory/{id}',
                'tradeHistory/{id}/{tid}',
            ],
        },
        'private': {
            'post': [
                'balances',
                'depositAddress',
                'newAddress',
                'depositsWithdrawals',
                'buy',
                'sell',
                'cancelOrder',
                'cancelAllOrders',
                'getOrder',
                'openOrders',
                'tradeHistory',
                'withdraw',
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicGetMarketlist ();
        let markets = response['data'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['pair'];
            let base = market['curr_a'];
            let quote = market['curr_b'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balance = await this.privatePostBalances ();
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let code = this.commonCurrencyCode (currency);
            let account = this.account ();
            if ('available' in balance) {
                if (currency in balance['available']) {
                    account['free'] = parseFloat (balance['available'][currency]);
                }
            }
            if ('locked' in balance) {
                if (currency in balance['locked']) {
                    account['used'] = parseFloat (balance['locked'][currency]);
                }
            }
            account['total'] = this.sum (account['free'], account['used']);
            result[code] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderBookId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    parseTicker (ticker, market = undefined) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['baseVolume']),
            'quoteVolume': parseFloat (ticker['quoteVolume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTickers ();
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let [ baseId, quoteId ] = id.split ('_');
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            let ticker = tickers[id];
            let market = undefined;
            if (symbol in this.markets)
                market = this.markets[symbol];
            if (id in this.markets_by_id)
                market = this.markets_by_id[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerId ({
            'id': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['timestamp']) * 1000;
        return {
            'id': trade['tradeID'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['rate'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        await this.loadMarkets ();
        let response = await this.publicGetTradeHistoryId (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['data'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
            'rate': price,
            'amount': amount,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderNumber'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'orderNumber': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let prefix = (api == 'private') ? (api + '/') : '';
        let url = this.urls['api'][api] + this.version + '/1/' + prefix + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let request = { 'nonce': nonce };
            body = this.urlencode (this.extend (request, query));
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
            headers = {
                'Key': this.apiKey,
                'Sign': signature,
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response)
            if (response['result'] != 'true')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var bxinth = {

    'id': 'bxinth',
    'name': 'BX.in.th',
    'countries': 'TH', // Thailand
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766412-567b1eb4-5ed7-11e7-94a8-ff6a3884f6c5.jpg',
        'api': 'https://bx.in.th/api',
        'www': 'https://bx.in.th',
        'doc': 'https://bx.in.th/info/api',
    },
    'api': {
        'public': {
            'get': [
                '', // ticker
                'options',
                'optionbook',
                'orderbook',
                'pairing',
                'trade',
                'tradehistory',
            ],
        },
        'private': {
            'post': [
                'balance',
                'biller',
                'billgroup',
                'billpay',
                'cancel',
                'deposit',
                'getorders',
                'history',
                'option-issue',
                'option-bid',
                'option-sell',
                'option-myissue',
                'option-mybid',
                'option-myoptions',
                'option-exercise',
                'option-cancel',
                'option-history',
                'order',
                'withdrawal',
                'withdrawal-history',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetPairing ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets[keys[p]];
            let id = market['pairing_id'].toString ();
            let base = market['primary_currency'];
            let quote = market['secondary_currency'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    commonCurrencyCode (currency) {
        // why would they use three letters instead of four for currency codes
        if (currency == 'DAS')
            return 'DASH';
        if (currency == 'DOG')
            return 'DOGE';
        return currency;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balance = response['balance'];
        let result = { 'info': balance };
        let currencies = Object.keys (balance);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = this.commonCurrencyCode (currency);
            let account = {
                'free': parseFloat (balance[currency]['available']),
                'used': 0.0,
                'total': parseFloat (balance[currency]['total']),
            };
            account['used'] = account['total'] - account['free'];
            result[code] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pairing': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['orderbook']['bids']['highbid']),
            'ask': parseFloat (ticker['orderbook']['asks']['highbid']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume_24hours']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGet ();
        let result = {};
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGet ({ 'pairing': market['id'] });
        let id = market['id'].toString ();
        let ticker = tickers[id];
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['trade_date']);
        return {
            'id': trade['trade_id'],
            'info': trade,
            'order': trade['order_id'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['trade_type'],
            'price': parseFloat (trade['rate']),
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrade (this.extend ({
            'pairing': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostOrder (this.extend ({
            'pairing': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        let pairing = undefined; // TODO fixme
        return this.privatePostCancel ({
            'order_id': id,
            'pairing': pairing,
        });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (path)
            url += path + '/';
        if (Object.keys (params).length)
            url += '?' + this.urlencode (params);
        if (api == 'private') {
            let nonce = this.nonce ();
            let auth = this.apiKey + nonce.toString () + this.secret;
            let signature = this.hash (this.encode (auth), 'sha256');
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
                // twofa: this.twofa,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var ccex = {

    'id': 'ccex',
    'name': 'C-CEX',
    'countries': [ 'DE', 'EU' ],
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766433-16881f90-5ed8-11e7-92f8-3d92cc747a6c.jpg',
        'api': {
            'tickers': 'https://c-cex.com/t',
            'public': 'https://c-cex.com/t/api_pub.html',
            'private': 'https://c-cex.com/t/api.html',
        },
        'www': 'https://c-cex.com',
        'doc': 'https://c-cex.com/?id=api',
    },
    'api': {
        'tickers': {
            'get': [
                'coinnames',
                '{market}',
                'pairs',
                'prices',
                'volume_{coin}',
            ],
        },
        'public': {
            'get': [
                'balancedistribution',
                'markethistory',
                'markets',
                'marketsummaries',
                'orderbook',
            ],
        },
        'private': {
            'get': [
                'buylimit',
                'cancel',
                'getbalance',
                'getbalances',
                'getopenorders',
                'getorder',
                'getorderhistory',
                'mytrades',
                'selllimit',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets['result'].length; p++) {
            let market = markets['result'][p];
            let id = market['MarketName'];
            let base = market['MarketCurrency'];
            let quote = market['BaseCurrency'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['result'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let account = {
                'free': balance['Available'],
                'used': balance['Pending'],
                'total': balance['Balance'],
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (this.extend ({
            'market': this.marketId (symbol),
            'type': 'both',
            'depth': 100,
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'Rate', 'Quantity');
    },

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastprice']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'buysupport'),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.tickersGetPrices ();
        let result = { 'info': tickers };
        let ids = Object.keys (tickers);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let ticker = tickers[id];
            let uppercase = id.toUpperCase ();
            let market = undefined;
            let symbol = undefined;
            if (uppercase in this.markets_by_id) {
                market = this.markets_by_id[uppercase];
                symbol = market['symbol'];
            } else {
                let [ base, quote ] = uppercase.split ('-');
                symbol = base + '/' + quote;
            }
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.tickersGetMarket ({
            'market': market['id'].toLowerCase (),
        });
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TimeStamp']);
        return {
            'id': trade['Id'],
            'info': trade,
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['OrderType'].toLowerCase (),
            'price': trade['Price'],
            'amount': trade['Quantity'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarkethistory (this.extend ({
            'market': this.marketId (market),
            'type': 'both',
            'depth': 100,
        }, params));
        return this.parseTrades (response['result'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privateGet' + this.capitalize (side) + type;
        let response = await this[method] (this.extend ({
            'market': this.marketId (symbol),
            'quantity': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['result']['uuid'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privateGetCancel ({ 'uuid': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'private') {
            let nonce = this.nonce ().toString ();
            let query = this.keysort (this.extend ({
                'a': path,
                'apikey': this.apiKey,
                'nonce': nonce,
            }, params));
            url += '?' + this.urlencode (query);
            headers = { 'apisign': this.hmac (this.encode (url), this.encode (this.secret), 'sha512') };
        } else if (api == 'public') {
            url += '?' + this.urlencode (this.extend ({
                'a': 'get' + path,
            }, params));
        } else {
            url += '/' + this.implodeParams (path, params) + '.json';
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'tickers')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var cex = {

    'id': 'cex',
    'name': 'CEX.IO',
    'countries': [ 'GB', 'EU', 'CY', 'RU' ],
    'rateLimit': 1500,
    'hasCORS': true,
    'hasFetchTickers': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
        'api': 'https://cex.io/api',
        'www': 'https://cex.io',
        'doc': 'https://cex.io/cex-api',
    },
    'api': {
        'public': {
            'get': [
                'currency_limits',
                'last_price/{pair}',
                'last_prices/{currencies}',
                'ohlcv/hd/{yyyymmdd}/{pair}',
                'order_book/{pair}',
                'ticker/{pair}',
                'tickers/{currencies}',
                'trade_history/{pair}',
            ],
            'post': [
                'convert/{pair}',
                'price_stats/{pair}',
            ],
        },
        'private': {
            'post': [
                'active_orders_status/',
                'archived_orders/{pair}',
                'balance/',
                'cancel_order/',
                'cancel_orders/{pair}',
                'cancel_replace_order/{pair}',
                'close_position/{pair}',
                'get_address/',
                'get_myfee/',
                'get_order/',
                'get_order_tx/',
                'open_orders/{pair}',
                'open_orders/',
                'open_position/{pair}',
                'open_positions/{pair}',
                'place_order/{pair}',
                'place_order/{pair}',
            ],
        }
    },

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyLimits ();
        let result = [];
        for (let p = 0; p < markets['data']['pairs'].length; p++) {
            let market = markets['data']['pairs'][p];
            let id = market['symbol1'] + '/' + market['symbol2'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = {
                'free': parseFloat (balances[currency]['available']),
                'used': parseFloat (balances[currency]['orders']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await  this.publicGetOrderBookPair (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    },

    parseTicker (ticker, market) {
        let timestamp = undefined;
        let iso8601 = undefined;
        if ('timestamp' in ticker) {
            timestamp = parseInt (ticker['timestamp']) * 1000;
            iso8601 = this.iso8601 (timestamp);
        }
        let volume = this.safeFloat (ticker, 'volume');
        let high = this.safeFloat (ticker, 'high');
        let low = this.safeFloat (ticker, 'low');
        let bid = this.safeFloat (ticker, 'bid');
        let ask = this.safeFloat (ticker, 'ask');
        let last = this.safeFloat (ticker, 'last');
        return {
            'timestamp': timestamp,
            'datetime': iso8601,
            'high': high,
            'low': low,
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let currencies = this.currencies.join ('/');
        let response = await this.publicGetTickersCurrencies ({
            'currencies': currencies,
        });
        let tickers = response['data'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let symbol = ticker['pair'].replace (':', '/');
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerPair ({
            'pair': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradeHistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        else
            order['order_type'] = type;
        let response = await this.privatePostPlaceOrderPair (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'key': this.apiKey,
                'signature': signature.toUpperCase (),
                'nonce': nonce,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('e' in response) {
            if ('ok' in response)
                if (response['ok'] == 'ok')
                    return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var chbtc = {
    'id': 'chbtc',
    'name': 'CHBTC',
    'countries': 'CN',
    'rateLimit': 1000,
    'version': 'v1',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28555659-f0040dc2-7109-11e7-9d99-688a438bf9f4.jpg',
        'api': {
            'public': 'http://api.chbtc.com/data', // no https for public API
            'private': 'https://trade.chbtc.com/api',
        },
        'www': 'https://trade.chbtc.com/api',
        'doc': 'https://www.chbtc.com/i/developer',
    },
    'api': {
        'public': {
            'get': [
                'ticker',
                'depth',
                'trades',
                'kline',
            ],
        },
        'private': {
            'post': [
                'order',
                'cancelOrder',
                'getOrder',
                'getOrders',
                'getOrdersNew',
                'getOrdersIgnoreTradeType',
                'getUnfinishedOrdersIgnoreTradeType',
                'getAccountInfo',
                'getUserAddress',
                'getWithdrawAddress',
                'getWithdrawRecord',
                'getChargeRecord',
                'getCnyWithdrawRecord',
                'getCnyChargeRecord',
                'withdraw',
            ],
        },
    },
    'markets': {
        'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY' },
        'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY' },
        'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY' },
        'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY' },
        'BTS/CNY': { 'id': 'bts_cny', 'symbol': 'BTS/CNY', 'base': 'BTS', 'quote': 'CNY' },
        // 'EOS/CNY': { 'id': 'eos_cny', 'symbol': 'EOS/CNY', 'base': 'EOS', 'quote': 'CNY' },
        'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY' },
        'HSR/CNY': { 'id': 'hsr_cny', 'symbol': 'HSR/CNY', 'base': 'HSR', 'quote': 'CNY' },
        'QTUM/CNY': { 'id': 'qtum_cny', 'symbol': 'QTUM/CNY', 'base': 'QTUM', 'quote': 'CNY' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['result'];
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balances['balance'])
                account['free'] = parseFloat (balances['balance'][currency]['amount']);
            if (currency in balances['frozen'])
                account['used'] = parseFloat (balances['frozen'][currency]['amount']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.publicGetDepth (this.extend ({
            'currency': market['id'],
        }, params));
        let timestamp = this.milliseconds ();
        let bids = undefined;
        let asks = undefined;
        if ('bids' in orderbook)
            bids = orderbook['bids'];
        if ('asks' in orderbook)
            asks = orderbook['asks'];
        let result = {
            'bids': bids,
            'asks': asks,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
        if (result['bids'])
            result['bids'] = this.sortBy (result['bids'], 0, true);
        if (result['asks'])
            result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    async fetchTicker (symbol) {
        let response = await this.publicGetTicker ({
            'currency': this.marketId (symbol),
        });
        let ticker = response['ticker'];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = trade['date'] * 1000;
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'currency': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let paramString = '&price=' + price.toString ();
        paramString += '&amount=' + amount.toString ();
        let tradeType = (side == 'buy') ? '1' : '0';
        paramString += '&tradeType=' + tradeType;
        paramString += '&currency=' + this.marketId (symbol);
        let response = await this.privatePostOrder (paramString);
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id, params = {}) {
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return this.privatePostCancelOrder (paramString);
    },

    async fetchOrder (id, params = {}) {
        let paramString = '&id=' + id.toString ();
        if ('currency' in params)
            paramString += '&currency=' + params['currency'];
        return this.privatePostGetOrder (paramString);
    },

    nonce () {
        return this.milliseconds ();
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if (api == 'public') {
            url += '/' + this.version + '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let paramsLength = params.length; // params should be a string here
            let nonce = this.nonce ();
            let auth = 'method=' + path;
            auth += '&accesskey=' + this.apiKey;
            auth += paramsLength ? params : '';
            let secret = this.hash (this.encode (this.secret), 'sha1');
            let signature = this.hmac (this.encode (auth), this.encode (secret), 'md5');
            let suffix = 'sign=' + signature + '&reqTime=' + nonce.toString ();
            url += '/' + path + '?' + auth + '&' + suffix;
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'private')
            if ('code' in response)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var chilebit = extend (blinktrade, {
    'id': 'chilebit',
    'name': 'ChileBit',
    'countries': 'CL',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27991414-1298f0d8-647f-11e7-9c40-d56409266336.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://chilebit.net',
        'doc': 'https://blinktrade.com/docs',
    },
    'comment': 'Blinktrade API',
    'markets': {
        'BTC/CLP': { 'id': 'BTCCLP', 'symbol': 'BTC/CLP', 'base': 'BTC', 'quote': 'CLP', 'brokerId': 9, 'broker': 'ChileBit' },
    },
})

//-----------------------------------------------------------------------------

var coincheck = {

    'id': 'coincheck',
    'name': 'coincheck',
    'countries': [ 'JP', 'ID' ],
    'rateLimit': 1500,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766464-3b5c3c74-5ed9-11e7-840e-31b32968e1da.jpg',
        'api': 'https://coincheck.com/api',
        'www': 'https://coincheck.com',
        'doc': 'https://coincheck.com/documents/exchange/api',
    },
    'api': {
        'public': {
            'get': [
                'exchange/orders/rate',
                'order_books',
                'rate/{pair}',
                'ticker',
                'trades',
            ],
        },
        'private': {
            'get': [
                'accounts',
                'accounts/balance',
                'accounts/leverage_balance',
                'bank_accounts',
                'deposit_money',
                'exchange/orders/opens',
                'exchange/orders/transactions',
                'exchange/orders/transactions_pagination',
                'exchange/leverage/positions',
                'lending/borrows/matches',
                'send_money',
                'withdraws',
            ],
            'post': [
                'bank_accounts',
                'deposit_money/{id}/fast',
                'exchange/orders',
                'exchange/transfers/to_leverage',
                'exchange/transfers/from_leverage',
                'lending/borrows',
                'lending/borrows/{id}/repay',
                'send_money',
                'withdraws',
            ],
            'delete': [
                'bank_accounts/{id}',
                'exchange/orders/{id}',
                'withdraws/{id}',
            ],
        },
    },
    'markets': {
        'BTC/JPY':  { 'id': 'btc_jpy',  'symbol': 'BTC/JPY',  'base': 'BTC',  'quote': 'JPY' }, // the only real pair
        'ETH/JPY':  { 'id': 'eth_jpy',  'symbol': 'ETH/JPY',  'base': 'ETH',  'quote': 'JPY' },
        'ETC/JPY':  { 'id': 'etc_jpy',  'symbol': 'ETC/JPY',  'base': 'ETC',  'quote': 'JPY' },
        'DAO/JPY':  { 'id': 'dao_jpy',  'symbol': 'DAO/JPY',  'base': 'DAO',  'quote': 'JPY' },
        'LSK/JPY':  { 'id': 'lsk_jpy',  'symbol': 'LSK/JPY',  'base': 'LSK',  'quote': 'JPY' },
        'FCT/JPY':  { 'id': 'fct_jpy',  'symbol': 'FCT/JPY',  'base': 'FCT',  'quote': 'JPY' },
        'XMR/JPY':  { 'id': 'xmr_jpy',  'symbol': 'XMR/JPY',  'base': 'XMR',  'quote': 'JPY' },
        'REP/JPY':  { 'id': 'rep_jpy',  'symbol': 'REP/JPY',  'base': 'REP',  'quote': 'JPY' },
        'XRP/JPY':  { 'id': 'xrp_jpy',  'symbol': 'XRP/JPY',  'base': 'XRP',  'quote': 'JPY' },
        'ZEC/JPY':  { 'id': 'zec_jpy',  'symbol': 'ZEC/JPY',  'base': 'ZEC',  'quote': 'JPY' },
        'XEM/JPY':  { 'id': 'xem_jpy',  'symbol': 'XEM/JPY',  'base': 'XEM',  'quote': 'JPY' },
        'LTC/JPY':  { 'id': 'ltc_jpy',  'symbol': 'LTC/JPY',  'base': 'LTC',  'quote': 'JPY' },
        'DASH/JPY': { 'id': 'dash_jpy', 'symbol': 'DASH/JPY', 'base': 'DASH', 'quote': 'JPY' },
        'ETH/BTC':  { 'id': 'eth_btc',  'symbol': 'ETH/BTC',  'base': 'ETH',  'quote': 'BTC' },
        'ETC/BTC':  { 'id': 'etc_btc',  'symbol': 'ETC/BTC',  'base': 'ETC',  'quote': 'BTC' },
        'LSK/BTC':  { 'id': 'lsk_btc',  'symbol': 'LSK/BTC',  'base': 'LSK',  'quote': 'BTC' },
        'FCT/BTC':  { 'id': 'fct_btc',  'symbol': 'FCT/BTC',  'base': 'FCT',  'quote': 'BTC' },
        'XMR/BTC':  { 'id': 'xmr_btc',  'symbol': 'XMR/BTC',  'base': 'XMR',  'quote': 'BTC' },
        'REP/BTC':  { 'id': 'rep_btc',  'symbol': 'REP/BTC',  'base': 'REP',  'quote': 'BTC' },
        'XRP/BTC':  { 'id': 'xrp_btc',  'symbol': 'XRP/BTC',  'base': 'XRP',  'quote': 'BTC' },
        'ZEC/BTC':  { 'id': 'zec_btc',  'symbol': 'ZEC/BTC',  'base': 'ZEC',  'quote': 'BTC' },
        'XEM/BTC':  { 'id': 'xem_btc',  'symbol': 'XEM/BTC',  'base': 'XEM',  'quote': 'BTC' },
        'LTC/BTC':  { 'id': 'ltc_btc',  'symbol': 'LTC/BTC',  'base': 'LTC',  'quote': 'BTC' },
        'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances)
                account['free'] = parseFloat (balances[lowercase]);
            let reserved = lowercase + '_reserved';
            if (reserved in balances)
                account['used'] = parseFloat (balances[reserved]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await  this.publicGetOrderBooks (params);
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTicker ();
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['created_at']);
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['order_type'],
            'price': parseFloat (trade['rate']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let prefix = '';
        let order = {
            'pair': this.marketId (symbol),
        };
        if (type == 'market') {
            let order_type = type + '_' + side;
            order['order_type'] = order_type;
            let prefix = (side == 'buy') ? (order_type + '_') : '';
            order[prefix + 'amount'] = amount;
        } else {
            order['order_type'] = side;
            order['rate'] = price;
            order['amount'] = amount;
        }
        let response = await this.privatePostExchangeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id) {
        return this.privateDeleteExchangeOrdersId ({ 'id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            let length = 0;
            if (Object.keys (query).length) {
                body = this.urlencode (this.keysort (query));
                length = body.length;
            }
            let auth = nonce + url + (body || '');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'ACCESS-KEY': this.apiKey,
                'ACCESS-NONCE': nonce,
                'ACCESS-SIGNATURE': this.hmac (this.encode (auth), this.encode (this.secret)),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'public')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var coinfloor = {

    'id': 'coinfloor',
    'name': 'coinfloor',
    'rateLimit': 1000,
    'countries': 'UK',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28246081-623fc164-6a1c-11e7-913f-bac0d5576c90.jpg',
        'api': 'https://webapi.coinfloor.co.uk:8090/bist',
        'www': 'https://www.coinfloor.co.uk',
        'doc': [
            'https://github.com/coinfloor/api',
            'https://www.coinfloor.co.uk/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{id}/ticker/',
                '{id}/order_book/',
                '{id}/transactions/',
            ],
        },
        'private': {
            'post': [
                '{id}/balance/',
                '{id}/user_transactions/',
                '{id}/open_orders/',
                '{id}/cancel_order/',
                '{id}/buy/',
                '{id}/sell/',
                '{id}/buy_market/',
                '{id}/sell_market/',
                '{id}/estimate_sell_market/',
                '{id}/estimate_buy_market/',
            ],
        },
    },
    'markets': {
        'BTC/GBP': { 'id': 'XBT/GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP' },
        'BTC/EUR': { 'id': 'XBT/EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'BTC/USD': { 'id': 'XBT/USD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/PLN': { 'id': 'XBT/PLN', 'symbol': 'BTC/PLN', 'base': 'BTC', 'quote': 'PLN' },
        'BCH/GBP': { 'id': 'BCH/GBP', 'symbol': 'BCH/GBP', 'base': 'BCH', 'quote': 'GBP' },
    },

    async fetchBalance (params = {}) {
        let symbol = undefined;
        if ('symbol' in params)
            symbol = params['symbol'];
        if ('id' in params)
            symbol = params['id'];
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchBalance requires a symbol param');
        return this.privatePostIdBalance ({
            'id': this.marketId (symbol),
        });
    },

    async fetchOrderBook (symbol) {
        let orderbook = await this.publicGetIdOrderBook ({
            'id': this.marketId (symbol),
        });
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        // rewrite to get the timestamp from HTTP headers
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': this.safeFloat (ticker, 'vwap'),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let ticker = await this.publicGetIdTicker ({
            'id': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetIdTransactions (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = { 'id': this.marketId (symbol) };
        let method = 'privatePostId' + this.capitalize (side);
        if (type == 'market') {
            order['quantity'] = amount;
            method += 'Market';
        } else {
            order['price'] = price;
            order['amount'] = amount;
        }
        return this[method] (this.extend (order, params));
    },

    async cancelOrder (id) {
        return this.privatePostIdCancelOrder ({ 'id': id });
    },

    request (path, type = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        // curl -k -u '[User ID]/[API key]:[Passphrase]' https://webapi.coinfloor.co.uk:8090/bist/XBT/GBP/balance/
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (type == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
            let auth = this.uid + '/' + this.apiKey + ':' + this.password;
            let signature = this.stringToBase64 (auth);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Authorization': 'Basic ' + signature,
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var coingi = {

    'id': 'coingi',
    'name': 'Coingi',
    'rateLimit': 1000,
    'countries': [ 'PA', 'BG', 'CN', 'US' ], // Panama, Bulgaria, China, US
    'hasFetchTickers': true,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28619707-5c9232a8-7212-11e7-86d6-98fe5d15cc6e.jpg',
        'api': 'https://api.coingi.com',
        'www': 'https://coingi.com',
        'doc': 'http://docs.coingi.apiary.io/',
    },
    'api': {
        'current': {
            'get': [
                'order-book/{pair}/{askCount}/{bidCount}/{depth}',
                'transactions/{pair}/{maxCount}',
                '24hour-rolling-aggregation',
            ],
        },
        'user': {
            'post': [
                'balance',
                'add-order',
                'cancel-order',
                'orders',
                'transactions',
                'create-crypto-withdrawal',
            ],
        },
    },
    'markets': {
        'LTC/BTC': { 'id': 'ltc-btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
        'PPC/BTC': { 'id': 'ppc-btc', 'symbol': 'PPC/BTC', 'base': 'PPC', 'quote': 'BTC' },
        'DOGE/BTC': { 'id': 'doge-btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC' },
        'VTC/BTC': { 'id': 'vtc-btc', 'symbol': 'VTC/BTC', 'base': 'VTC', 'quote': 'BTC' },
        'FTC/BTC': { 'id': 'ftc-btc', 'symbol': 'FTC/BTC', 'base': 'FTC', 'quote': 'BTC' },
        'NMC/BTC': { 'id': 'nmc-btc', 'symbol': 'NMC/BTC', 'base': 'NMC', 'quote': 'BTC' },
        'DASH/BTC': { 'id': 'dash-btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC' },
    },

    async fetchBalance (params = {}) {
        let currencies = [];
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c].toLowerCase ();
            currencies.push (currency);
        }
        let balances = await this.userPostBalance ({
            'currencies': currencies.join (',')
        });
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency']['name'];
            currency = currency.toUpperCase ();
            let account = {
                'free': balance['available'],
                'used': balance['blocked'] + balance['inOrders'] + balance['withdrawing'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.currentGetOrderBookPairAskCountBidCountDepth (this.extend ({
            'pair': market['id'],
            'askCount': 512, // maximum returned number of asks 1-512
            'bidCount': 512, // maximum returned number of bids 1-512
            'depth': 32, // maximum number of depth range steps 1-32
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'baseAmount');
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['highestBid'],
            'ask': ticker['lowestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': ticker['baseVolume'],
            'quoteVolume': ticker['counterVolume'],
            'info': ticker,
        };
        return ticker;
    },

    async fetchTickers (symbols = undefined) {
        let response = await this.currentGet24hourRollingAggregation ();
        let result = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let base = ticker['currencyPair']['base'].toUpperCase ();
            let quote = ticker['currencyPair']['counter'].toUpperCase ();
            let symbol = base + '/' + quote;
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        let tickers = await this.fetchTickers (symbol);
        return tickers[symbol];
    },

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['id'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined, // type
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.currentGetTransactionsPairMaxCount (this.extend ({
            'pair': market['id'],
            'maxCount': 128,
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'currencyPair': this.marketId (symbol),
            'volume': amount,
            'price': price,
            'orderType': (side == 'buy') ? 0 : 1,
        };
        let response = await this.userPostAddOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['result'],
        };
    },

    async cancelOrder (id) {
        return this.userPostCancelOrder ({ 'orderId': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + api + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'current') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let request = this.extend ({
                'token': this.apiKey,
                'nonce': nonce,
            }, query);
            let auth = nonce.toString () + '$' + this.apiKey;
            request['signature'] = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (request);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var coinmarketcap = {

    'id': 'coinmarketcap',
    'name': 'CoinMarketCap',
    'rateLimit': 10000,
    'version': 'v1',
    'countries': 'US',
    'hasCORS': true,
    'hasPrivateAPI': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28244244-9be6312a-69ed-11e7-99c1-7c1797275265.jpg',
        'api': 'https://api.coinmarketcap.com',
        'www': 'https://coinmarketcap.com',
        'doc': 'https://coinmarketcap.com/api',
    },
    'api': {
        'public': {
            'get': [
                'ticker/',
                'ticker/{id}/',
                'global/',
            ],
        },
    },
    'currencies': [
        'AUD',
        'BRL',
        'CAD',
        'CHF',
        'CNY',
        'EUR',
        'GBP',
        'HKD',
        'IDR',
        'INR',
        'JPY',
        'KRW',
        'MXN',
        'RUB',
        'USD',
    ],

    async fetchOrderBook (market, params = {}) {
        throw new ExchangeError ('Fetching order books is not supported by the API of ' + this.id);
    },

    async fetchMarkets () {
        let markets = await this.publicGetTicker ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            for (let c = 0; c < this.currencies.length; c++) {
                let base = market['symbol'];
                let baseId = market['id'];
                let quote = this.currencies[c];
                let quoteId = quote.toLowerCase ();
                let symbol = base + '/' + quote;
                let id = baseId + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                });
            }
        }
        return result;
    },

    async fetchGlobal (currency = 'USD') {
        await this.loadMarkets ();
        let request = {};
        if (currency)
            request['convert'] = currency;
        return this.publicGetGlobal (request);
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        if ('last_updated' in ticker)
            if (ticker['last_updated'])
                timestamp = parseInt (ticker['last_updated']) * 1000;
        let volume = undefined;
        let volumeKey = '24h_volume_' + market['quoteId'];
        if (ticker[volumeKey])
            volume = parseFloat (ticker[volumeKey]);
        let price = 'price_' + market['quoteId'];
        let change = undefined;
        let changeKey = 'percent_change_24h';
        if (ticker[changeKey])
            change = parseFloat (ticker[changeKey]);
        let last = undefined;
        if (price in ticker)
            if (ticker[price])
                last = parseFloat (ticker[price]);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': change,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    },

    async fetchTickers (currency = 'USD') {
        await this.loadMarkets ();
        let request = {};
        if (currency)
            request['convert'] = currency;
        let response = await this.publicGetTicker (request);
        let tickers = {};
        for (let t = 0; t < response.length; t++) {
            let ticker = response[t];
            let id = ticker['id'] + '/' + currency;
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            tickers[symbol] = this.parseTicker (ticker, market);
        }
        return tickers;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'convert': market['quote'],
            'id': market['baseId'],
        };
        let response = await this.publicGetTickerId (request);
        let ticker = response[0];
        return this.parseTicker (ticker, market);
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var coinmate = {

    'id': 'coinmate',
    'name': 'CoinMate',
    'countries': [ 'GB', 'CZ' ], // UK, Czech Republic
    'rateLimit': 1000,
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27811229-c1efb510-606c-11e7-9a36-84ba2ce412d8.jpg',
        'api': 'https://coinmate.io/api',
        'www': 'https://coinmate.io',
        'doc': [
            'http://docs.coinmate.apiary.io',
            'https://coinmate.io/developers',
        ],
    },
    'api': {
        'public': {
            'get': [
                'orderBook',
                'ticker',
                'transactions',
            ],
        },
        'private': {
            'post': [
                'balances',
                'bitcoinWithdrawal',
                'bitcoinDepositAddresses',
                'buyInstant',
                'buyLimit',
                'cancelOrder',
                'cancelOrderWithInfo',
                'createVoucher',
                'openOrders',
                'redeemVoucher',
                'sellInstant',
                'sellLimit',
                'transactionHistory',
                'unconfirmedBitcoinDeposits',
            ],
        },
    },
    'markets': {
        'BTC/EUR': { 'id': 'BTC_EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
        'BTC/CZK': { 'id': 'BTC_CZK', 'symbol': 'BTC/CZK', 'base': 'BTC', 'quote': 'CZK' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostBalances ();
        let balances = response['data'];
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in balances) {
                account['free'] = balances[currency]['available'];
                account['used'] = balances[currency]['reserved'];
                account['total'] = balances[currency]['balance'];
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPriceLimit': 'False',
        }, params));
        let orderbook = response['data'];
        let timestamp = orderbook['timestamp'] * 1000;
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        let response = await this.publicGetTicker ({
            'currencyPair': this.marketId (symbol),
        });
        let ticker = response['data'];
        let timestamp = ticker['timestamp'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['amount']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'id': trade['transactionId'],
            'info': trade,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'currencyPair': market['id'],
            'minutesIntoHistory': 10,
        }, params));
        return this.parseTrades (response['data'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'currencyPair': this.marketId (symbol),
        };
        if (type == 'market') {
            if (side == 'buy')
                order['total'] = amount; // amount in fiat
            else
                order['amount'] = amount; // amount in fiat
            method += 'Instant';
        } else {
            order['amount'] = amount; // amount in crypto
            order['price'] = price;
            method += this.capitalize (type);
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['data'].toString (),
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancelOrder ({ 'orderId': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ().toString ();
            let auth = nonce + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.urlencode (this.extend ({
                'clientId': this.uid,
                'nonce': nonce,
                'publicKey': this.apiKey,
                'signature': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type':  'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var coinsecure = {

    'id': 'coinsecure',
    'name': 'Coinsecure',
    'countries': 'IN', // India
    'rateLimit': 1000,
    'version': 'v1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766472-9cbd200a-5ed9-11e7-9551-2267ad7bac08.jpg',
        'api': 'https://api.coinsecure.in',
        'www': 'https://coinsecure.in',
        'doc': [
            'https://api.coinsecure.in',
            'https://github.com/coinsecure/plugins',
        ],
    },
    'api': {
        'public': {
            'get': [
                'bitcoin/search/confirmation/{txid}',
                'exchange/ask/low',
                'exchange/ask/orders',
                'exchange/bid/high',
                'exchange/bid/orders',
                'exchange/lastTrade',
                'exchange/max24Hr',
                'exchange/min24Hr',
                'exchange/ticker',
                'exchange/trades',
            ],
        },
        'private': {
            'get': [
                'mfa/authy/call',
                'mfa/authy/sms',
                'netki/search/{netkiName}',
                'user/bank/otp/{number}',
                'user/kyc/otp/{number}',
                'user/profile/phone/otp/{number}',
                'user/wallet/coin/address/{id}',
                'user/wallet/coin/deposit/confirmed/all',
                'user/wallet/coin/deposit/confirmed/{id}',
                'user/wallet/coin/deposit/unconfirmed/all',
                'user/wallet/coin/deposit/unconfirmed/{id}',
                'user/wallet/coin/wallets',
                'user/exchange/bank/fiat/accounts',
                'user/exchange/bank/fiat/balance/available',
                'user/exchange/bank/fiat/balance/pending',
                'user/exchange/bank/fiat/balance/total',
                'user/exchange/bank/fiat/deposit/cancelled',
                'user/exchange/bank/fiat/deposit/unverified',
                'user/exchange/bank/fiat/deposit/verified',
                'user/exchange/bank/fiat/withdraw/cancelled',
                'user/exchange/bank/fiat/withdraw/completed',
                'user/exchange/bank/fiat/withdraw/unverified',
                'user/exchange/bank/fiat/withdraw/verified',
                'user/exchange/ask/cancelled',
                'user/exchange/ask/completed',
                'user/exchange/ask/pending',
                'user/exchange/bid/cancelled',
                'user/exchange/bid/completed',
                'user/exchange/bid/pending',
                'user/exchange/bank/coin/addresses',
                'user/exchange/bank/coin/balance/available',
                'user/exchange/bank/coin/balance/pending',
                'user/exchange/bank/coin/balance/total',
                'user/exchange/bank/coin/deposit/cancelled',
                'user/exchange/bank/coin/deposit/unverified',
                'user/exchange/bank/coin/deposit/verified',
                'user/exchange/bank/coin/withdraw/cancelled',
                'user/exchange/bank/coin/withdraw/completed',
                'user/exchange/bank/coin/withdraw/unverified',
                'user/exchange/bank/coin/withdraw/verified',
                'user/exchange/bank/summary',
                'user/exchange/coin/fee',
                'user/exchange/fiat/fee',
                'user/exchange/kycs',
                'user/exchange/referral/coin/paid',
                'user/exchange/referral/coin/successful',
                'user/exchange/referral/fiat/paid',
                'user/exchange/referrals',
                'user/exchange/trade/summary',
                'user/login/token/{token}',
                'user/summary',
                'user/wallet/summary',
                'wallet/coin/withdraw/cancelled',
                'wallet/coin/withdraw/completed',
                'wallet/coin/withdraw/unverified',
                'wallet/coin/withdraw/verified',
            ],
            'post': [
                'login',
                'login/initiate',
                'login/password/forgot',
                'mfa/authy/initiate',
                'mfa/ga/initiate',
                'signup',
                'user/netki/update',
                'user/profile/image/update',
                'user/exchange/bank/coin/withdraw/initiate',
                'user/exchange/bank/coin/withdraw/newVerifycode',
                'user/exchange/bank/fiat/withdraw/initiate',
                'user/exchange/bank/fiat/withdraw/newVerifycode',
                'user/password/change',
                'user/password/reset',
                'user/wallet/coin/withdraw/initiate',
                'wallet/coin/withdraw/newVerifycode',
            ],
            'put': [
                'signup/verify/{token}',
                'user/exchange/kyc',
                'user/exchange/bank/fiat/deposit/new',
                'user/exchange/ask/new',
                'user/exchange/bid/new',
                'user/exchange/instant/buy',
                'user/exchange/instant/sell',
                'user/exchange/bank/coin/withdraw/verify',
                'user/exchange/bank/fiat/account/new',
                'user/exchange/bank/fiat/withdraw/verify',
                'user/mfa/authy/initiate/enable',
                'user/mfa/ga/initiate/enable',
                'user/netki/create',
                'user/profile/phone/new',
                'user/wallet/coin/address/new',
                'user/wallet/coin/new',
                'user/wallet/coin/withdraw/sendToExchange',
                'user/wallet/coin/withdraw/verify',
            ],
            'delete': [
                'user/gcm/{code}',
                'user/logout',
                'user/exchange/bank/coin/withdraw/unverified/cancel/{withdrawID}',
                'user/exchange/bank/fiat/deposit/cancel/{depositID}',
                'user/exchange/ask/cancel/{orderID}',
                'user/exchange/bid/cancel/{orderID}',
                'user/exchange/bank/fiat/withdraw/unverified/cancel/{withdrawID}',
                'user/mfa/authy/disable/{code}',
                'user/mfa/ga/disable/{code}',
                'user/profile/phone/delete',
                'user/profile/image/delete/{netkiName}',
                'user/wallet/coin/withdraw/unverified/cancel/{withdrawID}',
            ],
        },
    },
    'markets': {
        'BTC/INR': { 'id': 'BTC/INR', 'symbol': 'BTC/INR', 'base': 'BTC', 'quote': 'INR' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privateGetUserExchangeBankSummary ();
        let balance = response['message'];
        let coin = {
            'free': balance['availableCoinBalance'],
            'used': balance['pendingCoinBalance'],
            'total': balance['totalCoinBalance'],
        };
        let fiat = {
            'free': balance['availableFiatBalance'],
            'used': balance['pendingFiatBalance'],
            'total': balance['totalFiatBalance'],
        };
        let result = {
            'info': balance,
            'BTC': coin,
            'INR': fiat,
        };
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let bids = await this.publicGetExchangeBidOrders (params);
        let asks = await this.publicGetExchangeAskOrders (params);
        let orderbook = {
            'bids': bids['message'],
            'asks': asks['message'],
        };
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'rate', 'vol');
    },

    async fetchTicker (market) {
        let response = await this.publicGetExchangeTicker ();
        let ticker = response['message'];
        let timestamp = ticker['timestamp'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['coinvolume']),
            'quoteVolume': parseFloat (ticker['fiatvolume']),
            'info': ticker,
        };
    },

    fetchTrades (market, params = {}) {
        return this.publicGetExchangeTrades (params);
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePutUserExchange';
        let order = {};
        if (type == 'market') {
            method += 'Instant' + this.capitalize (side);
            if (side == 'buy')
                order['maxFiat'] = amount;
            else
                order['maxVol'] = amount;
        } else {
            let direction = (side == 'buy') ? 'Bid' : 'Ask';
            method += direction + 'New';
            order['rate'] = price;
            order['vol'] = amount;
        }
        let response = await this[method] (self.extend (order, params));
        return {
            'info': response,
            'id': response['message']['orderID'],
        };
    },

    cancelOrder (id) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privateDeleteUserExchangeAskCancelOrderId'; // TODO fixme, have to specify order side here
        return this[method] ({ 'orderID': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            headers = { 'Authorization': this.apiKey };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        let response = await this.fetch (url, method, headers, body);
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var coinspot = {

    'id': 'coinspot',
    'name': 'CoinSpot',
    'countries': 'AU', // Australia
    'rateLimit': 1000,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
        'api': {
            'public': 'https://www.coinspot.com.au/pubapi',
            'private': 'https://www.coinspot.com.au/api',
        },
        'www': 'https://www.coinspot.com.au',
        'doc': 'https://www.coinspot.com.au/api',
    },
    'api': {
        'public': {
            'get': [
                'latest',
            ],
        },
        'private': {
            'post': [
                'orders',
                'orders/history',
                'my/coin/deposit',
                'my/coin/send',
                'quote/buy',
                'quote/sell',
                'my/balances',
                'my/orders',
                'my/buy',
                'my/sell',
                'my/buy/cancel',
                'my/sell/cancel',
            ],
        },
    },
    'markets': {
        'BTC/AUD': { 'id': 'BTC', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD' },
        'LTC/AUD': { 'id': 'LTC', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD' },
        'DOGE/AUD': { 'id': 'DOGE', 'symbol': 'DOGE/AUD', 'base': 'DOGE', 'quote': 'AUD' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostMyBalances ();
        let result = { 'info': response };
        if ('balance' in response) {
            let balances = response['balance'];
            let currencies = Object.keys (balances);
            for (let c = 0; c < currencies.length; c++) {
                let currency = currencies[c];
                let uppercase = currency.toUpperCase ();
                let account = {
                    'free': balances[currency],
                    'used': 0.0,
                    'total': balances[currency],
                };
                if (uppercase == 'DRK')
                    uppercase = 'DASH';
                result[uppercase] = account;
            }
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let orderbook = await this.privatePostOrders (this.extend ({
            'cointype': market['id'],
        }, params));
        let timestamp = this.milliseconds ();
        let result = this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'rate', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    async fetchTicker (market) {
        let response = await this.publicGetLatest ();
        let id = this.marketId (market);
        id = id.toLowerCase ();
        let ticker = response['prices'][id];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': undefined,
            'info': ticker,
        };
    },

    fetchTrades (market, params = {}) {
        return this.privatePostOrdersHistory (this.extend ({
            'cointype': this.marketId (market),
        }, params));
    },

    createOrder (market, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePostMy' + this.capitalize (side);
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let order = {
            'cointype': this.marketId (market),
            'amount': amount,
            'rate': price,
        };
        return this[method] (this.extend (order, params));
    },

    cancelOrder (id, params = {}) {
        throw new ExchangeError (this.id + ' cancelOrder () is not fully implemented yet');
        let method = 'privatePostMyBuy';
        return this[method] ({ 'id': id });
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests');
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'private') {
            let nonce = this.nonce ();
            body = this.json (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/json',
                'key': this.apiKey,
                'sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var cryptopia = {

    'id': 'cryptopia',
    'name': 'Cryptopia',
    'rateLimit': 1500,
    'countries': 'NZ', // New Zealand
    'hasFetchTickers': true,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/29484394-7b4ea6e2-84c6-11e7-83e5-1fccf4b2dc81.jpg',
        'api': 'https://www.cryptopia.co.nz/api',
        'www': 'https://www.cryptopia.co.nz',
        'doc': [
            'https://www.cryptopia.co.nz/Forum/Thread/255',
            'https://www.cryptopia.co.nz/Forum/Thread/256',
        ],
    },
    'api': {
        'public': {
            'get': [
                'GetCurrencies',
                'GetTradePairs',
                'GetMarkets',
                'GetMarkets/{id}',
                'GetMarkets/{hours}',
                'GetMarkets/{id}/{hours}',
                'GetMarket/{id}',
                'GetMarket/{id}/{hours}',
                'GetMarketHistory/{id}',
                'GetMarketHistory/{id}/{hours}',
                'GetMarketOrders/{id}',
                'GetMarketOrders/{id}/{count}',
                'GetMarketOrderGroups/{ids}/{count}',
            ],
        },
        'private': {
            'post': [
                'CancelTrade',
                'GetBalance',
                'GetDepositAddress',
                'GetOpenOrders',
                'GetTradeHistory',
                'GetTransactions',
                'SubmitTip',
                'SubmitTrade',
                'SubmitTransfer',
                'SubmitWithdraw',
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicGetTradePairs ();
        let result = [];
        let markets = response['Data'];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['Id'];
            let symbol = market['Label'];
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
                'maker': market['TradeFee'] / 100,
                'taker': market['TradeFee'] / 100,
            });
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketOrdersId (this.extend ({
            'id': this.marketId (market),
        }, params));
        let orderbook = response['Data'];
        return this.parseOrderBook (orderbook, undefined, 'Buy', 'Sell', 'Price', 'Volume');
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'info': ticker,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['High']),
            'low': parseFloat (ticker['Low']),
            'bid': parseFloat (ticker['BidPrice']),
            'ask': parseFloat (ticker['AskPrice']),
            'vwap': undefined,
            'open': parseFloat (ticker['Open']),
            'close': parseFloat (ticker['Close']),
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': parseFloat (ticker['Change']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['BaseVolume']),
            'quoteVolume': parseFloat (ticker['Volume']),
        };
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketId ({
            'id': market['id'],
        });
        let ticker = response['Data'];
        return this.parseTicker (ticker, market);
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetMarkets ();
        let result = {};
        let tickers = response['Data'];
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['TradePairId'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    parseTrade (trade, market) {
        let timestamp = trade['Timestamp'] * 1000;
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['Type'].toLowerCase (),
            'price': trade['Price'],
            'amount': trade['Amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketHistoryIdHours (this.extend ({
            'id': market['id'],
            'hours': 24, // default
        }, params));
        let trades = response['Data'];
        return this.parseTrades (trades, market);
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalance ();
        let balances = response['Data'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let currency = balance['Symbol'];
            let account = {
                'free': balance['Available'],
                'used': 0.0,
                'total': balance['Total'],
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'TradePairId': this.marketId (market),
            'Type': this.capitalize (side),
            'Rate': price,
            'Amount': amount,
        };
        let response = await this.privatePostSubmitTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['Data']['OrderId'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelTrade ({
            'Type': 'Trade',
            'OrderId': id,
        });
    },

    parseOrder (order, market = undefined) {
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('Market' in order) {
            let id = order['Market'];
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            }
        }
        let timestamp = this.parse8601 (order['TimeStamp']);
        let amount = order['Amount'];
        let remaining = order['Remaining'];
        let filled = amount - remaining;
        return {
            'id': order['OrderId'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': 'limit',
            'side': order['Type'].toLowerCase (),
            'price': order['Rate'],
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' fetchOpenOrders requires a symbol param');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.privatePostGetOpenOrders ({
            // 'Market': market['id'],
            'TradePairId': market['id'], // Cryptopia identifier (not required if 'Market' supplied)
            // 'Count': 100, // default = 100
        }, params);
        let orders = response['Data'];
        let result = [];
        for (let i = 0; i < orders.length; i++) {
            let order = orders[i];
            result.push (this.extend (order, { 'status': 'open' }));
        }
        return this.parseOrders (result, market);
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostSubmitWithdraw (this.extend ({
            'Currency': currency,
            'Amount': amount,
            'Address': address, // Address must exist in you AddressBook in security settings
        }, params));
        return {
            'info': response,
            'id': response['Data'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            body = this.json (query);
            let hash = this.hash (this.encode (body), 'md5', 'base64');
            let secret = this.base64ToBinary (this.secret);
            let uri = this.encodeURIComponent (url);
            let lowercase = uri.toLowerCase ();
            let payload = this.apiKey + method + lowercase + nonce + this.binaryToString (hash);
            let signature = this.hmac (this.encode (payload), secret, 'sha256', 'base64');
            let auth = 'amx ' + this.apiKey + ':' + this.binaryToString (signature) + ':' + nonce;
            headers = {
                'Content-Type': 'application/json',
                'Authorization': auth,
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if (response)
            if ('Success' in response)
                if (response['Success'])
                    return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var dsx = {

    'id': 'dsx',
    'name': 'DSX',
    'countries': 'UK',
    'rateLimit': 1500,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27990275-1413158a-645a-11e7-931c-94717f7510e3.jpg',
        'api': {
            'mapi': 'https://dsx.uk/mapi', // market data
            'tapi': 'https://dsx.uk/tapi', // trading
            'dwapi': 'https://dsx.uk/dwapi', // deposit/withdraw
        },
        'www': 'https://dsx.uk',
        'doc': [
            'https://api.dsx.uk',
            'https://dsx.uk/api_docs/public',
            'https://dsx.uk/api_docs/private',
            '',
        ],
    },
    'api': {
        // market data (public)
        'mapi': {
            'get': [
                'barsFromMoment/{id}/{period}/{start}', // empty reply :\
                'depth/{id}',
                'info',
                'lastBars/{id}/{period}/{amount}', // period is (m, h or d)
                'periodBars/{id}/{period}/{start}/{end}',
                'ticker/{id}',
                'trades/{id}',
            ],
        },
        // trading (private)
        'tapi': {
            'post': [
                'getInfo',
                'TransHistory',
                'TradeHistory',
                'OrderHistory',
                'ActiveOrders',
                'Trade',
                'CancelOrder',
            ],
        },
        // deposit / withdraw (private)
        'dwapi': {
            'post': [
                'getCryptoDepositAddress',
                'cryptoWithdraw',
                'fiatWithdraw',
                'getTransactionStatus',
                'getTransactions',
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.mapiGetInfo ();
        let keys = Object.keys (response['pairs']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = response['pairs'][id];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.tapiPostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances['total']);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let account = {
                'free': balances['funds'][currency],
                'used': 0.0,
                'total': balances['total'][currency],
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.mapiGetDepthId (this.extend ({
            'id': market['id'],
        }, params));
        let orderbook = response[market['id']];
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.mapiGetTickerId ({
            'id': market['id'],
        });
        let ticker = response[market['id']];
        let timestamp = ticker['updated'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker['vol_cur']),
            'info': ticker,
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        return await this.mapiGetTradesId (this.extend ({
            'id': this.marketId (symbol),
        }, params));
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'rate': price,
            'amount': amount,
        };
        let response = await this.tapiPostTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['return']['orderId'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return await this.tapiPostCancelOrder ({ 'orderId': id });
    },

    async request (path, api = 'mapi', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        if ((api == 'mapi') || (api == 'dwapi'))
            url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'mapi') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': nonce,
            }, query));
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.decode (signature),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'mapi')
            return response;
        if ('success' in response)
            if (response['success'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var exmo = {

    'id': 'exmo',
    'name': 'EXMO',
    'countries': [ 'ES', 'RU' ], // Spain, Russia
    'rateLimit': 1000, // once every 350 ms ≈ 180 requests per minute ≈ 3 requests per second
    'version': 'v1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
        'api': 'https://api.exmo.com',
        'www': 'https://exmo.me',
        'doc': [
            'https://exmo.me/ru/api_doc',
            'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs',
        ],
    },
    'api': {
        'public': {
            'get': [
                'currency',
                'order_book',
                'pair_settings',
                'ticker',
                'trades',
            ],
        },
        'private': {
            'post': [
                'user_info',
                'order_create',
                'order_cancel',
                'user_open_orders',
                'user_trades',
                'user_cancelled_orders',
                'order_trades',
                'required_amount',
                'deposit_address',
                'withdraw_crypt',
                'withdraw_get_txid',
                'excode_create',
                'excode_load',
                'wallet_history',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetPairSettings ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let symbol = id.replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostUserInfo ();
        let result = { 'info': response };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let account = this.account ();
            if (currency in response['balances'])
                account['free'] = parseFloat (response['balances'][currency]);
            if (currency in response['reserved'])
                account['used'] = parseFloat (response['reserved'][currency]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response[market['id']];
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask');
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['updated'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy_price']),
            'ask': parseFloat (ticker['sell_price']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker['vol_curr']),
            'info': ticker,
        };
    },

    async fetchTickers (currency = 'USD') {
        await this.loadMarkets ();
        let response = await this.publicGetTicker ();
        let result = {};
        let ids = Object.keys (response);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = response[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let response = await this.publicGetTicker ();
        let market = this.market (symbol);
        return this.parseTicker (response[market['id']], market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response[market['id']], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let prefix = '';
        if (type == 'market')
            prefix = 'market_';
        let order = {
            'pair': this.marketId (symbol),
            'quantity': amount,
            'price': price || 0,
            'type': prefix + side,
        };
        let response = await this.privatePostOrderCreate (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return await this.privatePostOrderCancel ({ 'order_id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response) {
            if (response['result'])
                return response;
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var flowbtc = {

    'id': 'flowbtc',
    'name': 'flowBTC',
    'countries': 'BR', // Brazil
    'version': 'v1',
    'rateLimit': 1000,
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28162465-cd815d4c-67cf-11e7-8e57-438bea0523a2.jpg',
        'api': 'https://api.flowbtc.com:8400/ajax',
        'www': 'https://trader.flowbtc.com',
        'doc': 'http://www.flowbtc.com.br/api/',
    },
    'api': {
        'public': {
            'post': [
                'GetTicker',
                'GetTrades',
                'GetTradesByDate',
                'GetOrderBook',
                'GetProductPairs',
                'GetProducts',
            ],
        },
        'private': {
            'post': [
                'CreateAccount',
                'GetUserInfo',
                'SetUserInfo',
                'GetAccountInfo',
                'GetAccountTrades',
                'GetDepositAddresses',
                'Withdraw',
                'CreateOrder',
                'ModifyOrder',
                'CancelOrder',
                'CancelAllOrders',
                'GetAccountOpenOrders',
                'GetOrderFee',
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicPostGetProductPairs ();
        let markets = response['productPairs'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['name'];
            let base = market['product1Label'];
            let quote = market['product2Label'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['currencies'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['name'];
            let account = {
                'free': balance['balance'],
                'used': balance['hold'],
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicPostGetOrderBook (this.extend ({
            'productPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'px', 'qty');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicPostGetTicker ({
            'productPair': market['id'],
        });
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume24hr']),
            'quoteVolume': parseFloat (ticker['volume24hrProduct2']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['unixtime'] * 1000;
        let side = (trade['incomingOrderSide'] == 0) ? 'buy' : 'sell';
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': side,
            'price': trade['px'],
            'amount': trade['qty'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicPostGetTrades (this.extend ({
            'ins': market['id'],
            'startIndex': -1,
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let orderType = (type == 'market') ? 1 : 0;
        let order = {
            'ins': this.marketId (symbol),
            'side': side,
            'orderType': orderType,
            'qty': amount,
            'px': price,
        };
        let response = await this.privatePostCreateOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['serverOrderId'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        if ('ins' in params) {
            return this.privatePostCancelOrder (this.extend ({
                'serverOrderId': id,
            }, params));
        }
        throw new ExchangeError (this.id + ' requires `ins` symbol parameter for cancelling an order');
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length) {
                body = this.json (params);
            }
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ();
            let auth = nonce.toString () + this.uid + this.apiKey;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret));
            body = this.json (this.extend ({
                'apiKey': this.apiKey,
                'apiNonce': nonce,
                'apiSig': signature.toUpperCase (),
            }, params));
            headers = {
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('isAccepted' in response)
            if (response['isAccepted'])
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var foxbit = extend (blinktrade, {
    'id': 'foxbit',
    'name': 'FoxBit',
    'countries': 'BR',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27991413-11b40d42-647f-11e7-91ee-78ced874dd09.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://foxbit.exchange',
        'doc': 'https://blinktrade.com/docs',
    },
    'comment': 'Blinktrade API',
    'markets': {
        'BTC/BRL': { 'id': 'BTCBRL', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'brokerId': 4, 'broker': 'FoxBit' },
    },
})

//-----------------------------------------------------------------------------

var fyb = {

    'rateLimit': 1500,
    'api': {
        'public': {
            'get': [
                'ticker',
                'tickerdetailed',
                'orderbook',
                'trades',
            ],
        },
        'private': {
            'post': [
                'test',
                'getaccinfo',
                'getpendingorders',
                'getorderhistory',
                'cancelpendingorder',
                'placeorder',
                'withdraw',
            ],
        },
    },

    async fetchBalance (params = {}) {
        let balance = await this.privatePostGetaccinfo ();
        let btc = parseFloat (balance['btcBal']);
        let symbol = this.symbols[0];
        let quote = this.markets[symbol]['quote'];
        let lowercase = quote.toLowerCase () + 'Bal';
        let fiat = parseFloat (balance[lowercase]);
        let crypto = {
            'free': btc,
            'used': 0.0,
            'total': btc,
        };
        let accounts = { 'BTC': crypto };
        accounts[quote] = {
            'free': fiat,
            'used': 0.0,
            'total': fiat,
        };
        accounts['info'] = balance;
        return accounts;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderbook (params);
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTickerdetailed ();
        let timestamp = this.milliseconds ();
        let last = undefined;
        let volume = undefined;
        if ('last' in ticker)
            last = parseFloat (ticker['last']);
        if ('vol' in ticker)
            volume = parseFloat (ticker['vol']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': volume,
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (params);
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let response = await this.privatePostPlaceorder (this.extend ({
            'qty': amount,
            'price': price,
            'type': side[0].toUpperCase ()
        }, params));
        return {
            'info': response,
            'id': response['pending_oid'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancelpendingorder ({ 'orderNo': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            url += '.json';
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({ 'timestamp': nonce }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sig': this.hmac (this.encode (body), this.encode (this.secret), 'sha1')
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if (api == 'private')
            if ('error' in response)
                if (response['error'])
                    throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var fybse = extend (fyb, {
    'id': 'fybse',
    'name': 'FYB-SE',
    'countries': 'SE', // Sweden
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766512-31019772-5edb-11e7-8241-2e675e6797f1.jpg',
        'api': 'https://www.fybse.se/api/SEK',
        'www': 'https://www.fybse.se',
        'doc': 'http://docs.fyb.apiary.io',
    },
    'markets': {
        'BTC/SEK': { 'id': 'SEK', 'symbol': 'BTC/SEK', 'base': 'BTC', 'quote': 'SEK' },
    },
})

//-----------------------------------------------------------------------------

var fybsg = extend (fyb, {
    'id': 'fybsg',
    'name': 'FYB-SG',
    'countries': 'SG', // Singapore
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766513-3364d56a-5edb-11e7-9e6b-d5898bb89c81.jpg',
        'api': 'https://www.fybsg.com/api/SGD',
        'www': 'https://www.fybsg.com',
        'doc': 'http://docs.fyb.apiary.io',
    },
    'markets': {
        'BTC/SGD': { 'id': 'SGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
    },
})

//-----------------------------------------------------------------------------

var gatecoin = {

    'id': 'gatecoin',
    'name': 'Gatecoin',
    'rateLimit': 2000,
    'countries': 'HK', // Hong Kong
    'comment': 'a regulated/licensed exchange',
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1m',
        '15m': '15m',
        '1h': '1h',
        '6h': '6h',
        '1d': '24h',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28646817-508457f2-726c-11e7-9eeb-3528d2413a58.jpg',
        'api': 'https://api.gatecoin.com',
        'www': 'https://gatecoin.com',
        'doc': [
            'https://gatecoin.com/api',
            'https://github.com/Gatecoin/RESTful-API-Implementation',
            'https://api.gatecoin.com/swagger-ui/index.html',
        ],
    },
    'api': {
        'public': {
            'get': [
                'Public/ExchangeRate', // Get the exchange rates
                'Public/LiveTicker', // Get live ticker for all currency
                'Public/LiveTicker/{CurrencyPair}', // Get live ticker by currency
                'Public/LiveTickers', // Get live ticker for all currency
                'Public/MarketDepth/{CurrencyPair}', // Gets prices and market depth for the currency pair.
                'Public/NetworkStatistics/{DigiCurrency}', // Get the network status of a specific digital currency
                'Public/StatisticHistory/{DigiCurrency}/{Typeofdata}', // Get the historical data of a specific digital currency
                'Public/TickerHistory/{CurrencyPair}/{Timeframe}', // Get ticker history
                'Public/Transactions/{CurrencyPair}', // Gets recent transactions
                'Public/TransactionsHistory/{CurrencyPair}', // Gets all transactions
                'Reference/BusinessNatureList', // Get the business nature list.
                'Reference/Countries', // Get the country list.
                'Reference/Currencies', // Get the currency list.
                'Reference/CurrencyPairs', // Get the currency pair list.
                'Reference/CurrentStatusList', // Get the current status list.
                'Reference/IdentydocumentTypes', // Get the different types of identity documents possible.
                'Reference/IncomeRangeList', // Get the income range list.
                'Reference/IncomeSourceList', // Get the income source list.
                'Reference/VerificationLevelList', // Get the verif level list.
                'Stream/PublicChannel', // Get the public pubnub channel list
            ],
            'post': [
                'Export/Transactions', // Request a export of all trades from based on currencypair, start date and end date
                'Ping', // Post a string, then get it back.
                'Public/Unsubscribe/{EmailCode}', // Lets the user unsubscribe from emails
                'RegisterUser', // Initial trader registration.
            ],
        },
        'private': {
            'get': [
                'Account/CorporateData', // Get corporate account data
                'Account/DocumentAddress', // Check if residence proof uploaded
                'Account/DocumentCorporation', // Check if registered document uploaded
                'Account/DocumentID', // Check if ID document copy uploaded
                'Account/DocumentInformation', // Get Step3 Data
                'Account/Email', // Get user email
                'Account/FeeRate', // Get fee rate of logged in user
                'Account/Level', // Get verif level of logged in user
                'Account/PersonalInformation', // Get Step1 Data
                'Account/Phone', // Get user phone number
                'Account/Profile', // Get trader profile
                'Account/Questionnaire', // Fill the questionnaire
                'Account/Referral', // Get referral information
                'Account/ReferralCode', // Get the referral code of the logged in user
                'Account/ReferralNames', // Get names of referred traders
                'Account/ReferralReward', // Get referral reward information
                'Account/ReferredCode', // Get referral code
                'Account/ResidentInformation', // Get Step2 Data
                'Account/SecuritySettings', // Get verif details of logged in user
                'Account/User', // Get all user info
                'APIKey/APIKey', // Get API Key for logged in user
                'Auth/ConnectionHistory', // Gets connection history of logged in user
                'Balance/Balances', // Gets the available balance for each currency for the logged in account.
                'Balance/Balances/{Currency}', // Gets the available balance for s currency for the logged in account.
                'Balance/Deposits', // Get all account deposits, including wire and digital currency, of the logged in user
                'Balance/Withdrawals', // Get all account withdrawals, including wire and digital currency, of the logged in user
                'Bank/Accounts/{Currency}/{Location}', // Get internal bank account for deposit
                'Bank/Transactions', // Get all account transactions of the logged in user
                'Bank/UserAccounts', // Gets all the bank accounts related to the logged in user.
                'Bank/UserAccounts/{Currency}', // Gets all the bank accounts related to the logged in user.
                'ElectronicWallet/DepositWallets', // Gets all crypto currency addresses related deposits to the logged in user.
                'ElectronicWallet/DepositWallets/{DigiCurrency}', // Gets all crypto currency addresses related deposits to the logged in user by currency.
                'ElectronicWallet/Transactions', // Get all digital currency transactions of the logged in user
                'ElectronicWallet/Transactions/{DigiCurrency}', // Get all digital currency transactions of the logged in user
                'ElectronicWallet/UserWallets', // Gets all external digital currency addresses related to the logged in user.
                'ElectronicWallet/UserWallets/{DigiCurrency}', // Gets all external digital currency addresses related to the logged in user by currency.
                'Info/ReferenceCurrency', // Get user's reference currency
                'Info/ReferenceLanguage', // Get user's reference language
                'Notification/Messages', // Get from oldest unread + 3 read message to newest messages
                'Trade/Orders', // Gets open orders for the logged in trader.
                'Trade/Orders/{OrderID}', // Gets an order for the logged in trader.
                'Trade/StopOrders', // Gets all stop orders for the logged in trader. Max 1000 record.
                'Trade/StopOrdersHistory', // Gets all stop orders for the logged in trader. Max 1000 record.
                'Trade/Trades', // Gets all transactions of logged in user
                'Trade/UserTrades', // Gets all transactions of logged in user
            ],
            'post': [
                'Account/DocumentAddress', // Upload address proof document
                'Account/DocumentCorporation', // Upload registered document document
                'Account/DocumentID', // Upload ID document copy
                'Account/Email/RequestVerify', // Request for verification email
                'Account/Email/Verify', // Verification email
                'Account/GoogleAuth', // Enable google auth
                'Account/Level', // Request verif level of logged in user
                'Account/Questionnaire', // Fill the questionnaire
                'Account/Referral', // Post a referral email
                'APIKey/APIKey', // Create a new API key for logged in user
                'Auth/ChangePassword', // Change password.
                'Auth/ForgotPassword', // Request reset password
                'Auth/ForgotUserID', // Request user id
                'Auth/Login', // Trader session log in.
                'Auth/Logout', // Logout from the current session.
                'Auth/LogoutOtherSessions', // Logout other sessions.
                'Auth/ResetPassword', // Reset password
                'Bank/Transactions', // Request a transfer from the traders account of the logged in user. This is only available for bank account
                'Bank/UserAccounts', // Add an account the logged in user
                'ElectronicWallet/DepositWallets/{DigiCurrency}', // Add an digital currency addresses to the logged in user.
                'ElectronicWallet/Transactions/Deposits/{DigiCurrency}', // Get all internal digital currency transactions of the logged in user
                'ElectronicWallet/Transactions/Withdrawals/{DigiCurrency}', // Get all external digital currency transactions of the logged in user
                'ElectronicWallet/UserWallets/{DigiCurrency}', // Add an external digital currency addresses to the logged in user.
                'ElectronicWallet/Withdrawals/{DigiCurrency}', // Request a transfer from the traders account to an external address. This is only available for crypto currencies.
                'Notification/Messages', // Mark all as read
                'Notification/Messages/{ID}', // Mark as read
                'Trade/Orders', // Place an order at the exchange.
                'Trade/StopOrders', // Place a stop order at the exchange.
            ],
            'put': [
                'Account/CorporateData', // Update user company data for corporate account
                'Account/DocumentID', // Update ID document meta data
                'Account/DocumentInformation', // Update Step3 Data
                'Account/Email', // Update user email
                'Account/PersonalInformation', // Update Step1 Data
                'Account/Phone', // Update user phone number
                'Account/Questionnaire', // update the questionnaire
                'Account/ReferredCode', // Update referral code
                'Account/ResidentInformation', // Update Step2 Data
                'Account/SecuritySettings', // Update verif details of logged in user
                'Account/User', // Update all user info
                'Bank/UserAccounts', // Update the label of existing user bank accounnt
                'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Update the name of an address
                'ElectronicWallet/UserWallets/{DigiCurrency}', // Update the name of an external address
                'Info/ReferenceCurrency', // User's reference currency
                'Info/ReferenceLanguage', // Update user's reference language
            ],
            'delete': [
                'APIKey/APIKey/{PublicKey}', // Remove an API key
                'Bank/Transactions/{RequestID}', // Delete pending account withdraw of the logged in user
                'Bank/UserAccounts/{Currency}/{Label}', // Delete an account of the logged in user
                'ElectronicWallet/DepositWallets/{DigiCurrency}/{AddressName}', // Delete an digital currency addresses related to the logged in user.
                'ElectronicWallet/UserWallets/{DigiCurrency}/{AddressName}', // Delete an external digital currency addresses related to the logged in user.
                'Trade/Orders', // Cancels all existing order
                'Trade/Orders/{OrderID}', // Cancels an existing order
                'Trade/StopOrders', // Cancels all existing stop orders
                'Trade/StopOrders/{ID}', // Cancels an existing stop order
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicGetPublicLiveTickers ();
        let markets = response['tickers'];
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currencyPair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalanceBalances ();
        let balances = response['balances'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': balance['availableBalance'],
                'used': this.sum (
                    balance['pendingIncoming'],
                    balance['pendingOutgoing'],
                    balance['openOrder']),
                'total': balance['balance'],
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.publicGetPublicMarketDepthCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'volume');
    },

    parseTicker (ticker, market) {
        let timestamp = parseInt (ticker['createDateTime']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetPublicLiveTickers ();
        let tickers = response['tickers'];
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let id = ticker['currencyPair'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicLiveTickerCurrencyPair ({
            'CurrencyPair': market['id'],
        });
        let ticker = response['ticker'];
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let side = undefined;
        let order = undefined;
        if ('way' in trade) {
            side = (trade['way'] == 'bid') ? 'buy' : 'sell';
            let orderId = trade['way'] + 'OrderId';
            order = trade[orderId];
        }
        let timestamp = parseInt (trade['transactionTime']) * 1000;
        if (!market)
            market = this.markets_by_id[trade['currencyPair']];
        return {
            'info': trade,
            'id': trade['transactionId'].toString (),
            'order': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetPublicTransactionsCurrencyPair (this.extend ({
            'CurrencyPair': market['id'],
        }, params));
        return this.parseTrades (response['transactions'], market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            parseInt (ohlcv['createDateTime']) * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            undefined,
            ohlcv['volume'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'CurrencyPair': market['id'],
            'Timeframe': this.timeframes[timeframe],
        };
        if (limit)
            request['Count'] = limit;
        request = this.extend (request, params);
        let response = await this.publicGetPublicTickerHistoryCurrencyPairTimeframe (request);
        return this.parseOHLCVs (response['tickers'], market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'Code': this.marketId (symbol),
            'Way': (side == 'buy') ? 'Bid' : 'Ask',
            'Amount': amount,
        };
        if (type == 'limit')
            order['Price'] = price;
        if (this.twofa) {
            if ('ValidationCode' in params)
                order['ValidationCode'] = params['ValidationCode'];
            else
                throw new AuthenticationError (this.id + ' two-factor authentication requires a missing ValidationCode parameter');
        }
        let response = await this.privatePostTradeOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['clOrderId'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privateDeleteTradeOrdersOrderID ({ 'OrderID': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let contentType = (method == 'GET') ? '' : 'application/json';
            let auth = method + url + contentType + nonce.toString ();
            auth = auth.toLowerCase ();
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            headers = {
                'API_PUBLIC_KEY': this.apiKey,
                'API_REQUEST_SIGNATURE': signature,
                'API_REQUEST_DATE': nonce,
            };
            if (method != 'GET') {
                headers['Content-Type'] = contentType;
                body = this.json (this.extend ({ 'nonce': nonce }, params));
            }
        }
        let response = await this.fetch (url, method, headers, body);
        if ('responseStatus' in response)
            if ('message' in response['responseStatus'])
                if (response['responseStatus']['message'] == 'OK')
                    return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var gdax = {
    'id': 'gdax',
    'name': 'GDAX',
    'countries': 'US',
    'rateLimit': 1000,
    'hasCORS': true,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': 60,
        '5m': 300,
        '15m': 900,
        '30m': 1800,
        '1h': 3600,
        '2h': 7200,
        '4h': 14400,
        '12h': 43200,
        '1d': 86400,
        '1w': 604800,
        '1M': 2592000,
        '1y': 31536000,
    },
    'urls': {
        'test': 'https://api-public.sandbox.gdax.com',
        'logo': 'https://user-images.githubusercontent.com/1294454/27766527-b1be41c6-5edb-11e7-95f6-5b496c469e2c.jpg',
        'api': 'https://api.gdax.com',
        'www': 'https://www.gdax.com',
        'doc': 'https://docs.gdax.com',
    },
    'api': {
        'public': {
            'get': [
                'currencies',
                'products',
                'products/{id}/book',
                'products/{id}/candles',
                'products/{id}/stats',
                'products/{id}/ticker',
                'products/{id}/trades',
                'time',
            ],
        },
        'private': {
            'get': [
                'accounts',
                'accounts/{id}',
                'accounts/{id}/holds',
                'accounts/{id}/ledger',
                'coinbase-accounts',
                'fills',
                'funding',
                'orders',
                'orders/{id}',
                'payment-methods',
                'position',
                'reports/{id}',
                'users/self/trailing-volume',
            ],
            'post': [
                'deposits/coinbase-account',
                'deposits/payment-method',
                'funding/repay',
                'orders',
                'position/close',
                'profiles/margin-transfer',
                'reports',
                'withdrawals/coinbase',
                'withdrawals/crypto',
                'withdrawals/payment-method',
            ],
            'delete': [
                'orders',
                'orders/{id}',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quote_currency'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccounts ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['hold']),
                'total': parseFloat (balance['balance']),
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdBook (this.extend ({
            'id': this.marketId (market),
            'level': 2, // 1 best bidask, 2 aggregated, 3 full
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetProductsIdTicker ({
            'id': market['id'],
        });
        let quote = await this.publicGetProductsIdStats ({
            'id': market['id'],
        });
        let timestamp = this.parse8601 (ticker['time']);
        let bid = undefined;
        let ask = undefined;
        if ('bid' in ticker)
            bid = parseFloat (ticker['bid']);
        if ('ask' in ticker)
            ask = parseFloat (ticker['ask']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (quote['high']),
            'low': parseFloat (quote['low']),
            'bid': bid,
            'ask': ask,
            'vwap': undefined,
            'open': parseFloat (quote['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (quote['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (['time']);
        let type = undefined;
        return {
            'id': trade['trade_id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['size']),
        };
    },

    async fetchTrades (market, params = {}) {
        await this.loadMarkets ();
        return await this.publicGetProductsIdTrades (this.extend ({
            'id': this.marketId (market), // fixes issue #2
        }, params));
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            ohlcv[3],
            ohlcv[2],
            ohlcv[1],
            ohlcv[4],
            ohlcv[5],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let granularity = this.timeframes[timeframe];
        let request = {
            'id': market['id'],
            'granularity': granularity,
        };
        if (since) {
            request['start'] = this.iso8601 (since);
            if (!limit)
                limit = 200; // max = 200
            request['end'] = this.iso8601 (limit * granularity * 1000 + since);
        }
        let response = await this.publicGetProductsIdCandles (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async fetchTime () {
        let response = this.publicGetTime ();
        return this.parse8601 (response['iso']);
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let oid = this.nonce ().toString ();
        let order = {
            'product_id': this.marketId (market),
            'side': side,
            'size': amount,
            'type': type,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return await this.privateDeleteOrdersId ({ 'id': id });
    },

    async getPaymentMethods () {
        let response = await this.privateGetPaymentMethods ();
        return response;
    },

    async withdraw (currency, amount, address, params = {}) {
        if ('payment_method_id' in params) {
            await this.loadMarkets ();
            let response = await this.privatePostWithdraw (this.extend ({
                'currency': currency,
                'amount': amount,
                // 'address': address, // they don't allow withdrawals to direct addresses
            }, params));
            return {
                'info': response,
                'id': response['result'],
            };
        }
        throw new ExchangeError (this.id + " withdraw requires a 'payment_method_id' parameter");
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let request = '/' + this.implodeParams (path, params);
        let url = this.urls['api'] + request;
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            if (!this.apiKey)
                throw new AuthenticationError (this.id + ' requires apiKey property for authentication and trading');
            if (!this.secret)
                throw new AuthenticationError (this.id + ' requires secret property for authentication and trading');
            if (!this.password)
                throw new AuthenticationError (this.id + ' requires password property for authentication and trading');
            let nonce = this.nonce ().toString ();
            if (Object.keys (query).length)
                body = this.json (query);
            let what = nonce + method + request + (body || '');
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (this.encode (what), secret, 'sha256', 'base64');
            headers = {
                'CB-ACCESS-KEY': this.apiKey,
                'CB-ACCESS-SIGN': this.decode (signature),
                'CB-ACCESS-TIMESTAMP': nonce,
                'CB-ACCESS-PASSPHRASE': this.password,
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('message' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var gemini = {
    'id': 'gemini',
    'name': 'Gemini',
    'countries': 'US',
    'rateLimit': 1500, // 200 for private API
    'version': 'v1',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
        'api': 'https://api.gemini.com',
        'www': 'https://gemini.com',
        'doc': 'https://docs.gemini.com/rest-api',
    },
    'api': {
        'public': {
            'get': [
                'symbols',
                'pubticker/{symbol}',
                'book/{symbol}',
                'trades/{symbol}',
                'auction/{symbol}',
                'auction/{symbol}/history',
            ],
        },
        'private': {
            'post': [
                'order/new',
                'order/cancel',
                'order/cancel/session',
                'order/cancel/all',
                'order/status',
                'orders',
                'mytrades',
                'tradevolume',
                'balances',
                'deposit/{currency}/newAddress',
                'withdraw/{currency}',
                'heartbeat',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let id = markets[p];
            let market = id;
            let uppercase = market.toUpperCase ();
            let base = uppercase.slice (0, 3);
            let quote = uppercase.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPubtickerSymbol ({
            'symbol': market['id'],
        });
        let timestamp = ticker['volume']['timestamp'];
        let baseVolume = market['base'];
        let quoteVolume = market['quote'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume'][baseVolume]),
            'quoteVolume': parseFloat (ticker['volume'][quoteVolume]),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['timestampms'];
        return {
            'id': trade['tid'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['available']),
                'used': 0.0,
                'total': parseFloat (balance['amount']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let order = {
            'client_order_id': this.nonce (),
            'symbol': this.marketId (symbol),
            'amount': amount.toString (),
            'price': price.toString (),
            'side': side,
            'type': 'exchange limit', // gemini allows limit orders only
        };
        let response = await this.privatePostOrderNew (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'order_id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let request = this.extend ({
                'request': url,
                'nonce': nonce,
            }, query);
            let payload = this.json (request);
            payload = this.stringToBase64 (this.encode (payload));
            let signature = this.hmac (payload, this.encode (this.secret), 'sha384');
            headers = {
                'Content-Type': 'text/plain',
                'X-GEMINI-APIKEY': this.apiKey,
                'X-GEMINI-PAYLOAD': payload,
                'X-GEMINI-SIGNATURE': signature,
            };
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response)
            if (response['result'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var hitbtc = {

    'id': 'hitbtc',
    'name': 'HitBTC',
    'countries': 'HK', // Hong Kong
    'rateLimit': 1500,
    'version': '1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
        'api': 'http://api.hitbtc.com',
        'www': 'https://hitbtc.com',
        'doc': [
            'https://hitbtc.com/api',
            'http://hitbtc-com.github.io/hitbtc-api',
            'http://jsfiddle.net/bmknight/RqbYB',
        ],
    },
    'api': {
        'public': {
            'get': [
                '{symbol}/orderbook',
                '{symbol}/ticker',
                '{symbol}/trades',
                '{symbol}/trades/recent',
                'symbols',
                'ticker',
                'time,'
            ],
        },
        'trading': {
            'get': [
                'balance',
                'orders/active',
                'orders/recent',
                'order',
                'trades/by/order',
                'trades',
            ],
            'post': [
                'new_order',
                'cancel_order',
                'cancel_orders',
            ],
        },
        'payment': {
            'get': [
                'balance',
                'address/{currency}',
                'transactions',
                'transactions/{transaction}',
            ],
            'post': [
                'transfer_to_trading',
                'transfer_to_main',
                'address/{currency}',
                'payout',
            ],
        }
    },

    async fetchMarkets () {
        let markets = await this.publicGetSymbols ();
        let result = [];
        for (let p = 0; p < markets['symbols'].length; p++) {
            let market = markets['symbols'][p];
            let id = market['symbol'];
            let base = market['commodity'];
            let quote = market['currency'];
            let lot = parseFloat (market['lot']);
            let step = parseFloat (market['step']);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'step': step,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.tradingGetBalance ();
        let balances = response['balance'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency_code'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': parseFloat (balance['cash']),
                'used': parseFloat (balance['reserved']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetSymbolOrderbook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['timestamp'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume']),
            'quoteVolume': parseFloat (ticker['volume_quote']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker ();
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetSymbolTicker ({
            'symbol': market['id'],
        });
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        return {
            'info': trade,
            'id': trade[0],
            'timestamp': trade[3],
            'datetime': this.iso8601 (trade[3]),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade[4],
            'price': parseFloat (trade[1]),
            'amount': parseFloat (trade[2]),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetSymbolTrades (this.extend ({
            'symbol': market['id'],
            // 'from': 0,
            // 'till': 100,
            // 'by': 'ts', // or by trade_id
            // 'sort': 'desc', // or asc
            // 'start_index': 0,
            // 'max_results': 1000,
            // 'format_item': 'object',
            // 'format_price': 'number',
            // 'format_amount': 'number',
            // 'format_tid': 'string',
            // 'format_timestamp': 'millisecond',
            // 'format_wrap': false,
            'side': 'true',
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        // check if amount can be evenly divided into lots
        // they want integer quantity in lot units
        let quantity = parseFloat (amount) / market['lot'];
        let wholeLots = Math.round (quantity);
        let difference = quantity - wholeLots;
        if (Math.abs (difference) > market['step'])
            throw new ExchangeError (this.id + ' order amount should be evenly divisible by lot unit size of ' + market['lot'].toString ());
        let clientOrderId = this.milliseconds ();
        let order = {
            'clientOrderId': clientOrderId.toString (),
            'symbol': market['id'],
            'side': side,
            'quantity': wholeLots.toString (), // quantity in integer lot units
            'type': type,
        };
        if (type == 'limit')
            order['price'] = price.toFixed (10);
        let response = await this.tradingPostNewOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['ExecutionReport']['clientOrderId'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.tradingPostCancelOrder (this.extend ({
            'clientOrderId': id,
        }, params));
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.paymentPostPayout (this.extend ({
            'currency_code': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['transaction'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + 'api' + '/' + this.version + '/' + api + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            query = this.extend ({ 'nonce': nonce, 'apikey': this.apiKey }, query);
            if (method == 'POST')
                if (Object.keys (query).length)
                    body = this.urlencode (query);
            url += '?' + this.urlencode (query);
            let auth = url + (body || '');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'X-Signature': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512').toLowerCase (),
            };
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('code' in response) {
            if ('ExecutionReport' in response) {
                if (response['ExecutionReport']['orderRejectReason'] == 'orderExceedsLimit')
                    throw new InsufficientFunds (this.id + ' ' + this.json (response));
            }
            throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var hitbtc2 = extend (hitbtc, {

    'id': 'hitbtc2',
    'name': 'HitBTC v2',
    'countries': 'HK', // Hong Kong
    'rateLimit': 1500,
    'version': '2',
    'hasCORS': true,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
        'api': 'https://api.hitbtc.com',
        'www': 'https://hitbtc.com',
        'doc': [
            'https://api.hitbtc.com/api/2/explore',
            'https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md',
        ],
    },
    'api': {
        'public': {
            'get': [
                'symbol', // Available Currency Symbols
                'symbol/{symbol}', // Get symbol info
                'currency', // Available Currencies
                'currency/{currency}', // Get currency info
                'ticker', // Ticker list for all symbols
                'ticker/{symbol}', // Ticker for symbol
                'trades/{symbol}', // Trades
                'orderbook/{symbol}', // Orderbook
            ],
        },
        'private': {
            'get': [
                'order', // List your current open orders
                'order/{clientOrderId}', // Get a single order by clientOrderId
                'trading/balance', // Get trading balance
                'trading/fee/{symbol}', // Get trading fee rate
                'history/trades', // Get historical trades
                'history/order', // Get historical orders
                'history/order/{id}/trades', // Get historical trades by specified order
                'account/balance', // Get main acccount balance
                'account/transactions', // Get account transactions
                'account/transactions/{id}', // Get account transaction by id
                'account/crypto/address/{currency}', // Get deposit crypro address
            ],
            'post': [
                'order', // Create new order
                'account/crypto/withdraw', // Withdraw crypro
                'account/crypto/address/{currency}', // Create new deposit crypro address
                'account/transfer', // Transfer amount to trading
            ],
            'put': [
                'order/{clientOrderId}', // Create new order
                'account/crypto/withdraw/{id}', // Commit withdraw crypro
            ],
            'delete': [
                'order', // Cancel all open orders
                'order/{clientOrderId}', // Cancel order
                'account/crypto/withdraw/{id}', // Rollback withdraw crypro
            ],
            'patch': [
                'order/{clientOrderId}', // Cancel Replace order
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetSymbol ();
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let id = market['id'];
            let base = market['baseCurrency'];
            let quote = market['quoteCurrency'];
            let lot = market['quantityIncrement'];
            let step = market['tickSize'];
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'lot': lot,
                'step': step,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance () {
        await this.loadMarkets ();
        let balances = await this.privateGetTradingBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let code = balance['currency'];
            let currency = this.commonCurrencyCode (code);
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['reserved']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'bid', 'ask', 'price', 'size');
    },

    parseTicker (ticker, market) {
        let timestamp = this.parse8601 (ticker['timestamp']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': this.safeFloat (ticker, 'open'),
            'close': this.safeFloat (ticker, 'close'),
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': this.safeFloat (ticker, 'volume'),
            'quoteVolume': this.safeFloat (ticker, 'quoteVolume'),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker ();
        let result = {};
        for (let i = 0; i < tickers.length; i++) {
            let ticker = tickers[i];
            let id = ticker['symbol'];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTickerSymbol ({
            'symbol': market['id'],
        });
        if ('message' in ticker)
            throw new ExchangeError (this.id + ' ' + ticker['message']);
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['timestamp']);
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let clientOrderId = this.milliseconds ();
        amount = parseFloat (amount);
        let order = {
            'clientOrderId': clientOrderId.toString (),
            'symbol': market['id'],
            'side': side,
            'quantity': amount.toString (),
            'type': type,
        };
        if (type == 'limit') {
            price = parseFloat (price);
            order['price'] = price.toFixed (10);
        }
        let response = await this.privatePostOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['clientOrderId'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privateDeleteOrderClientOrderId (this.extend ({
            'clientOrderId': id,
        }, params));
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        amount = parseFloat (amount);
        let response = await this.privatePostAccountCryptoWithdraw (this.extend ({
            'currency': currency,
            'amount': amount.toString (),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/api' + '/' + this.version + '/';
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            url += api + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            url += this.implodeParams (path, params) + '?' + this.urlencode (query);
            if (method != 'GET')
                if (Object.keys (query).length)
                    body = this.json (query);
            let payload = this.encode (this.apiKey + ':' + this.secret);
            let auth = this.stringToBase64 (payload);
            headers = {
                'Authorization': "Basic " + this.decode (auth),
                'Content-Type': 'application/json',
            };
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
})

//-----------------------------------------------------------------------------

var huobi1 = {

    'id': 'huobi1',
    'name': 'Huobi v1',
    'countries': 'CN',
    'rateLimit': 2000,
    'version': 'v1',
    'hasFetchOHLCV': true,
    'accounts': undefined,
    'accountsById': undefined,
    'timeframes': {
        '1m': '1min',
        '5m': '5min',
        '15m': '15min',
        '30m': '30min',
        '1h': '60min',
        '1d': '1day',
        '1w': '1week',
        '1M': '1mon',
        '1y': '1year',
    },
    'api': {
        'market': {
            'get': [
                'history/kline', // 获取K线数据
                'detail/merged', // 获取聚合行情(Ticker)
                'depth', // 获取 Market Depth 数据
                'trade', // 获取 Trade Detail 数据
                'history/trade', // 批量获取最近的交易记录
                'detail', // 获取 Market Detail 24小时成交量数据
            ],
        },
        'public': {
            'get': [
                'common/symbols', // 查询系统支持的所有交易对
                'common/currencys', // 查询系统支持的所有币种
                'common/timestamp', // 查询系统当前时间
            ],
        },
        'private': {
            'get': [
                'account/accounts', // 查询当前用户的所有账户(即account-id)
                'account/accounts/{id}/balance', // 查询指定账户的余额
                'order/orders/{id}', // 查询某个订单详情
                'order/orders/{id}/matchresults', // 查询某个订单的成交明细
                'order/orders', // 查询当前委托、历史委托
                'order/matchresults', // 查询当前成交、历史成交
                'dw/withdraw-virtual/addresses', // 查询虚拟币提现地址
            ],
            'post': [
                'order/orders/place', // 创建并执行一个新订单 (一步下单， 推荐使用)
                'order/orders', // 创建一个新的订单请求 （仅创建订单，不执行下单）
                'order/orders/{id}/place', // 执行一个订单 （仅执行已创建的订单）
                'order/orders/{id}/submitcancel', // 申请撤销一个订单请求
                'order/orders/batchcancel', // 批量撤销订单
                'dw/balance/transfer', // 资产划转
                'dw/withdraw-virtual/create', // 申请提现虚拟币
                'dw/withdraw-virtual/{id}/place', // 确认申请虚拟币提现
                'dw/withdraw-virtual/{id}/cancel', // 申请取消提现虚拟币
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicGetCommonSymbols ();
        let markets = response['data'];
        let numMarkets = markets.length;
        if (numMarkets < 1)
            throw new ExchangeError (this.id + ' publicGetCommonSymbols returned empty response: ' + this.json (response));
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            let baseId = market['base-currency'];
            let quoteId = market['quote-currency'];
            let base = baseId.toUpperCase ();
            let quote = quoteId.toUpperCase ();
            let id = baseId + quoteId;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    parseTicker (ticker, market) {
        let last = undefined;
        if ('last' in ticker)
            last = ticker['last'];
        let timestamp = this.milliseconds ();
        if ('ts' in ticker)
            timestamp = ticker['ts'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['bid'][0],
            'ask': ticker['ask'][0],
            'vwap': undefined,
            'open': ticker['open'],
            'close': ticker['close'],
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['amount']),
            'quoteVolume': ticker['vol'],
            'info': ticker,
        };
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDepth (this.extend ({
            'symbol': market['id'],
            'type': 'step0',
        }, params));
        return this.parseOrderBook (response['tick'], response['tick']['ts']);
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetDetailMerged ({ 'symbol': market['id'] });
        return this.parseTicker (response['tick'], market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    parseTradesData (data, market) {
        let result = [];
        for (let i = 0; i < data.length; i++) {
            let trades = this.parseTrades (data[i]['data'], market);
            for (let k = 0; k < trades.length; k++) {
                result.push (trades[k]);
            }
        }
        return result;
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryTrade (this.extend ({
            'symbol': market['id'],
            'size': 2000,
        }, params));
        return this.parseTradesData (response['data'], market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['id'] * 1000,
            ohlcv['open'],
            ohlcv['high'],
            ohlcv['low'],
            ohlcv['close'],
            ohlcv['vol'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.marketGetHistoryKline (this.extend ({
            'symbol': market['id'],
            'period': this.timeframes[timeframe],
            'size': 2000, // max = 2000
        }, params));
        return this.parseOHLCVs (response['data'], market, timeframe, since, limit);
    },

    async loadAccounts (reload = false) {
        if (reload) {
            this.accounts = await this.fetchAccounts ();
        } else {
            if (this.accounts) {
                return this.accounts;
            } else {
                this.accounts = await this.fetchAccounts ();
                this.accountsById = this.indexBy (this.accounts, 'id');
            }
        }
        return this.accounts;
    },

    async fetchAccounts () {
        await this.loadMarkets ();
        let response = await this.privateGetAccountAccounts ();
        return response['data'];
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let response = await this.privateGetAccountAccountsIdBalance (this.extend ({
            'id': this.accounts[0]['id'],
        }, params));
        let balances = response['data']['list'];
        let result = { 'info': response };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let uppercase = balance['currency'].toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = this.account ();
            account['free'] = parseFloat (balance['balance']);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        await this.loadAccounts ();
        let market = this.market (symbol);
        let order = {
            'account-id': this.accounts[0]['id'],
            'amount': amount.toFixed (10),
            'symbol': market['id'],
            'type': side + '-' + type,
        };
        if (type == 'limit')
            order['price'] = price.toFixed (10);
        let response = await this.privatePostOrderOrdersPlace (this.extend (order, params));
        return {
            'info': response,
            'id': response['data'],
        };
    },

    async cancelOrder (id) {
        return this.privatePostOrderOrdersIdSubmitcancel ({ 'id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/';
        if (api == 'market')
            url += api;
        else
            url += this.version;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            let timestamp = this.YmdHMS (this.milliseconds (), 'T');
            let request = this.keysort (this.extend ({
                'SignatureMethod': 'HmacSHA256',
                'SignatureVersion': '2',
                'AccessKeyId': this.apiKey,
                'Timestamp': timestamp,
            }, query));
            let auth = this.urlencode (request);
            let payload = [ method, this.hostname, url, auth ].join ("\n");
            let signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
            auth += '&' + this.urlencode ({ 'Signature': signature });
            if (method == 'GET') {
                url += '?' + auth;
            } else {
                body = this.json (query);
                headers = {
                    'Content-Type': 'application/json',
                };
            }
        } else {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var huobicny = extend (huobi1, {

    'id': 'huobicny',
    'name': 'Huobi CNY',
    'hostname': 'be.huobi.com',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
        'api': 'https://be.huobi.com',
        'www': 'https://www.huobi.com',
        'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
    },
    // 'markets': {
    //     'ETH/CNY': { 'id': 'ethcny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY' },
    //     'ETC/CNY': { 'id': 'etccny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY' },
    //     'BCH/CNY': { 'id': 'bcccny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY' },
    // },
})

//-----------------------------------------------------------------------------

var huobipro = extend (huobi1, {

    'id': 'huobipro',
    'name': 'Huobi Pro',
    'hostname': 'api.huobi.pro',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
        'api': 'https://api.huobi.pro',
        'www': 'https://www.huobi.pro',
        'doc': 'https://github.com/huobiapi/API_Docs/wiki/REST_api_reference',
    },
    // 'markets': {
    //     'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
    //     'ETC/BTC': { 'id': 'etccny', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC' },
    //     'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC' },
    //     'BCH/BTC': { 'id': 'bcccny', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
    // },
})

//-----------------------------------------------------------------------------

var huobi = {

    'id': 'huobi',
    'name': 'Huobi',
    'countries': 'CN',
    'rateLimit': 2000,
    'version': 'v3',
    'hasCORS': false,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '001',
        '5m': '005',
        '15m': '015',
        '30m': '030',
        '1h': '060',
        '1d': '100',
        '1w': '200',
        '1M': '300',
        '1y': '400',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766569-15aa7b9a-5edd-11e7-9e7f-44791f4ee49c.jpg',
        'api': 'http://api.huobi.com',
        'www': 'https://www.huobi.com',
        'doc': 'https://github.com/huobiapi/API_Docs_en/wiki',
    },
    'api': {
        'staticmarket': {
            'get': [
                '{id}_kline_{period}',
                'ticker_{id}',
                'depth_{id}',
                'depth_{id}_{length}',
                'detail_{id}',
            ],
        },
        'usdmarket': {
            'get': [
                '{id}_kline_{period}',
                'ticker_{id}',
                'depth_{id}',
                'depth_{id}_{length}',
                'detail_{id}',
            ],
        },
        'trade': {
            'post': [
                'get_account_info',
                'get_orders',
                'order_info',
                'buy',
                'sell',
                'buy_market',
                'sell_market',
                'cancel_order',
                'get_new_deal_orders',
                'get_order_id_by_trade_id',
                'withdraw_coin',
                'cancel_withdraw_coin',
                'get_withdraw_coin_result',
                'transfer',
                'loan',
                'repayment',
                'get_loan_available',
                'get_loans',
            ],
        },
    },
    'markets': {
        'BTC/CNY': { 'id': 'btc', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 1 },
        'LTC/CNY': { 'id': 'ltc', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'staticmarket', 'coinType': 2 },
        // 'BTC/USD': { 'id': 'btc', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'type': 'usdmarket',    'coinType': 1 },
    },

    async fetchBalance (params = {}) {
        let balances = await this.tradePostGetAccountInfo ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let available = 'available_' + lowercase + '_display';
            let frozen = 'frozen_' + lowercase + '_display';
            let loan = 'loan_' + lowercase + '_display';
            if (available in balances)
                account['free'] = parseFloat (balances[available]);
            if (frozen in balances)
                account['used'] = parseFloat (balances[frozen]);
            if (loan in balances)
                account['used'] = this.sum (account['used'], parseFloat (balances[loan]));
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDepthId';
        let orderbook = await this[method] (this.extend ({ 'id': market['id'] }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetTickerId';
        let response = await this[method] ({ 'id': market['id'] });
        let ticker = response['ticker'];
        let timestamp = parseInt (response['time']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['ts'];
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['direction'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetDetailId';
        let response = await this[method] (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        // not implemented yet
        return [
            ohlcv[0],
            ohlcv[1],
            ohlcv[2],
            ohlcv[3],
            ohlcv[4],
            ohlcv[6],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        let market = this.market (symbol);
        let method = market['type'] + 'GetIdKlinePeriod';
        let ohlcvs = await this[method] (this.extend ({
            'id': market['id'],
            'period': this.timeframes[timeframe],
        }, params));
        return ohlcvs;
        // return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let method = 'tradePost' + this.capitalize (side);
        let order = {
            'coin_type': market['coinType'],
            'amount': amount,
            'market': market['quote'].toLowerCase (),
        };
        if (type == 'limit')
            order['price'] = price;
        else
            method += this.capitalize (type);
        let response = this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id) {
        return this.tradePostCancelOrder ({ 'id': id });
    },

    async request (path, api = 'trade', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'];
        if (api == 'trade') {
            url += '/api' + this.version;
            let query = this.keysort (this.extend ({
                'method': path,
                'access_key': this.apiKey,
                'created': this.nonce (),
            }, params));
            let queryString = this.urlencode (this.omit (query, 'market'));
            // secret key must be appended to the query before signing
            queryString += '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        } else {
            url += '/' + api + '/' + this.implodeParams (path, params) + '_json.js';
            let query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] == 'error')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var independentreserve = {

    'id': 'independentreserve',
    'name': 'Independent Reserve',
    'countries': [ 'AU', 'NZ' ], // Australia, New Zealand
    'rateLimit': 1000,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30521662-cf3f477c-9bcb-11e7-89bc-d1ac85012eda.jpg',
        'api': {
            'public': 'https://api.independentreserve.com/Public',
            'private': 'https://api.independentreserve.com/Private',
        },
        'www': 'https://www.independentreserve.com',
        'doc': 'https://www.independentreserve.com/API',
    },
    'api': {
        'public': {
            'get': [
                'GetValidPrimaryCurrencyCodes',
                'GetValidSecondaryCurrencyCodes',
                'GetValidLimitOrderTypes',
                'GetValidMarketOrderTypes',
                'GetValidOrderTypes',
                'GetValidTransactionTypes',
                'GetMarketSummary',
                'GetOrderBook',
                'GetTradeHistorySummary',
                'GetRecentTrades',
                'GetFxRates',
            ],
        },
        'private': {
            'post': [
                'PlaceLimitOrder',
                'PlaceMarketOrder',
                'CancelOrder',
                'GetOpenOrders',
                'GetClosedOrders',
                'GetClosedFilledOrders',
                'GetOrderDetails',
                'GetAccounts',
                'GetTransactions',
                'GetDigitalCurrencyDepositAddress',
                'GetDigitalCurrencyDepositAddresses',
                'SynchDigitalCurrencyDepositAddressWithBlockchain',
                'WithdrawDigitalCurrency',
                'RequestFiatWithdrawal',
                'GetTrades',
            ],
        },
    },

    async fetchMarkets () {
        let baseCurrencies = await this.publicGetValidPrimaryCurrencyCodes ();
        let quoteCurrencies = await this.publicGetValidSecondaryCurrencyCodes ();
        let result = [];
        for (let i = 0; i < baseCurrencies.length; i++) {
            let baseId = baseCurrencies[i];
            let baseIdUppercase = baseId.toUpperCase ();
            let base = this.commonCurrencyCode (baseIdUppercase);
            for (let j = 0; j < quoteCurrencies.length; j++) {
                let quoteId = quoteCurrencies[j];
                let quoteIdUppercase = quoteId.toUpperCase ();
                let quote = this.commonCurrencyCode (quoteIdUppercase);
                let id = baseId + '/' + quoteId;
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': id,
                });
            }
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostGetAccounts ();
        let result = { 'info': balances };
        for (let i = 0; i < balances.length; i++) {
            let balance = balances[i];
            let currencyCode = balance['CurrencyCode'];
            let uppercase = currencyCode.toUpperCase ();
            let currency = this.commonCurrencyCode (uppercase);
            let account = this.account ();
            account['free'] = balance['AvailableBalance'];
            account['total'] = balance['TotalBalance'];
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrderBook (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        }, params));
        let timestamp = this.parse8601 (response['CreatedTimestampUtc']);
        return this.parseOrderBook (response, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume');
    },

    parseTicker (ticker, market) {
        let timestamp = this.parse8601 (ticker['CreatedTimestampUtc']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DayHighestPrice'],
            'low': ticker['DayLowestPrice'],
            'bid': ticker['CurrentHighestBidPrice'],
            'ask': ticker['CurrentLowestOfferPrice'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['LastPrice'],
            'change': undefined,
            'percentage': undefined,
            'average': ticker['DayAvgPrice'],
            'baseVolume': ticker['DayVolumeXbt'],
            'quoteVolume': ticker['DayVolumeXbtInSecondaryCurrrency'],
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketSummary ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
        });
        return this.parseTicker (response, market);
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['TradeTimestampUtc']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['SecondaryCurrencyTradePrice'],
            'amount': trade['PrimaryCurrencyAmount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetRecentTrades (this.extend ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'numberOfRecentTradesToRetrieve': 50, // max = 50
        }, params));
        return this.parseTrades (response['Trades'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let capitalizedOrderType = this.capitalize (type);
        let method = 'Place' + capitalizedOrderType + 'Order';
        let orderType = capitalizedOrderType;
        orderType += (side == 'sell') ?  'Offer' : 'Bid';
        let order = this.ordered ({
            'primaryCurrencyCode': market['baseId'],
            'secondaryCurrencyCode': market['quoteId'],
            'orderType': orderType,
        });
        if (type == 'limit')
            order['price'] = price;
        order['volume'] = amount;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['OrderGuid'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'orderGuid': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            let auth = [
                url,
                'apiKey=' + this.apiKey,
                'nonce=' + nonce.toString (),
            ];
            let keysorted = this.keysort (params);
            let keys = Object.keys (params);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                auth.push (key + '=' + params[key]);
            }
            let message = auth.join (',');
            let signature = this.hmac (this.encode (message), this.encode (this.secret));
            let query = this.keysort (this.extend ({
                'apiKey': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params));
            body = this.json (query);
            headers = { 'Content-Type': 'application/json' };
        }
        let response = await this.fetch (url, method, headers, body);
        // todo error handling
        return response;
    },
}

//-----------------------------------------------------------------------------

var itbit = {

    'id': 'itbit',
    'name': 'itBit',
    'countries': 'US',
    'rateLimit': 2000,
    'version': 'v1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
        'api': 'https://api.itbit.com',
        'www': 'https://www.itbit.com',
        'doc': [
            'https://api.itbit.com/docs',
            'https://www.itbit.com/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                'markets/{symbol}/ticker',
                'markets/{symbol}/order_book',
                'markets/{symbol}/trades',
            ],
        },
        'private': {
            'get': [
                'wallets',
                'wallets/{walletId}',
                'wallets/{walletId}/balances/{currencyCode}',
                'wallets/{walletId}/funding_history',
                'wallets/{walletId}/trades',
                'wallets/{walletId}/orders/{id}',
            ],
            'post': [
                'wallet_transfers',
                'wallets',
                'wallets/{walletId}/cryptocurrency_deposits',
                'wallets/{walletId}/cryptocurrency_withdrawals',
                'wallets/{walletId}/orders',
                'wire_withdrawal',
            ],
            'delete': [
                'wallets/{walletId}/orders/{id}',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'XBTUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'BTC/SGD': { 'id': 'XBTSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD' },
        'BTC/EUR': { 'id': 'XBTEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetMarketsSymbolOrderBook (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetMarketsSymbolTicker ({
            'symbol': this.marketId (symbol),
        });
        let serverTimeUTC = ('serverTimeUTC' in ticker);
        if (!serverTimeUTC)
            throw new ExchangeError (this.id + ' fetchTicker returned a bad response: ' + this.json (ticker));
        let timestamp = this.parse8601 (ticker['serverTimeUTC']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': parseFloat (ticker['vwap24h']),
            'open': parseFloat (ticker['openToday']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['lastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume24h']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['timestamp']);
        let id = trade['matchNumber'].toString ();
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': id,
            'order': id,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetMarketsSymbolTrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response['recentTrades'], market);
    },

    async fetchBalance (params = {}) {
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = {
                'free': parseFloat (balance['availableBalance']),
                'used': 0.0,
                'total': parseFloat (balance['totalBalance']),
            };
            account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    fetchWallets () {
        return this.privateGetWallets ();
    },

    nonce () {
        return this.milliseconds ();
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' createOrder requires a walletId parameter');
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'side': side,
            'type': type,
            'currency': market['base'],
            'amount': amount,
            'display': amount,
            'price': price,
            'instrument': market['id'],
        };
        let response = await this.privatePostTradeAdd (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    cancelOrder (id, params = {}) {
        let walletIdInParams = ('walletId' in params);
        if (!walletIdInParams)
            throw new ExchangeError (this.id + ' cancelOrder requires a walletId parameter');
        return this.privateDeleteWalletsWalletIdOrdersId (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            if (Object.keys (query).length)
                body = this.json (query);
            else
                body = '';
            let nonce = this.nonce ().toString ();
            let timestamp = nonce;
            let auth = [ method, url, body, nonce, timestamp ];
            let message = nonce + this.json (auth);
            let hash = this.hash (this.encode (message), 'sha256', 'binary');
            let binhash = this.binaryConcat (url, hash);
            let signature = this.hmac (binhash, this.encode (this.secret), 'sha512', 'base64');
            headers = {
                'Authorization': self.apiKey + ':' + signature,
                'Content-Type': 'application/json',
                'X-Auth-Timestamp': timestamp,
                'X-Auth-Nonce': nonce,
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('code' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var jubi = {

    'id': 'jubi',
    'name': 'jubi.com',
    'countries': 'CN',
    'rateLimit': 1500,
    'version': 'v1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766581-9d397d9a-5edd-11e7-8fb9-5d8236c0e692.jpg',
        'api': 'https://www.jubi.com/api',
        'www': 'https://www.jubi.com',
        'doc': 'https://www.jubi.com/help/api.html',
    },
    'api': {
        'public': {
            'get': [
                'depth',
                'orders',
                'ticker',
                'allticker',
            ],
        },
        'private': {
            'post': [
                'balance',
                'trade_add',
                'trade_cancel',
                'trade_list',
                'trade_view',
                'wallet',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetAllticker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let base = id.toUpperCase ();
            let quote = 'CNY';
            let symbol = base + '/' + quote;
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': id,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            if (lowercase == 'dash')
                lowercase = 'drk';
            let account = this.account ();
            let free = lowercase + '_balance';
            let used = lowercase + '_lock';
            if (free in balances)
                account['free'] = parseFloat (balances[free]);
            if (used in balances)
                account['used'] = parseFloat (balances[used]);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetDepth (this.extend ({
            'coin': this.marketId (symbol),
        }, params));
        let result = this.parseOrderBook (orderbook);
        result['asks'] = this.sortBy (result['asks'], 0);
        return result;
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['vol']),
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetAllticker ();
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTicker ({
            'coin': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'id': trade['tid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetOrders (this.extend ({
            'coin': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostTradeAdd (this.extend ({
            'amount': amount,
            'price': price,
            'type': side,
            'coin': this.marketId (symbol),
        }, params));
        return {
            'info': response,
            'id': response['id'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostTradeCancel (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ().toString ();
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, params);
            let request = this.urlencode (query);
            let secret = this.hash (this.encode (this.secret));
            query['signature'] = this.hmac (this.encode (request), this.encode (secret));
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------
// kraken is also owner of ex. Coinsetter / CaVirtEx / Clevercoin

var kraken = {

    'id': 'kraken',
    'name': 'Kraken',
    'countries': 'US',
    'version': '0',
    'rateLimit': 1500,
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'marketsByAltname': {},
    'timeframes': {
        '1m': '1',
        '5m': '5',
        '15m': '15',
        '30m': '30',
        '1h': '60',
        '4h': '240',
        '1d': '1440',
        '1w': '10080',
        '2w': '21600',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766599-22709304-5ede-11e7-9de1-9f33732e1509.jpg',
        'api': 'https://api.kraken.com',
        'www': 'https://www.kraken.com',
        'doc': [
            'https://www.kraken.com/en-us/help/api',
            'https://github.com/nothingisdead/npm-kraken-api',
        ],
        'fees': 'https://www.kraken.com/en-us/help/fees',
    },
    'api': {
        'public': {
            'get': [
                'Assets',
                'AssetPairs',
                'Depth',
                'OHLC',
                'Spread',
                'Ticker',
                'Time',
                'Trades',
            ],
        },
        'private': {
            'post': [
                'AddOrder',
                'Balance',
                'CancelOrder',
                'ClosedOrders',
                'DepositAddresses',
                'DepositMethods',
                'DepositStatus',
                'Ledgers',
                'OpenOrders',
                'OpenPositions',
                'QueryLedgers',
                'QueryOrders',
                'QueryTrades',
                'TradeBalance',
                'TradesHistory',
                'TradeVolume',
                'Withdraw',
                'WithdrawCancel',
                'WithdrawInfo',
                'WithdrawStatus',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetAssetPairs ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets['result'][id];
            let base = market['base'];
            let quote = market['quote'];
            if ((base[0] == 'X') || (base[0] == 'Z'))
                base = base.slice (1);
            if ((quote[0] == 'X') || (quote[0] == 'Z'))
                quote = quote.slice (1);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let darkpool = id.indexOf ('.d') >= 0;
            let symbol = darkpool ? market['altname'] : (base + '/' + quote);
            let maker = undefined;
            if ('fees_maker' in market)
                maker = market['fees_maker'][0][1];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'darkpool': darkpool,
                'info': market,
                'altname': market['altname'],
                'maker': maker,
                'taker': market['fees'][0][1],
            });
        }
        this.marketsByAltname = this.indexBy (result, 'altname');
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide an order book for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetDepth (this.extend ({
            'pair': market['id'],
        }, params));
        let orderbook = response['result'][market['id']];
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['h'][1]),
            'low': parseFloat (ticker['l'][1]),
            'bid': parseFloat (ticker['b'][0]),
            'ask': parseFloat (ticker['a'][0]),
            'vwap': parseFloat (ticker['p'][1]),
            'open': parseFloat (ticker['o']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['c'][0]),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['v'][1]),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let pairs = [];
        for (let s = 0; s < this.symbols.length; s++) {
            let symbol = this.symbols[s];
            let market = this.markets[symbol];
            if (!market['darkpool'])
                pairs.push (market['id']);
        }
        let filter = pairs.join (',');
        let response = await this.publicGetTicker ({
            'pair': filter,
        });
        let tickers = response['result'];
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let darkpool = symbol.indexOf ('.d') >= 0;
        if (darkpool)
            throw new ExchangeError (this.id + ' does not provide a ticker for darkpool symbol ' + symbol);
        let market = this.market (symbol);
        let response = await this.publicGetTicker ({
            'pair': market['id'],
        });
        let ticker = response['result'][market['id']];
        return this.parseTicker (ticker, market);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv[0] * 1000,
            parseFloat (ohlcv[1]),
            parseFloat (ohlcv[2]),
            parseFloat (ohlcv[3]),
            parseFloat (ohlcv[4]),
            parseFloat (ohlcv[6]),
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
            'interval': this.timeframes[timeframe],
        };
        if (since)
            request['since'] = parseInt (since / 1000);
        let response = await this.publicGetOHLC (this.extend (request, params));
        let ohlcvs = response['result'][market['id']];
        return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade[2] * 1000);
        let side = (trade[3] == 's') ? 'sell' : 'buy';
        let type = (trade[4] == 'l') ? 'limit' : 'market';
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': type,
            'side': side,
            'price': parseFloat (trade[0]),
            'amount': parseFloat (trade[1]),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let id = market['id'];
        let response = await this.publicGetTrades (this.extend ({
            'pair': id,
        }, params));
        let trades = response['result'][id];
        return this.parseTrades (trades, market);
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostBalance ();
        let balances = response['result'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let code = currency;
            // X-ISO4217-A3 standard currency codes
            if (code[0] == 'X') {
                code = code.slice (1);
            } else if (code[0] == 'Z') {
                code = code.slice (1);
            }
            code = this.commonCurrencyCode (code);
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[code] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'ordertype': type,
            'volume': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostAddOrder (this.extend (order, params));
        let length = response['result']['txid'].length;
        let id = (length > 1) ? response['result']['txid'] : response['result']['txid'][0];
        return {
            'info': response,
            'id': id,
        };
    },

    parseOrder (order, market = undefined) {
        let description = order['descr'];
        let side = description['type'];
        let type = description['ordertype'];
        let symbol = undefined;
        if (!market) {
            let pair = description['pair'];
            if (pair in this.marketsByAltname) {
                market = this.marketsByAltname[pair];
            } else if (pair in this.markets_by_id) {
                market = this.markets_by_id[pair];
            }
        }
        if (market)
            symbol = market['symbol'];
        let timestamp = parseInt (order['opentm'] * 1000);
        let amount = parseFloat (order['vol']);
        let filled = parseFloat (order['vol_exec']);
        let remaining = amount - filled;
        return {
            'id': order['id'],
            'info': order,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': order['status'],
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': parseFloat (order['price']),
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            // 'trades': this.parseTrades (order['trades'], market),
        };
    },

    parseOrders (orders, market = undefined) {
        let result = [];
        let ids = Object.keys (orders);
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = this.extend ({ 'id': id }, orders[id]);
            result.push (this.parseOrder (order, market));
        }
        return result;
    },

    async fetchOrder (id, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostQueryOrders (this.extend ({
            'trades': true, // whether or not to include trades in output (optional, default false)
            'txid': id, // comma delimited list of transaction ids to query info about (20 maximum)
            // 'userref': 'optional', // restrict results to given user reference id (optional)
        }, params));
        let orders = response['result'];
        let order = this.parseOrder (orders[id]);
        return this.extend ({ 'info': response }, order);
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'txid': id });
    },

    async withdraw (currency, amount, address, params = {}) {
        if ('key' in params) {
            await this.loadMarkets ();
            let response = await this.privatePostWithdraw (this.extend ({
                'asset': currency,
                'amount': amount,
                // 'address': address, // they don't allow withdrawals to direct addresses
            }, params));
            return {
                'info': response,
                'id': response['result'],
            };
        }
        throw new ExchangeError (this.id + " withdraw requires a 'key' parameter (withdrawal key name, as set up on your account)");
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.marketId (symbol);
        let response = await this.privatePostOpenOrders (params);
        return this.parseOrders (response['result']['open'], market);
    },

    async fetchClosedOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.marketId (symbol);
        let response = await this.privatePostClosedOrders (params);
        return this.parseOrders (response['result']['closed'], market);
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.version + '/' + api + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ().toString ();
            body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
            let auth = this.encode (nonce + body);
            let hash = this.hash (auth, 'sha256', 'binary');
            let binary = this.stringToBinary (this.encode (url));
            let binhash = this.binaryConcat (binary, hash);
            let secret = this.base64ToBinary (this.secret);
            let signature = this.hmac (binhash, secret, 'sha512', 'base64');
            headers = {
                'API-Key': this.apiKey,
                'API-Sign': this.decode (signature),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response) {
            let numErrors = response['error'].length;
            if (numErrors)
                throw new ExchangeError (this.id + ' ' + this.json (response));
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var lakebtc = {

    'id': 'lakebtc',
    'name': 'LakeBTC',
    'countries': 'US',
    'version': 'api_v2',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28074120-72b7c38a-6660-11e7-92d9-d9027502281d.jpg',
        'api': 'https://api.lakebtc.com',
        'www': 'https://www.lakebtc.com',
        'doc': [
            'https://www.lakebtc.com/s/api_v2',
            'https://www.lakebtc.com/s/api',
        ],
    },
    'api': {
        'public': {
            'get': [
                'bcorderbook',
                'bctrades',
                'ticker',
            ],
        },
        'private': {
            'post': [
                'buyOrder',
                'cancelOrders',
                'getAccountInfo',
                'getExternalAccounts',
                'getOrders',
                'getTrades',
                'openOrders',
                'sellOrder',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetTicker ();
        let result = [];
        let keys = Object.keys (markets);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let market = markets[id];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['balance'];
        let result = { 'info': response };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = parseFloat (balances[currency]);
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBcorderbook (this.extend ({
            'symbol': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTicker ({
            'symbol': market['id'],
        });
        let ticker = tickers[market['id']];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'volume'),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetBctrades (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePost' + this.capitalize (side) + 'Order';
        let marketId = this.marketId (market);
        let order = {
            'params': [ price, amount, marketId ],
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'params': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public') {
            url += '/' + path;
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            if (Object.keys (params).length)
                params = params.join (',');
            else
                params = '';
            let query = this.urlencode ({
                'tonce': nonce,
                'accesskey': this.apiKey,
                'requestmethod': method.toLowerCase (),
                'id': nonce,
                'method': path,
                'params': params,
            });
            body = this.json ({
                'method': path,
                'params': params,
                'id': nonce,
            });
            let signature = this.hmac (this.encode (query), this.secret, 'sha1', 'base64');
            headers = {
                'Json-Rpc-Tonce': nonce,
                'Authorization': "Basic " + this.apiKey + ':' + signature,
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var livecoin = {

    'id': 'livecoin',
    'name': 'LiveCoin',
    'countries': [ 'US', 'UK', 'RU' ],
    'rateLimit': 1000,
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27980768-f22fc424-638a-11e7-89c9-6010a54ff9be.jpg',
        'api': 'https://api.livecoin.net',
        'www': 'https://www.livecoin.net',
        'doc': 'https://www.livecoin.net/api?lang=en',
    },
    'api': {
        'public': {
            'get': [
                'exchange/all/order_book',
                'exchange/last_trades',
                'exchange/maxbid_minask',
                'exchange/order_book',
                'exchange/restrictions',
                'exchange/ticker', // omit params to get all tickers at once
                'info/coinInfo',
            ],
        },
        'private': {
            'get': [
                'exchange/client_orders',
                'exchange/order',
                'exchange/trades',
                'exchange/commission',
                'exchange/commissionCommonInfo',
                'payment/balances',
                'payment/balance',
                'payment/get/address',
                'payment/history/size',
                'payment/history/transactions',
            ],
            'post': [
                'exchange/buylimit',
                'exchange/buymarket',
                'exchange/cancellimit',
                'exchange/selllimit',
                'exchange/sellmarket',
                'payment/out/capitalist',
                'payment/out/card',
                'payment/out/coin',
                'payment/out/okpay',
                'payment/out/payeer',
                'payment/out/perfectmoney',
                'payment/voucher/amount',
                'payment/voucher/make',
                'payment/voucher/redeem',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetExchangeTicker ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['symbol'];
            let symbol = id;
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetPaymentBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < this.currencies.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let account = undefined;
            if (currency in result)
                account = result[currency];
            else
                account = this.account ();
            if (balance['type'] == 'total')
                account['total'] = parseFloat (balance['value']);
            if (balance['type'] == 'available')
                account['free'] = parseFloat (balance['value']);
            if (balance['type'] == 'trade')
                account['used'] = parseFloat (balance['value']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetExchangeOrderBook (this.extend ({
            'currencyPair': this.marketId (symbol),
            'groupByPrice': 'false',
            'depth': 100,
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp);
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['best_bid']),
            'ask': parseFloat (ticker['best_ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetExchangeTicker ();
        let tickers = this.indexBy (response, 'symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetExchangeTicker ({
            'currencyPair': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['time'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['id'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'].toLowerCase (),
            'price': trade['price'],
            'amount': trade['quantity'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExchangeLastTrades (this.extend ({
            'currencyPair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePostExchange' + this.capitalize (side) + type;
        let order = {
            'currencyPair': this.marketId (symbol),
            'quantity': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostExchangeCancellimit (this.extend ({
            'orderId': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let query = this.urlencode (this.keysort (params));
            if (method == 'GET')
                if (query)
                    url += '?' + query;
            else
                if (query)
                    body = query;
            let signature = this.hmac (this.encode (query), this.encode (this.secret), 'sha256');
            headers = {
                'Api-Key': this.apiKey,
                'Sign': signature.toUpperCase (),
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var liqui = {
    'id': 'liqui',
    'name': 'Liqui',
    'countries': 'UA',
    'rateLimit': 2000,
    'version': '3',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27982022-75aea828-63a0-11e7-9511-ca584a8edd74.jpg',
        'api': {
            'public': 'https://api.liqui.io/api',
            'private': 'https://api.liqui.io/tapi',
        },
        'www': 'https://liqui.io',
        'doc': 'https://liqui.io/api',
        'fees': 'https://liqui.io/fee',
    },
    'api': {
        'public': {
            'get': [
                'info',
                'ticker/{pair}',
                'depth/{pair}',
                'trades/{pair}',
            ],
        },
        'private': {
            'post': [
                'getInfo',
                'Trade',
                'ActiveOrders',
                'OrderInfo',
                'CancelOrder',
                'TradeHistory',
                'TransHistory',
                'CoinDepositAddress',
                'WithdrawCoin',
                'CreateCoupon',
                'RedeemCoupon',
            ],
        },
    },
    'fees': {
        'trading': {
            'maker': 0.001,
            'taker': 0.0025,
        },
        'funding': 0.0,
    },

    calculateFeeRate (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let key = (side == 'sell') ? 'quote' : 'base';
        let market = this.markets[symbol];
        return { 'currency': market[key], 'rate': market[takerOrMaker] };
    },

    async fetchMarkets () {
        let response = await this.publicGetInfo ();
        let markets = response['pairs'];
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ base, quote ] = id.split ('_');
            base = base.toUpperCase ();
            quote = quote.toUpperCase ();
            if (base == 'DSH')
                base = 'DASH';
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'taker': market['fee'],
                'info': market,
            }));
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let funds = balances['funds'];
        let currencies = Object.keys (funds);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let uppercase = currency.toUpperCase ();
            // they misspell DASH as dsh :/
            if (uppercase == 'DSH')
                uppercase = 'DASH';
            let account = {
                'free': funds[currency],
                'used': 0.0,
                'total': funds[currency],
            };
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetDepthPair (this.extend ({
            'pair': market['id'],
        }, params));
        if (market['id'] in response) {
            let orderbook = response[market['id']];
            let result = this.parseOrderBook (orderbook);
            result['bids'] = this.sortBy (result['bids'], 0, true);
            result['asks'] = this.sortBy (result['asks'], 0);
            return result;
        }
        throw new ExchangeError (this.id + ' ' + market['symbol'] + ' order book is empty or not available');
    },

    parseTicker (ticker, market = undefined) {
        let timestamp = ticker['updated'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': this.safeFloat (ticker, 'high'),
            'low': this.safeFloat (ticker, 'low'),
            'bid': this.safeFloat (ticker, 'buy'),
            'ask': this.safeFloat (ticker, 'sell'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'last'),
            'change': undefined,
            'percentage': undefined,
            'average': this.safeFloat (ticker, 'avg'),
            'baseVolume': this.safeFloat (ticker, 'vol_cur'),
            'quoteVolume': this.safeFloat (ticker, 'vol'),
            'info': ticker,
        };
    },

    async fetchTickers (symbols = undefined) {
        await this.loadMarkets ();
        let ids = (symbols) ? this.marketIds (symbols) : this.ids;
        let tickers = await this.publicGetTickerPair ({
            'pair': ids.join ('-'),
        });
        let result = {};
        let keys = Object.keys (tickers);
        for (let k = 0; k < keys.length; k++) {
            let id = keys[k];
            let ticker = tickers[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let id = market['id'];
        let tickers = await this.fetchTickers ([ id ]);
        return tickers[symbol];
    },

    parseTrade (trade, market) {
        let timestamp = trade['timestamp'] * 1000;
        let side = (trade['type'] == 'ask') ? 'sell' : 'buy';
        return {
            'id': trade['tid'],
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let id = market['id'];
        let response = await this.publicGetTradesPair (this.extend ({
            'pair': id,
        }, params));
        return this.parseTrades (response[id], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        };
        let response = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['return']['order_id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder ({ 'order_id': id });
    },

    parseOrder (order) {
        let statusCode = order['status'];
        let status = undefined;
        if (statusCode == 0) {
            status = 'open';
        } else if ((statusCode == 2) || (statusCode == 3)) {
            status = 'canceled';
        } else {
            status = 'closed';
        }
        let timestamp = order['timestamp_created'] * 1000;
        let market = this.markets_by_id[order['pair']];
        let result = {
            'info': order,
            'id': order['id'],
            'symbol': market['symbol'],
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'type': 'limit',
            'side': order['type'],
            'price': order['rate'],
            'amount': order['start_amount'],
            'remaining': order['amount'],
            'status': status,
        };
        return result;
    },

    parseOrders (orders, market = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    },

    async fetchOrder (id) {
        await this.loadMarkets ();
        let response = await this.privatePostOrderInfo ({ 'order_id': id });
        let order = response['return'][id];
        return this.parseOrder (this.extend ({ 'id': id }, order));
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        if (!symbol)
            throw new ExchangeError (this.id + ' requires a symbol');
        await this.loadMarkets ();
        let market = this.market (symbol);
        let request = {
            'pair': market['id'],
        };
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        return this.parseOrders (response['return'], market);
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostWithdrawCoin (this.extend ({
            'coinName': currency,
            'amount': parseFloat (amount),
            'address': address,
        }, params));
        return {
            'info': response,
            'id': response['return']['tId'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            url +=  '/' + this.version + '/' + this.implodeParams (path, params);
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
                'method': path,
            }, query));
            let signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha512');
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': signature,
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var luno = {

    'id': 'luno',
    'name': 'luno',
    'countries': [ 'GB', 'SG', 'ZA' ],
    'rateLimit': 3000,
    'version': '1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766607-8c1a69d8-5ede-11e7-930c-540b5eb9be24.jpg',
        'api': 'https://api.mybitx.com/api',
        'www': 'https://www.luno.com',
        'doc': [
            'https://www.luno.com/en/api',
            'https://npmjs.org/package/bitx',
            'https://github.com/bausmeier/node-bitx',
        ],
    },
    'api': {
        'public': {
            'get': [
                'orderbook',
                'ticker',
                'tickers',
                'trades',
            ],
        },
        'private': {
            'get': [
                'accounts/{id}/pending',
                'accounts/{id}/transactions',
                'balance',
                'fee_info',
                'funding_address',
                'listorders',
                'listtrades',
                'orders/{id}',
                'quotes/{id}',
                'withdrawals',
                'withdrawals/{id}',
            ],
            'post': [
                'accounts',
                'postorder',
                'marketorder',
                'stoporder',
                'funding_address',
                'withdrawals',
                'send',
                'quotes',
                'oauth2/grant',
            ],
            'put': [
                'quotes/{id}',
            ],
            'delete': [
                'quotes/{id}',
                'withdrawals/{id}',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['pair'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['balance'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = this.commonCurrencyCode (balance['asset']);
            let reserved = parseFloat (balance['reserved']);
            let unconfirmed = parseFloat (balance['unconfirmed']);
            let account = {
                'free': parseFloat (balance['balance']),
                'used': this.sum (reserved, unconfirmed),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetOrderbook (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        let timestamp = orderbook['timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'volume');
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['timestamp'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_trade']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['rolling_24_hour_volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetTickers ();
        let tickers = this.indexBy (response['tickers'], 'pair');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetTicker ({
            'pair': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let side = (trade['is_buy']) ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': undefined,
            'order': undefined,
            'timestamp': trade['timestamp'],
            'datetime': this.iso8601 (trade['timestamp']),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['volume']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let method = 'privatePost';
        let order = { 'pair': this.marketId (market) };
        if (type == 'market') {
            method += 'Marketorder';
            order['type'] = side.toUpperCase ();
            if (side == 'buy')
                order['counter_volume'] = amount;
            else
                order['base_volume'] = amount;
        } else {
            method += 'Order';
            order['volume'] = amount;
            order['price'] = price;
            if (side == 'buy')
                order['type'] = 'BID';
            else
                order['type'] = 'ASK';
        }
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'],
        };
    },

    async cancelOrder (id) {
        await this.loadMarkets ();
        return this.privatePostStoporder ({ 'order_id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (Object.keys (query).length)
            url += '?' + this.urlencode (query);
        if (api == 'private') {
            let auth = this.encode (this.apiKey + ':' + this.secret);
            auth = this.stringToBase64 (auth);
            headers = { 'Authorization': 'Basic ' + this.decode (auth) };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var mercado = {

    'id': 'mercado',
    'name': 'Mercado Bitcoin',
    'countries': 'BR', // Brazil
    'rateLimit': 1000,
    'version': 'v3',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27837060-e7c58714-60ea-11e7-9192-f05e86adb83f.jpg',
        'api': {
            'public': 'https://www.mercadobitcoin.net/api',
            'private': 'https://www.mercadobitcoin.net/tapi',
        },
        'www': 'https://www.mercadobitcoin.com.br',
        'doc': [
            'https://www.mercadobitcoin.com.br/api-doc',
            'https://www.mercadobitcoin.com.br/trade-api',
        ],
    },
    'api': {
        'public': {
            'get': [ // last slash critical
                'orderbook/',
                'orderbook_litecoin/',
                'ticker/',
                'ticker_litecoin/',
                'trades/',
                'trades_litecoin/',
                'v2/ticker/',
                'v2/ticker_litecoin/',
            ],
        },
        'private': {
            'post': [
                'cancel_order',
                'get_account_info',
                'get_order',
                'get_withdrawal',
                'list_system_messages',
                'list_orders',
                'list_orderbook',
                'place_buy_order',
                'place_sell_order',
                'withdraw_coin',
            ],
        },
    },
    'markets': {
        'BTC/BRL': { 'id': 'BRLBTC', 'symbol': 'BTC/BRL', 'base': 'BTC', 'quote': 'BRL', 'suffix': '' },
        'LTC/BRL': { 'id': 'BRLLTC', 'symbol': 'LTC/BRL', 'base': 'LTC', 'quote': 'BRL', 'suffix': 'Litecoin' },
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let method = 'publicGetOrderbook' + this.capitalize (market['suffix']);
        let orderbook = await this[method] (params);
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let method = 'publicGetV2Ticker' + this.capitalize (market['suffix']);
        let response = await this[method] ();
        let ticker = response['ticker'];
        let timestamp = parseInt (ticker['date']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['date'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let method = 'publicGetTrades' + this.capitalize (market['suffix']);
        let response = await this[method] (params);
        return this.parseTrades (response, market);
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostGetAccountInfo ();
        let balances = response['balance'];
        let result = { 'info': response };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balances) {
                account['free'] = parseFloat (balances[lowercase]['available']);
                account['total'] = parseFloat (balances[lowercase]['total']);
                account['used'] = account['total'] - account['free'];
            }
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let method = 'privatePostPlace' + this.capitalize (side) + 'Order';
        let order = {
            'coin_pair': this.marketId (symbol),
            'quantity': amount,
            'limit_price': price,
        };
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['response_data']['order']['order_id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api] + '/';
        if (api == 'public') {
            url += path;
        } else {
            url += this.version + '/';
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'tapi_method': path,
                'tapi_nonce': nonce,
            }, params));
            let auth = '/tapi/' + this.version + '/' + '?' + body;
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'TAPI-ID': this.apiKey,
                'TAPI-MAC': this.hmac (this.encode (auth), this.secret, 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error_message' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var mixcoins = {

    'id': 'mixcoins',
    'name': 'MixCoins',
    'countries': [ 'GB', 'HK' ],
    'rateLimit': 1500,
    'version': 'v1',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30237212-ed29303c-9535-11e7-8af8-fcd381cfa20c.jpg',
        'api': 'https://mixcoins.com/api',
        'www': 'https://mixcoins.com',
        'doc': 'https://mixcoins.com/help/api/',
    },
    'api': {
        'public': {
            'get': [
                'ticker',
                'trades',
                'depth',
            ],
        },
        'private': {
            'post': [
                'cancel',
                'info',
                'orders',
                'order',
                'transactions',
                'trade',
            ],
        },
    },
    'markets': {
        'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
        'BCH/BTC': { 'id': 'bcc_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC' },
        'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC' },
        'BCH/USD': { 'id': 'bcc_usd', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD' },
        'ETH/USD': { 'id': 'eth_usd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD' },
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostInfo ();
        let balance = response['result']['wallet'];
        let result = { 'info': balance };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if (lowercase in balance) {
                account['free'] = parseFloat (balance[lowercase]['avail']);
                account['used'] = parseFloat (balance[lowercase]['lock']);
                account['total'] = this.sum (account['free'], account['used']);
            }
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let response = await this.publicGetDepth (this.extend ({
            'market': this.marketId (symbol),
        }, params));
        let orderbook = response['result'];
        return this.parseOrderBook (response['result']);
    },

    async fetchTicker (symbol) {
        let response = await this.publicGetTicker ({
            'market': this.marketId (symbol),
        });
        let ticker = response['result'];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'id': trade['id'].toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': undefined,
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTrades (this.extend ({
            'market': market['id'],
        }, params));
        return this.parseTrades (response['result'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let order = {
            'market': this.marketId (symbol),
            'op': side,
            'amount': amount,
        };
        if (type == 'market') {
            order['order_type'] = 1;
            order['price'] = price;
        } else {
            order['order_type'] = 0;
        }
        let response = await this.privatePostTrade (this.extend (order, params));
        return {
            'info': response,
            'id': response['result']['id'].toString (),
        };
    },

    async cancelOrder (id) {
        return this.privatePostCancel ({ 'id': id });
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.secret, 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] == 200)
                return response;
        throw new ExchangeError (this.id + ' ' + this.json (response));
    },
}

//-----------------------------------------------------------------------------

var nova = {

    'id': 'nova',
    'name': 'Novaexchange',
    'countries': 'TZ', // Tanzania
    'rateLimit': 2000,
    'version': 'v2',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30518571-78ca0bca-9b8a-11e7-8840-64b83a4a94b2.jpg',
        'api': 'https://novaexchange.com/remote',
        'www': 'https://novaexchange.com',
        'doc': 'https://novaexchange.com/remote/faq',
    },
    'api': {
        'public': {
            'get': [
                'markets/',
                'markets/{basecurrency}',
                'market/info/{pair}/',
                'market/orderhistory/{pair}/',
                'market/openorders/{pair}/buy/',
                'market/openorders/{pair}/sell/',
                'market/openorders/{pair}/both/',
                'market/openorders/{pair}/{ordertype}/',
            ],
        },
        'private': {
            'post': [
                'getbalances/',
                'getbalance/{currency}/',
                'getdeposits/',
                'getwithdrawals/',
                'getnewdepositaddress/{currency}/',
                'getdepositaddress/{currency}/',
                'myopenorders/',
                'myopenorders_market/{pair}/',
                'cancelorder/{orderid}/',
                'withdraw/{currency}/',
                'trade/{pair}/',
                'tradehistory/',
                'getdeposithistory/',
                'getwithdrawalhistory/',
                'walletstatus/',
                'walletstatus/{currency}/',
            ],
        },
    },

    async fetchMarkets () {
        let response = await this.publicGetMarkets ();
        let markets = response['markets'];
        let result = [];
        for (let i = 0; i < markets.length; i++) {
            let market = markets[i];
            if (!market['disabled']) {
                let id = market['marketname'];
                let [ quote, base ] = id.split ('_');
                let symbol = base + '/' + quote;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'info': market,
                });
            }
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetMarketOpenordersPairBoth (this.extend ({
            'pair': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buyorders', 'sellorders', 'price', 'amount');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let response = await this.publicGetMarketInfoPair ({
            'pair': this.marketId (symbol),
        });
        let ticker = response['markets'][0];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24h']),
            'low': parseFloat (ticker['low24h']),
            'bid': this.safeFloat (ticker, 'bid'),
            'ask': this.safeFloat (ticker, 'ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last_price']),
            'change': parseFloat (ticker['change24h']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume24h']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = trade['unix_t_datestamp'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['tradetype'].toLowerCase (),
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetMarketOrderhistoryPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response['items'], market);
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetbalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let lockbox = parseFloat (balance['amount_lockbox']);
            let trades = parseFloat (balance['amount_trades']);
            let account = {
                'free': parseFloat (balance['amount']),
                'used': this.sum (lockbox, trades),
                'total': parseFloat (balance['amount_total']),
            };
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        amount = amount.toString ();
        price = price.toString ();
        let market = this.market (symbol);
        let order = {
            'tradetype': side.toUpperCase (),
            'tradeamount': amount,
            'tradeprice': price,
            'tradebase': 1,
            'pair': market['id'],
        };
        let response = await this.privatePostTradePair (this.extend (order, params));
        return {
            'info': response,
            'id': undefined,
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostCancelorder (this.extend ({
            'orderid': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/';
        if (api == 'private')
            url += api + '/';
        url += this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ().toString ();
            url += '?' + this.urlencode ({ 'nonce': nonce });
            let signature = this.hmac (this.encode (url), this.encode (this.secret), 'sha512', 'base64');
            body = this.urlencode (this.extend ({
                'apikey': this.apiKey,
                'signature': signature,
            }, query));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('status' in response)
            if (response['status'] != 'success')
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------
// OKCoin
// China
// https://www.okcoin.com/
// https://www.okcoin.com/rest_getStarted.html
// https://github.com/OKCoin/websocket
// https://www.npmjs.com/package/okcoin.com
// https://www.okcoin.cn
// https://www.okcoin.cn/rest_getStarted.html

var okcoin = {

    'version': 'v1',
    'rateLimit': 1000, // up to 3000 requests per 5 minutes ≈ 600 requests per minute ≈ 10 requests per second ≈ 100 ms
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1min',
        '3m': '3min',
        '5m': '5min',
        '15m': '15min',
        '30m': '30min',
        '1h': '1hour',
        '2h': '2hour',
        '4h': '4hour',
        '6h': '6hour',
        '12h': '12hour',
        '1d': '1day',
        '3d': '3day',
        '1w': '1week',
    },
    'api': {
        'public': {
            'get': [
                'depth',
                'exchange_rate',
                'future_depth',
                'future_estimated_price',
                'future_hold_amount',
                'future_index',
                'future_kline',
                'future_price_limit',
                'future_ticker',
                'future_trades',
                'kline',
                'otcs',
                'ticker',
                'trades',
            ],
        },
        'private': {
            'post': [
                'account_records',
                'batch_trade',
                'borrow_money',
                'borrow_order_info',
                'borrows_info',
                'cancel_borrow',
                'cancel_order',
                'cancel_otc_order',
                'cancel_withdraw',
                'future_batch_trade',
                'future_cancel',
                'future_devolve',
                'future_explosive',
                'future_order_info',
                'future_orders_info',
                'future_position',
                'future_position_4fix',
                'future_trade',
                'future_trades_history',
                'future_userinfo',
                'future_userinfo_4fix',
                'lend_depth',
                'order_fee',
                'order_history',
                'order_info',
                'orders_info',
                'otc_order_history',
                'otc_order_info',
                'repayment',
                'submit_otc_order',
                'trade',
                'trade_history',
                'trade_otc_order',
                'withdraw',
                'withdraw_info',
                'unrepayments_info',
                'userinfo',
            ],
        },
    },

    async fetchOrderBook (symbol, params = {}) {
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Depth';
        let orderbook = await this[method] (this.extend (request, params));
        let timestamp = this.milliseconds ();
        return {
            'bids': orderbook['bids'],
            'asks': this.sortBy (orderbook['asks'], 0),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    },

    parseTicker (ticker, market) {
        let timestamp = ticker['timestamp'];
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    async fetchTicker (symbol) {
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Ticker';
        let response = await this[method] (request);
        let timestamp = parseInt (response['date']) * 1000;
        let ticker = this.extend (response['ticker'], { 'timestamp': timestamp });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let symbol = undefined;
        if (market)
            symbol = market['symbol'];
        return {
            'info': trade,
            'timestamp': trade['date_ms'],
            'datetime': this.iso8601 (trade['date_ms']),
            'symbol': symbol,
            'id': trade['tid'],
            'order': undefined,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Trades';
        let response = await this[method] (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 1440, params = {}) {
        let market = this.market (symbol);
        let method = 'publicGet';
        let request = {
            'symbol': market['id'],
            'type': this.timeframes[timeframe],
        };
        if (market['future']) {
            method += 'Future';
            request['contract_type'] = 'this_week'; // next_week, quarter
        }
        method += 'Kline';
        if (limit)
            request['size'] = parseInt (limit);
        if (since) {
            request['since'] = since;
        } else {
            request['since'] = this.milliseconds () - 86400000; // last 24 hours
        }
        let response = await this[method] (this.extend (request, params));
        return this.parseOHLCVs (response, market, timeframe, since, limit);
    },

    async fetchBalance (params = {}) {
        let response = await this.privatePostUserinfo ();
        let balances = response['info']['funds'];
        let result = { 'info': response };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            account['free'] = this.safeFloat (balances['free'], lowercase, 0.0);
            account['used'] = this.safeFloat (balances['freezed'], lowercase, 0.0);
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let market = this.market (symbol);
        let method = 'privatePost';
        let order = {
            'symbol': market['id'],
            'type': side,
        };
        if (market['future']) {
            method += 'Future';
            order = this.extend (order, {
                'contract_type': 'this_week', // next_week, quarter
                'match_price': 0, // match best counter party price? 0 or 1, ignores price if 1
                'lever_rate': 10, // leverage rate value: 10 or 20 (10 by default)
                'price': price,
                'amount': amount,
            });
        } else {
            if (type == 'limit') {
                order['price'] = price;
                order['amount'] = amount;
            } else {
                order['type'] += '_market';
                if (side == 'buy') {
                    order['price'] = params;
                } else {
                    order['amount'] = amount;
                }
            }
        }
        method += 'Trade';
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['order_id'].toString (),
        };
    },

    cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + 'api' + '/' + this.version + '/' + path + '.do';
        if (api == 'public') {
            if (Object.keys (params).length)
                url += '?' + this.urlencode (params);
        } else {
            let query = this.keysort (this.extend ({
                'api_key': this.apiKey,
            }, params));
            // secret key must be at the end of query
            let queryString = this.urlencode (query) + '&secret_key=' + this.secret;
            query['sign'] = this.hash (this.encode (queryString)).toUpperCase ();
            body = this.urlencode (query);
            headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
        }
        url = this.urls['api'] + url;
        let response = await this.fetch (url, method, headers, body);
        if ('result' in response)
            if (!response['result'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var okcoincny = extend (okcoin, {
    'id': 'okcoincny',
    'name': 'OKCoin CNY',
    'countries': 'CN',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766792-8be9157a-5ee5-11e7-926c-6d69b8d3378d.jpg',
        'api': 'https://www.okcoin.cn',
        'www': 'https://www.okcoin.cn',
        'doc': 'https://www.okcoin.cn/rest_getStarted.html',
    },
    'markets': {
        'BTC/CNY': { 'id': 'btc_cny', 'symbol': 'BTC/CNY', 'base': 'BTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
        'LTC/CNY': { 'id': 'ltc_cny', 'symbol': 'LTC/CNY', 'base': 'LTC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
        'ETH/CNY': { 'id': 'eth_cny', 'symbol': 'ETH/CNY', 'base': 'ETH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
        'ETC/CNY': { 'id': 'etc_cny', 'symbol': 'ETC/CNY', 'base': 'ETC', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
        'BCH/CNY': { 'id': 'bcc_cny', 'symbol': 'BCH/CNY', 'base': 'BCH', 'quote': 'CNY', 'type': 'spot', 'spot': true, 'future': false },
    },
})

//-----------------------------------------------------------------------------

var okcoinusd = extend (okcoin, {
    'id': 'okcoinusd',
    'name': 'OKCoin USD',
    'countries': [ 'CN', 'US' ],
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766791-89ffb502-5ee5-11e7-8a5b-c5950b68ac65.jpg',
        'api': 'https://www.okcoin.com',
        'www': 'https://www.okcoin.com',
        'doc': [
            'https://www.okcoin.com/rest_getStarted.html',
            'https://www.npmjs.com/package/okcoin.com',
        ],
    },
    'markets': {
        'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'type': 'spot', 'spot': true, 'future': false },
        'LTC/USD': { 'id': 'ltc_usd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'type': 'spot', 'spot': true, 'future': false },
        'ETH/USD': { 'id': 'eth_usd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'type': 'spot', 'spot': true, 'future': false },
        'ETC/USD': { 'id': 'etc_usd', 'symbol': 'ETC/USD', 'base': 'ETC', 'quote': 'USD', 'type': 'spot', 'spot': true, 'future': false },
    },
})

//-----------------------------------------------------------------------------

var okex = extend (okcoin, {
    'id': 'okex',
    'name': 'OKEX',
    'countries': [ 'CN', 'US' ],
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/29562593-9038a9bc-8742-11e7-91cc-8201f845bfc1.jpg',
        'api': 'https://www.okex.com',
        'www': 'https://www.okex.com',
        'doc': 'https://www.okex.com/rest_getStarted.html',
    },
    'markets': {
        'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'type': 'future', 'spot': false, 'future': true },
        'LTC/USD': { 'id': 'ltc_usd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'type': 'future', 'spot': false, 'future': true },
        'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'type': 'spot', 'spot': true, 'future': false },
        'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'type': 'spot', 'spot': true, 'future': false },
        'ETC/BTC': { 'id': 'etc_btc', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC', 'type': 'spot', 'spot': true, 'future': false },
        'BCH/BTC': { 'id': 'bcc_btc', 'symbol': 'BCH/BTC', 'base': 'BCH', 'quote': 'BTC', 'type': 'spot', 'spot': true, 'future': false },
    },

    cancelOrder (id, params = {}) {
        return this.privatePostFutureCancel (this.extend ({
            'order_id': id,
        }, params));
    },
})

//-----------------------------------------------------------------------------

var paymium = {

    'id': 'paymium',
    'name': 'Paymium',
    'countries': [ 'FR', 'EU' ],
    'rateLimit': 2000,
    'version': 'v1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27790564-a945a9d4-5ff9-11e7-9d2d-b635763f2f24.jpg',
        'api': 'https://paymium.com/api',
        'www': 'https://www.paymium.com',
        'doc': [
            'https://github.com/Paymium/api-documentation',
            'https://www.paymium.com/page/developers',
        ],
    },
    'api': {
        'public': {
            'get': [
                'countries',
                'data/{id}/ticker',
                'data/{id}/trades',
                'data/{id}/depth',
                'bitcoin_charts/{id}/trades',
                'bitcoin_charts/{id}/depth',
            ],
        },
        'private': {
            'get': [
                'merchant/get_payment/{UUID}',
                'user',
                'user/addresses',
                'user/addresses/{btc_address}',
                'user/orders',
                'user/orders/{UUID}',
                'user/price_alerts',
            ],
            'post': [
                'user/orders',
                'user/addresses',
                'user/payment_requests',
                'user/price_alerts',
                'merchant/create_payment',
            ],
            'delete': [
                'user/orders/{UUID}/cancel',
                'user/price_alerts/{id}',
            ],
        },
    },
    'markets': {
        'BTC/EUR': { 'id': 'eur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR' },
    },

    async fetchBalance (params = {}) {
        let balances = await this.privateGetUser ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            let balance = 'balance_' + lowercase;
            let locked = 'locked_' + lowercase;
            if (balance in balances)
                account['free'] = balances[balance];
            if (locked in balances)
                account['used'] = balances[locked];
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        let orderbook = await this.publicGetDataIdDepth (this.extend ({
            'id': this.marketId (market),
        }, params));
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'price', 'amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    },

    async fetchTicker (market) {
        let ticker = await this.publicGetDataIdTicker ({
            'id': this.marketId (market),
        });
        let timestamp = ticker['at'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': parseFloat (ticker['open']),
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['price']),
            'change': undefined,
            'percentage': parseFloat (ticker['variation']),
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['created_at_int']) * 1000;
        let volume = 'traded_' + market['base'].toLowerCase ();
        return {
            'info': trade,
            'id': trade['uuid'],
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade[volume],
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetDataIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        let order = {
            'type': this.capitalize (type) + 'Order',
            'currency': this.marketId (market),
            'direction': side,
            'amount': amount,
        };
        if (type == 'market')
            order['price'] = price;
        let response = await this.privatePostUserOrders (this.extend (order, params));
        return {
            'info': response,
            'id': response['uuid'],
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'orderNumber': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            body = this.json (params);
            let nonce = this.nonce ().toString ();
            let auth = nonce + url + body;
            headers = {
                'Api-Key': this.apiKey,
                'Api-Signature': this.hmac (this.encode (auth), this.secret),
                'Api-Nonce': nonce,
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var poloniex = {

    'id': 'poloniex',
    'name': 'Poloniex',
    'countries': 'US',
    'rateLimit': 500, // up 6 calls per second
    'hasCORS': true,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766817-e9456312-5ee6-11e7-9b3c-b628ca5626a5.jpg',
        'api': {
            'public': 'https://poloniex.com/public',
            'private': 'https://poloniex.com/tradingApi',
        },
        'www': 'https://poloniex.com',
        'doc': [
            'https://poloniex.com/support/api/',
            'http://pastebin.com/dMX7mZE0',
        ],
        'fees': 'https://poloniex.com/fees',
    },
    'api': {
        'public': {
            'get': [
                'return24hVolume',
                'returnChartData',
                'returnCurrencies',
                'returnLoanOrders',
                'returnOrderBook',
                'returnTicker',
                'returnTradeHistory',
            ],
        },
        'private': {
            'post': [
                'buy',
                'cancelLoanOffer',
                'cancelOrder',
                'closeMarginPosition',
                'createLoanOffer',
                'generateNewAddress',
                'getMarginPosition',
                'marginBuy',
                'marginSell',
                'moveOrder',
                'returnActiveLoans',
                'returnAvailableAccountBalances',
                'returnBalances',
                'returnCompleteBalances',
                'returnDepositAddresses',
                'returnDepositsWithdrawals',
                'returnFeeInfo',
                'returnLendingHistory',
                'returnMarginAccountSummary',
                'returnOpenLoanOffers',
                'returnOpenOrders',
                'returnOrderTrades',
                'returnTradableBalances',
                'returnTradeHistory',
                'sell',
                'toggleAutoRenew',
                'transferBalance',
                'withdraw',
            ],
        },
    },
    'fees': {
        'trading': {
            'maker': 0.0015,
            'taker': 0.0025,
        },
        'funding': 0.0,
    },

    calculateFeeRate (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
        let key = (side == 'sell') ? 'quote' : 'base';
        let market = this.markets[symbol];
        return { 'currency': market[key], 'rate': market[takerOrMaker] };
    },

    async fetchMarkets () {
        let markets = await this.publicGetReturnTicker ();
        let keys = Object.keys (markets);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets[id];
            let [ quote, base ] = id.split ('_');
            let symbol = base + '/' + quote;
            result.push (this.extend (this.fees['trading'], {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            }));
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostReturnCompleteBalances ({
            'account': 'all',
        });
        let result = { 'info': balances };
        let currencies = Object.keys (balances);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = balances[currency];
            let account = {
                'free': parseFloat (balance['available']),
                'used': parseFloat (balance['onOrders']),
                'total': 0.0,
            };
            account['total'] = this.sum (account['free'], account['used']);
            result[currency] = account;
        }
        return result;
    },

    async fetchFees (params = {}) {
        await this.loadMarkets ();
        let fees = await this.privatePostReturnFeeInfo ();
        return {
            'info': fees,
            'maker': parseFloat (fees['makerFee']),
            'taker': parseFloat (fees['takerFee']),
            'withdraw': 0.0,
        };
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetReturnOrderBook (this.extend ({
            'currencyPair': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high24hr']),
            'low': parseFloat (ticker['low24hr']),
            'bid': parseFloat (ticker['highestBid']),
            'ask': parseFloat (ticker['lowestAsk']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': parseFloat (ticker['percentChange']),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['baseVolume']),
            'quoteVolume': parseFloat (ticker['quoteVolume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetReturnTicker ();
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetReturnTicker ();
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        let timestamp = this.parse8601 (trade['date']);
        let id = undefined;
        let order = undefined;
        let symbol = undefined;
        if (market) {
            symbol = market['symbol'];
        } else if ('currencyPair' in trade) {
            let marketId = trade['currencyPair'];
            symbol = this.markets_by_id[marketId]['symbol'];
        }
        if ('tradeID' in trade)
            id = trade['tradeID'];
        if ('orderNumber' in trade)
            order = trade['orderNumber'];
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': symbol,
            'id': id,
            'order': order,
            'type': undefined,
            'side': trade['type'],
            'price': parseFloat (trade['rate']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let trades = await this.publicGetReturnTradeHistory (this.extend ({
            'currencyPair': market['id'],
            'end': this.seconds (), // last 50000 trades by default
        }, params));
        return this.parseTrades (trades, market);
    },

    async fetchMyTrades (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let request = this.extend ({
            'currencyPair': pair,
            'end': this.seconds (), // last 50000 trades by default
        }, params);
        let response = await this.privatePostReturnTradeHistory (request);
        let result = undefined;
        if (market) {
            result = this.parseTrades (response, market);
        } else {
            result = { 'info': response };
            let ids = Object.keys (response);
            for (let i = 0; i < ids.length; i++) {
                let id = ids[i];
                let market = this.markets_by_id[id];
                let symbol = market['symbol'];
                result[symbol] = this.parseTrades (response[id], market);
            }
        }
        return result;
    },

    parseOrder (order, market) {
        let trades = undefined;
        if ('resultingTrades' in order)
            trades = this.parseTrades (order['resultingTrades'], market);
        return {
            'info': order,
            'id': order['orderNumber'],
            'timestamp': order['timestamp'],
            'datetime': this.iso8601 (order['timestamp']),
            'status': order['status'],
            'symbol': market['symbol'],
            'type': order['type'],
            'side': order['side'],
            'price': parseFloat (order['price']),
            'amount': parseFloat (order['amount']),
            'trades': trades,
        };
    },

    parseOpenOrders (orders, market, result = []) {
        for (let i = 0; i < orders.length; i++) {
            let order = orders[i];
            let timestamp = this.parse8601 (order['date']);
            let extended = this.extend (order, {
                'timestamp': timestamp,
                'status': 'open',
                'type': 'limit',
                'side': order['type'],
                'price': order['rate'],
            });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        if (symbol)
            market = this.market (symbol);
        let pair = market ? market['id'] : 'all';
        let response = await this.privatePostReturnOpenOrders (this.extend ({
            'currencyPair': pair,
        }));
        if (market)
            return this.parseOpenOrders (response, market);
        let ids = Object.keys (response);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let orders = response[id];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            this.parseOpenOrders (orders, market, result);
        }
        return result;
    },

    async fetchOrderStatus (id, market = undefined) {
        await this.loadMarkets ();
        let orders = await this.fetchOpenOrders (market);
        let indexed = this.indexBy (orders, 'id');
        return (id in indexed) ? 'open' : 'closed';
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        await this.loadMarkets ();
        let method = 'privatePost' + this.capitalize (side);
        let market = this.market (symbol);
        let response = await this[method] (this.extend ({
            'currencyPair': market['id'],
            'rate': price,
            'amount': amount,
        }, params));
        let timestamp = this.milliseconds ();
        let order = this.parseOrder (this.extend ({
            'timestamp': timestamp,
            'status': 'open',
            'type': type,
            'side': side,
            'price': parseFloat (price),
            'amount': parseFloat (amount),
        }, response), market);
        let id = order['id'];
        this.orders[id] = order;
        return this.extend ({ 'info': response }, order);
    },

    async fetchOrder (id) {
        await this.loadMarkets ();
        let orders = await this.fetchOpenOrders ();
        let index = this.indexBy (orders, 'id');
        if (id in index) {
            this.orders[id] = index[id];
            return index[id];
        } else if (id in this.orders) {
            this.orders[id]['status'] = 'closed';
            return this.orders[id];
        }
        throw new ExchangeError (this.id + ' order ' + id + ' not found');
    },

    async fetchOrderTrades (id, params = {}) {
        await this.loadMarkets ();
        let trades = await this.privatePostReturnOrderTrades (this.extend ({
            'orderNumber': id,
        }, params));
        return this.parseTrades (trades);
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder (this.extend ({
            'orderNumber': id,
        }, params));
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': result['response'],
        };
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let query = this.extend ({ 'command': path }, params);
        if (api == 'public') {
            url += '?' + this.urlencode (query);
        } else {
            query['nonce'] = this.nonce ();
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response) {
            let error = this.id + ' ' + this.json (response);
            let failed = response['error'].indexOf ('Not enough') >= 0;
            if (failed)
                throw new InsufficientFunds (error);
            throw new ExchangeError (error);
        }
        return response;
    },
}

//-----------------------------------------------------------------------------

var quadrigacx = {

    'id': 'quadrigacx',
    'name': 'QuadrigaCX',
    'countries': 'CA',
    'rateLimit': 1000,
    'version': 'v2',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766825-98a6d0de-5ee7-11e7-9fa4-38e11a2c6f52.jpg',
        'api': 'https://api.quadrigacx.com',
        'www': 'https://www.quadrigacx.com',
        'doc': 'https://www.quadrigacx.com/api_info',
    },
    'api': {
        'public': {
            'get': [
                'order_book',
                'ticker',
                'transactions',
            ],
        },
        'private': {
            'post': [
                'balance',
                'bitcoin_deposit_address',
                'bitcoin_withdrawal',
                'buy',
                'cancel_order',
                'ether_deposit_address',
                'ether_withdrawal',
                'lookup_order',
                'open_orders',
                'sell',
                'user_transactions',
            ],
        },
    },
    'markets': {
        'BTC/CAD': { 'id': 'btc_cad', 'symbol': 'BTC/CAD', 'base': 'BTC', 'quote': 'CAD' },
        'BTC/USD': { 'id': 'btc_usd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD' },
        'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC' },
        'ETH/CAD': { 'id': 'eth_cad', 'symbol': 'ETH/CAD', 'base': 'ETH', 'quote': 'CAD' },
    },

    async fetchBalance (params = {}) {
        let balances = await this.privatePostBalance ();
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = {
                'free': parseFloat (balances[lowercase + '_available']),
                'used': parseFloat (balances[lowercase + '_reserved']),
                'total': parseFloat (balances[lowercase + '_balance']),
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        let orderbook = await this.publicGetOrderBook (this.extend ({
            'book': this.marketId (symbol),
        }, params));
        let timestamp = parseInt (orderbook['timestamp']) * 1000;
        return this.parseOrderBook (orderbook, timestamp);
    },

    async fetchTicker (symbol) {
        let ticker = await this.publicGetTicker ({
            'book': this.marketId (symbol),
        });
        let timestamp = parseInt (ticker['timestamp']) * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': parseFloat (ticker['vwap']),
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = parseInt (trade['date']) * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': trade['tid'].toString (),
            'order': undefined,
            'type': undefined,
            'side': trade['side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['amount']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        let market = this.market (symbol);
        let response = await this.publicGetTransactions (this.extend ({
            'book': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        let method = 'privatePost' + this.capitalize (side);
        let order = {
            'amount': amount,
            'book': this.marketId (symbol),
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this[method] (this.extend (order, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + path;
        if (api == 'public') {
            url += '?' + this.urlencode (params);
        } else {
            if (!this.uid)
                throw new AuthenticationError (this.id + ' requires `' + this.id + '.uid` property for authentication');
            let nonce = this.nonce ();
            let request = [ nonce.toString (), this.uid, this.apiKey ].join ('');
            let signature = this.hmac (this.encode (request), this.encode (this.secret));
            let query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
                'signature': signature,
            }, params);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var quoine = {

    'id': 'quoine',
    'name': 'QUOINE',
    'countries': [ 'JP', 'SG', 'VN' ],
    'version': '2',
    'rateLimit': 1000,
    'hasFetchTickers': true,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766844-9615a4e8-5ee8-11e7-8814-fcd004db8cdd.jpg',
        'api': 'https://api.quoine.com',
        'www': 'https://www.quoine.com',
        'doc': 'https://developers.quoine.com',
    },
    'api': {
        'public': {
            'get': [
                'products',
                'products/{id}',
                'products/{id}/price_levels',
                'executions',
                'ir_ladders/{currency}',
            ],
        },
        'private': {
            'get': [
                'accounts/balance',
                'crypto_accounts',
                'executions/me',
                'fiat_accounts',
                'loan_bids',
                'loans',
                'orders',
                'orders/{id}',
                'orders/{id}/trades',
                'trades',
                'trades/{id}/loans',
                'trading_accounts',
                'trading_accounts/{id}',
            ],
            'post': [
                'fiat_accounts',
                'loan_bids',
                'orders',
            ],
            'put': [
                'loan_bids/{id}/close',
                'loans/{id}',
                'orders/{id}',
                'orders/{id}/cancel',
                'trades/{id}',
                'trades/{id}/close',
                'trades/close_all',
                'trading_accounts/{id}',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetProducts ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['id'];
            let base = market['base_currency'];
            let quote = market['quoted_currency'];
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAccountsBalance ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = parseFloat (balance['balance']);
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetProductsIdPriceLevels (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'buy_price_levels', 'sell_price_levels');
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        let last = undefined;
        if ('last_traded_price' in ticker) {
            if (ticker['last_traded_price']) {
                let length = ticker['last_traded_price'].length;
                if (length > 0)
                    last = parseFloat (ticker['last_traded_price']);
            }
        }
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high_market_ask']),
            'low': parseFloat (ticker['low_market_bid']),
            'bid': parseFloat (ticker['market_bid']),
            'ask': parseFloat (ticker['market_ask']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_24h']),
            'quoteVolume': undefined,
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetProducts ();
        let result = {};
        for (let t = 0; t < tickers.length; t++) {
            let ticker = tickers[t];
            let base = ticker['base_currency'];
            let quote = ticker['quoted_currency'];
            let symbol = base + '/' + quote;
            let market = this.markets[symbol];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetProductsId ({
            'id': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['created_at'] * 1000;
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['taker_side'],
            'price': parseFloat (trade['price']),
            'amount': parseFloat (trade['quantity']),
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetExecutions (this.extend ({
            'product_id': market['id'],
        }, params));
        return this.parseTrades (response['models'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'order_type': type,
            'product_id': this.marketId (symbol),
            'side': side,
            'quantity': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostOrders (this.extend ({
            'order': order,
        }, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePutOrdersIdCancel (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        headers = {
            'X-Quoine-API-Version': this.version,
            'Content-Type': 'application/json',
        };
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let request = {
                'path': url,
                'nonce': nonce,
                'token_id': this.apiKey,
                'iat': Math.floor (nonce / 1000), // issued at
            };
            if (Object.keys (query).length)
                body = this.json (query);
            headers['X-Quoine-Auth'] = this.jwt (request, this.secret);
        }
        let response = await this.fetch (this.urls['api'] + url, method, headers, body);
        if ('message' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var southxchange = {

    'id': 'southxchange',
    'name': 'SouthXchange',
    'countries': 'AR', // Argentina
    'rateLimit': 1000,
    'hasFetchTickers': true,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27838912-4f94ec8a-60f6-11e7-9e5d-bbf9bd50a559.jpg',
        'api': 'https://www.southxchange.com/api',
        'www': 'https://www.southxchange.com',
        'doc': 'https://www.southxchange.com/Home/Api',
    },
    'api': {
        'public': {
            'get': [
                'markets',
                'price/{symbol}',
                'prices',
                'book/{symbol}',
                'trades/{symbol}',
            ],
        },
        'private': {
            'post': [
                'cancelMarketOrders',
                'cancelOrder',
                'generatenewaddress',
                'listOrders',
                'listBalances',
                'placeOrder',
                'withdraw',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetMarkets ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let base = market[0];
            let quote = market[1];
            let symbol = base + '/' + quote;
            let id = symbol;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privatePostListBalances ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.uppercase;
            let free = parseFloat (balance['Available']);
            let used = parseFloat (balance['Unconfirmed']);
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetBookSymbol (this.extend ({
            'symbol': this.marketId (symbol),
        }, params));
        return this.parseOrderBook (orderbook, undefined, 'BuyOrders', 'SellOrders', 'Price', 'Amount');
    },

    parseTicker (ticker, market) {
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': undefined,
            'low': undefined,
            'bid': this.safeFloat (ticker, 'Bid'),
            'ask': this.safeFloat (ticker, 'Ask'),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': this.safeFloat (ticker, 'Last'),
            'change': this.safeFloat (ticker, 'Variation24Hr'),
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': this.safeFloat (ticker, 'Volume24Hr'),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetPrices ();
        let tickers = this.indexBy (response, 'Market');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetPriceSymbol ({
            'symbol': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market) {
        let timestamp = trade['At'] * 1000;
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'id': undefined,
            'order': undefined,
            'type': undefined,
            'side': trade['Type'],
            'price': trade['Price'],
            'amount': trade['Amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesSymbol (this.extend ({
            'symbol': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let order = {
            'listingCurrency': market['base'],
            'referenceCurrency': market['quote'],
            'type': side,
            'amount': amount,
        };
        if (type == 'limit')
            order['limitPrice'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response.toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostCancelOrder (this.extend ({
            'orderCode': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            let nonce = this.nonce ();
            query = this.extend ({
                'key': this.apiKey,
                'nonce': nonce,
            }, query);
            body = this.json (query);
            headers = {
                'Content-Type': 'application/json',
                'Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        // if (!response)
        //     throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var surbitcoin = extend (blinktrade, {
    'id': 'surbitcoin',
    'name': 'SurBitcoin',
    'countries': 'VE',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27991511-f0a50194-6481-11e7-99b5-8f02932424cc.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://surbitcoin.com',
        'doc': 'https://blinktrade.com/docs',
    },
    'comment': 'Blinktrade API',
    'markets': {
        'BTC/VEF': { 'id': 'BTCVEF', 'symbol': 'BTC/VEF', 'base': 'BTC', 'quote': 'VEF', 'brokerId': 1, 'broker': 'SurBitcoin' },
    },
})

//-----------------------------------------------------------------------------

var therock = {

    'id': 'therock',
    'name': 'TheRockTrading',
    'countries': 'MT',
    'rateLimit': 1000,
    'version': 'v1',
    'hasCORS': false,
    'hasFetchTickers': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766869-75057fa2-5ee9-11e7-9a6f-13e641fa4707.jpg',
        'api': 'https://api.therocktrading.com',
        'www': 'https://therocktrading.com',
        'doc': [
            'https://api.therocktrading.com/doc/v1/index.html',
            'https://api.therocktrading.com/doc/',
        ],
    },
    'api': {
        'public': {
            'get': [
                'funds/{id}/orderbook',
                'funds/{id}/ticker',
                'funds/{id}/trades',
                'funds/tickers',
            ],
        },
        'private': {
            'get': [
                'balances',
                'balances/{id}',
                'discounts',
                'discounts/{id}',
                'funds',
                'funds/{id}',
                'funds/{id}/trades',
                'funds/{fund_id}/orders',
                'funds/{fund_id}/orders/{id}',
                'funds/{fund_id}/position_balances',
                'funds/{fund_id}/positions',
                'funds/{fund_id}/positions/{id}',
                'transactions',
                'transactions/{id}',
                'withdraw_limits/{id}',
                'withdraw_limits',
            ],
            'post': [
                'atms/withdraw',
                'funds/{fund_id}/orders',
            ],
            'delete': [
                'funds/{fund_id}/orders/{id}',
                'funds/{fund_id}/orders/remove_all',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetFundsTickers ();
        let result = [];
        for (let p = 0; p < markets['tickers'].length; p++) {
            let market = markets['tickers'][p];
            let id = market['fund_id'];
            let base = id.slice (0, 3);
            let quote = id.slice (3, 6);
            let symbol = base + '/' + quote;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalances ();
        let balances = response['balances'];
        let result = { 'info': response };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let free = balance['trading_balance'];
            let total = balance['balance'];
            let used = total - free;
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetFundsIdOrderbook (this.extend ({
            'id': this.marketId (symbol),
        }, params));
        let timestamp = this.parse8601 (orderbook['date']);
        return this.parseOrderBook (orderbook, timestamp, 'bids', 'asks', 'price', 'amount');
    },

    parseTicker (ticker, market) {
        let timestamp = this.parse8601 (ticker['date']);
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['bid']),
            'ask': parseFloat (ticker['ask']),
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['volume_traded']),
            'quoteVolume': parseFloat (ticker['volume']),
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let response = await this.publicGetFundsTickers ();
        let tickers = this.indexBy (response['tickers'], 'fund_id');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = this.markets_by_id[id];
            let symbol = market['symbol'];
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let ticker = await this.publicGetFundsIdTicker ({
            'id': market['id'],
        });
        return this.parseTicker (ticker, market);
    },

    parseTrade (trade, market = undefined) {
        if (!market)
            market = this.markets_by_id[trade['fund_id']];
        let timestamp = this.parse8601 (trade['date']);
        return {
            'info': trade,
            'id': trade['id'].toString (),
            'order': undefined,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': trade['side'],
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetFundsIdTrades (this.extend ({
            'id': market['id'],
        }, params));
        return this.parseTrades (response['trades'], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostFundsFundIdOrders (this.extend ({
            'fund_id': this.marketId (symbol),
            'side': side,
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['id'].toString (),
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privateDeleteFundsFundIdOrdersId (this.extend ({
            'id': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'private') {
            let nonce = this.nonce ().toString ();
            let auth = nonce + url;
            headers = {
                'X-TRT-KEY': this.apiKey,
                'X-TRT-NONCE': nonce,
                'X-TRT-SIGN': this.hmac (this.encode (auth), this.encode (this.secret), 'sha512'),
            };
            if (Object.keys (query).length) {
                body = this.json (query);
                headers['Content-Type'] = 'application/json';
            }
        }
        let response = await this.fetch (url, method, headers, body);
        if ('errors' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var urdubit = extend (blinktrade, {
    'id': 'urdubit',
    'name': 'UrduBit',
    'countries': 'PK',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27991453-156bf3ae-6480-11e7-82eb-7295fe1b5bb4.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://urdubit.com',
        'doc': 'https://blinktrade.com/docs',
    },
    'comment': 'Blinktrade API',
    'markets': {
        'BTC/PKR': { 'id': 'BTCPKR', 'symbol': 'BTC/PKR', 'base': 'BTC', 'quote': 'PKR', 'brokerId': 8, 'broker': 'UrduBit' },
    },
})

//-----------------------------------------------------------------------------

var vaultoro = {

    'id': 'vaultoro',
    'name': 'Vaultoro',
    'countries': 'CH',
    'rateLimit': 1000,
    'version': '1',
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766880-f205e870-5ee9-11e7-8fe2-0d5b15880752.jpg',
        'api': 'https://api.vaultoro.com',
        'www': 'https://www.vaultoro.com',
        'doc': 'https://api.vaultoro.com',
    },
    'api': {
        'public': {
            'get': [
                'bidandask',
                'buyorders',
                'latest',
                'latesttrades',
                'markets',
                'orderbook',
                'sellorders',
                'transactions/day',
                'transactions/hour',
                'transactions/month',
            ],
        },
        'private': {
            'get': [
                'balance',
                'mytrades',
                'orders',
            ],
            'post': [
                'buy/{symbol}/{type}',
                'cancel/{id}',
                'sell/{symbol}/{type}',
                'withdraw',
            ],
        },
    },

    async fetchMarkets () {
        let result = [];
        let markets = await this.publicGetMarkets ();
        let market = markets['data'];
        let base = market['BaseCurrency'];
        let quote = market['MarketCurrency'];
        let symbol = base + '/' + quote;
        let baseId = base;
        let quoteId = quote;
        let id = market['MarketName'];
        result.push ({
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'info': market,
        });
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privateGetBalance ();
        let balances = response['data'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency_code'];
            let uppercase = currency.toUpperCase ();
            let free = balance['cash'];
            let used = balance['reserved'];
            let total = this.sum (free, used);
            let account = {
                'free': free,
                'used': used,
                'total': total,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicGetOrderbook (params);
        let orderbook = {
            'bids': response['data'][0]['b'],
            'asks': response['data'][1]['s'],
        };
        let result = this.parseOrderBook (orderbook, undefined, 'bids', 'asks', 'Gold_Price', 'Gold_Amount');
        result['bids'] = this.sortBy (result['bids'], 0, true);
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let quote = await this.publicGetBidandask ();
        let bidsLength = quote['bids'].length;
        let bid = quote['bids'][bidsLength - 1];
        let ask = quote['asks'][0];
        let response = await this.publicGetMarkets ();
        let ticker = response['data'];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['24hHigh']),
            'low': parseFloat (ticker['24hLow']),
            'bid': bid[0],
            'ask': ask[0],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['LastPrice']),
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': parseFloat (ticker['24hVolume']),
            'info': ticker,
        };
    },

    parseTrade (trade, market) {
        let timestamp = this.parse8601 (trade['Time']);
        return {
            'id': undefined,
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'order': undefined,
            'type': undefined,
            'side': undefined,
            'price': trade['Gold_Price'],
            'amount': trade['Gold_Amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTransactionsDay (params);
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let method = 'privatePost' + this.capitalize (side) + 'SymbolType';
        let response = await this[method] (this.extend ({
            'symbol': market['quoteId'].toLowerCase (),
            'type': type,
            'gld': amount,
            'price': price || 1,
        }, params));
        return {
            'info': response,
            'id': response['data']['Order_ID'],
        };
    },

    async cancelOrder (id, params = {}) {
        await this.loadMarkets ();
        return this.privatePostCancelId (this.extend ({
            'id': id,
        }, params));
    },

    request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += path;
        } else {
            let nonce = this.nonce ();
            url += this.version + '/' + this.implodeParams (path, params);
            let query = this.extend ({
                'nonce': nonce,
                'apikey': this.apiKey,
            }, this.omit (params, this.extractParams (path)));
            url += '?' + this.urlencode (query);
            headers = {
                'Content-Type': 'application/json',
                'X-Signature': this.hmac (this.encode (url), this.encode (this.secret))
            };
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var vbtc = extend (blinktrade, {
    'id': 'vbtc',
    'name': 'VBTC',
    'countries': 'VN',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27991481-1f53d1d8-6481-11e7-884e-21d17e7939db.jpg',
        'api': {
            'public': 'https://api.blinktrade.com/api',
            'private': 'https://api.blinktrade.com/tapi',
        },
        'www': 'https://vbtc.exchange',
        'doc': 'https://blinktrade.com/docs',
    },
    'comment': 'Blinktrade API',
    'markets': {
        'BTC/VND': { 'id': 'BTCVND', 'symbol': 'BTC/VND', 'base': 'BTC', 'quote': 'VND', 'brokerId': 3, 'broker': 'VBTC' },
    },
})


//-----------------------------------------------------------------------------

var virwox = {

    'id': 'virwox',
    'name': 'VirWoX',
    'countries': [ 'AT', 'EU' ],
    'rateLimit': 1000,
    'hasCORS': true,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766894-6da9d360-5eea-11e7-90aa-41f2711b7405.jpg',
        'api': {
            'public': 'http://api.virwox.com/api/json.php',
            'private': 'https://www.virwox.com/api/trading.php',
        },
        'www': 'https://www.virwox.com',
        'doc': 'https://www.virwox.com/developers.php',
    },
    'api': {
        'public': {
            'get': [
                'getInstruments',
                'getBestPrices',
                'getMarketDepth',
                'estimateMarketOrder',
                'getTradedPriceVolume',
                'getRawTradeData',
                'getStatistics',
                'getTerminalList',
                'getGridList',
                'getGridStatistics',
            ],
            'post': [
                'getInstruments',
                'getBestPrices',
                'getMarketDepth',
                'estimateMarketOrder',
                'getTradedPriceVolume',
                'getRawTradeData',
                'getStatistics',
                'getTerminalList',
                'getGridList',
                'getGridStatistics',
            ],
        },
        'private': {
            'get': [
                'cancelOrder',
                'getBalances',
                'getCommissionDiscount',
                'getOrders',
                'getTransactions',
                'placeOrder',
            ],
            'post': [
                'cancelOrder',
                'getBalances',
                'getCommissionDiscount',
                'getOrders',
                'getTransactions',
                'placeOrder',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetInstruments ();
        let keys = Object.keys (markets['result']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let market = markets['result'][keys[p]];
            let id = market['instrumentID'];
            let symbol = market['symbol'];
            let base = market['longCurrency'];
            let quote = market['shortCurrency'];
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetBalances ();
        let balances = response['result']['accountList'];
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['currency'];
            let total = balance['balance'];
            let account = {
                'free': total,
                'used': 0.0,
                'total': total,
            };
            result[currency] = account;
        }
        return result;
    },

    async fetchBestPrices (symbol) {
        await this.loadMarkets ();
        return await this.publicPostGetBestPrices ({
            'symbols': [ symbol ],
        });
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let response = await this.publicPostGetMarketDepth (this.extend ({
            'symbols': [ symbol ],
            'buyDepth': 100,
            'sellDepth': 100,
        }, params));
        let orderbook = response['result'][0];
        return this.parseOrderBook (orderbook, undefined, 'buy', 'sell', 'price', 'volume');
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let end = this.milliseconds ();
        let start = end - 86400000;
        let response = await this.publicGetTradedPriceVolume ({
            'instrument': symbol,
            'endDate': this.YmdHMS (end),
            'startDate': this.YmdHMS (start),
            'HLOC': 1,
        });
        let tickers = response['result']['priceVolumeList'];
        let keys = Object.keys (tickers);
        let length = keys.length;
        let lastKey = keys[length - 1];
        let ticker = tickers[lastKey];
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': undefined,
            'ask': undefined,
            'vwap': undefined,
            'open': parseFloat (ticker['open']),
            'close': parseFloat (ticker['close']),
            'first': undefined,
            'last': undefined,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': parseFloat (ticker['longVolume']),
            'quoteVolume': parseFloat (ticker['shortVolume']),
            'info': ticker,
        };
    },

    async fetchTrades (market, params = {}) {
        await this.loadMarkets ();
        return await this.publicGetRawTradeData(this.extend ({
            'instrument': market,
            'timespan': 3600,
        }, params));
    },

    async createOrder (market, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        let order = {
            'instrument': this.symbol (market),
            'orderType': side.toUpperCase (),
            'amount': amount,
        };
        if (type == 'limit')
            order['price'] = price;
        let response = await this.privatePostPlaceOrder (this.extend (order, params));
        return {
            'info': response,
            'id': response['orderID'].toString (),
        };
    },

    cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'orderID': id,
        }, params));
    },

    async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'][api];
        let auth = {};
        if (api == 'private') {
            auth['key'] = this.apiKey;
            auth['user'] = this.login;
            auth['pass'] = this.password;
        }
        let nonce = this.nonce ();
        if (method == 'GET') {
            url += '?' + this.urlencode (this.extend ({
                'method': path,
                'id': nonce,
            }, auth, params));
        } else {
            headers = { 'Content-Type': 'application/json' };
            body = this.json ({
                'method': path,
                'params': this.extend (auth, params),
                'id': nonce,
            });
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            if (response['error'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var wex = extend (liqui, {

    'id': 'wex',
    'name': 'WEX',
    'countries': 'NZ', // New Zealand
    'version': '3',
    'hasFetchTickers': true,
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/30652751-d74ec8f8-9e31-11e7-98c5-71469fcef03e.jpg',
        'api': {
            'public': 'https://wex.nz/api',
            'private': 'https://wex.nz/tapi',
        },
        'www': 'https://wex.nz',
        'doc': [
            'https://wex.nz/api/3/docs',
            'https://wex.nz/tapi/docs',
        ],
    },
    'api': {
        'public': {
            'get': [
                'info',
                'ticker/{pair}',
                'depth/{pair}',
                'trades/{pair}',
            ],
        },
        'private': {
            'post': [
                'getInfo',
                'Trade',
                'ActiveOrders',
                'OrderInfo',
                'CancelOrder',
                'TradeHistory',
                'TransHistory',
                'CoinDepositAddress',
                'WithdrawCoin',
                'CreateCoupon',
                'RedeemCoupon',
            ],
        }
    },
})

//-----------------------------------------------------------------------------

var xbtce = {

    'id': 'xbtce',
    'name': 'xBTCe',
    'countries': 'RU',
    'rateLimit': 2000, // responses are cached every 2 seconds
    'version': 'v1',
    'hasPublicAPI': false,
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28059414-e235970c-662c-11e7-8c3a-08e31f78684b.jpg',
        'api': 'https://cryptottlivewebapi.xbtce.net:8443/api',
        'www': 'https://www.xbtce.com',
        'doc': [
            'https://www.xbtce.com/tradeapi',
            'https://support.xbtce.info/Knowledgebase/Article/View/52/25/xbtce-exchange-api',
        ],
    },
    'api': {
        'public': {
            'get': [
                'currency',
                'currency/{filter}',
                'level2',
                'level2/{filter}',
                'quotehistory/{symbol}/{periodicity}/bars/ask',
                'quotehistory/{symbol}/{periodicity}/bars/bid',
                'quotehistory/{symbol}/level2',
                'quotehistory/{symbol}/ticks',
                'symbol',
                'symbol/{filter}',
                'tick',
                'tick/{filter}',
                'ticker',
                'ticker/{filter}',
                'tradesession',
            ],
        },
        'private': {
            'get': [
                'tradeserverinfo',
                'tradesession',
                'currency',
                'currency/{filter}',
                'level2',
                'level2/{filter}',
                'symbol',
                'symbol/{filter}',
                'tick',
                'tick/{filter}',
                'account',
                'asset',
                'asset/{id}',
                'position',
                'position/{id}',
                'trade',
                'trade/{id}',
                'quotehistory/{symbol}/{periodicity}/bars/ask',
                'quotehistory/{symbol}/{periodicity}/bars/ask/info',
                'quotehistory/{symbol}/{periodicity}/bars/bid',
                'quotehistory/{symbol}/{periodicity}/bars/bid/info',
                'quotehistory/{symbol}/level2',
                'quotehistory/{symbol}/level2/info',
                'quotehistory/{symbol}/periodicities',
                'quotehistory/{symbol}/ticks',
                'quotehistory/{symbol}/ticks/info',
                'quotehistory/cache/{symbol}/{periodicity}/bars/ask',
                'quotehistory/cache/{symbol}/{periodicity}/bars/bid',
                'quotehistory/cache/{symbol}/level2',
                'quotehistory/cache/{symbol}/ticks',
                'quotehistory/symbols',
                'quotehistory/version',
            ],
            'post': [
                'trade',
                'tradehistory',
            ],
            'put': [
                'trade',
            ],
            'delete': [
                'trade',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.privateGetSymbol ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['Symbol'];
            let base = market['MarginCurrency'];
            let quote = market['ProfitCurrency'];
            if (base == 'DSH')
                base = 'DASH';
            let symbol = base + '/' + quote;
            symbol = market['IsTradeAllowed'] ? symbol : id;
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let balances = await this.privateGetAsset ();
        let result = { 'info': balances };
        for (let b = 0; b < balances.length; b++) {
            let balance = balances[b];
            let currency = balance['Currency'];
            let uppercase = currency.toUpperCase ();
            // xbtce names DASH incorrectly as DSH
            if (uppercase == 'DSH')
                uppercase = 'DASH';
            let total = balance['balance'];
            let account = {
                'free': balance['FreeAmount'],
                'used': balance['LockedAmount'],
                'total': balance['Amount'],
            };
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let orderbook = await this.privateGetLevel2Filter (this.extend ({
            'filter': market['id'],
        }, params));
        orderbook = orderbook[0];
        let timestamp = orderbook['Timestamp'];
        return this.parseOrderBook (orderbook, timestamp, 'Bids', 'Asks', 'Price', 'Volume');
    },

    parseTicker (ticker, market) {
        let timestamp = 0;
        let last = undefined;
        if ('LastBuyTimestamp' in ticker)
            if (timestamp < ticker['LastBuyTimestamp']) {
                timestamp = ticker['LastBuyTimestamp'];
                last = ticker['LastBuyPrice'];
            }
        if ('LastSellTimestamp' in ticker)
            if (timestamp < ticker['LastSellTimestamp']) {
                timestamp = ticker['LastSellTimestamp'];
                last = ticker['LastSellPrice'];
            }
        if (!timestamp)
            timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['DailyBestBuyPrice'],
            'low': ticker['DailyBestSellPrice'],
            'bid': ticker['BestBid'],
            'ask': ticker['BestAsk'],
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': last,
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': ticker['DailyTradedTotalVolume'],
            'info': ticker,
        };
    },

    async fetchTickers () {
        await this.loadMarkets ();
        let tickers = await this.publicGetTicker ();
        tickers = this.indexBy (tickers, 'Symbol');
        let ids = Object.keys (tickers);
        let result = {};
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let market = undefined;
            let symbol = undefined;
            if (id in this.markets_by_id) {
                market = this.markets_by_id[id];
                symbol = market['symbol'];
            } else {
                let base = id.slice (0, 3);
                let quote = id.slice (3, 6);
                if (base == 'DSH')
                    base = 'DASH';
                if (quote == 'DSH')
                    quote = 'DASH';
                symbol = base + '/' + quote;
            }
            let ticker = tickers[id];
            result[symbol] = this.parseTicker (ticker, market);
        }
        return result;
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.publicGetTickerFilter ({
            'filter': market['id'],
        });
        let length = tickers.length;
        if (length < 1)
            throw new ExchangeError (this.id + ' fetchTicker returned empty response, xBTCe public API error');
        tickers = this.indexBy (tickers, 'Symbol');
        let ticker = tickers[market['id']];
        return this.parseTicker (ticker, market);
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        // no method for trades?
        return await this.privateGetTrade (params);
    },

    parseOHLCV (ohlcv, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
        return [
            ohlcv['Timestamp'],
            ohlcv['Open'],
            ohlcv['High'],
            ohlcv['Low'],
            ohlcv['Close'],
            ohlcv['Volume'],
        ];
    },

    async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
        throw new NotSupported (this.id + ' fetchOHLCV is disabled by the exchange');
        let minutes = parseInt (timeframe / 60); // 1 minute by default
        let periodicity = minutes.toString ();
        await this.loadMarkets ();
        let market = this.market (symbol);
        if (!since)
            since = this.seconds () - 86400 * 7; // last day by defulat
        if (!limit)
            limit = 1000; // default
        let response = await this.privateGetQuotehistorySymbolPeriodicityBarsBid (this.extend ({
            'symbol': market['id'],
            'periodicity': '5m', // periodicity,
            'timestamp': since,
            'count': limit,
        }, params));
        return this.parseOHLCVs (response['Bars'], market, timeframe, since, limit);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.tapiPostTrade (this.extend ({
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price,
        }, params));
        return {
            'info': response,
            'id': response['Id'].toString (),
        };
    },

    cancelOrder (id, params = {}) {
        return this.privateDeleteTrade (this.extend ({
            'Type': 'Cancel',
            'Id': id,
        }, params));
    },

    nonce () {
        return this.milliseconds ();
    },

    request (path, api = 'api', method = 'GET', params = {}, headers = undefined, body = undefined) {
        if (!this.apiKey)
            throw new AuthenticationError (this.id + ' requires apiKey for all requests, their public API is always busy');
        if (!this.uid)
            throw new AuthenticationError (this.id + ' requires uid property for authentication and trading');
        let url = this.urls['api'] + '/' + this.version;
        if (api == 'public')
            url += '/' + api;
        url += '/' + this.implodeParams (path, params);
        let query = this.omit (params, this.extractParams (path));
        if (api == 'public') {
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            headers = { 'Accept-Encoding': 'gzip, deflate' };
            let nonce = this.nonce ().toString ();
            if (method == 'POST') {
                if (Object.keys (query).length) {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                }
                else
                    url += '?' + this.urlencode (query);
            }
            let auth = nonce + this.uid + this.apiKey + method + url;
            if (body)
                auth += body;
            let signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
            let credentials = this.uid + ':' + this.apiKey + ':' + nonce + ':' + this.binaryToString (signature);
            headers['Authorization'] = 'HMAC ' + credentials;
        }
        return this.fetch (url, method, headers, body);
    },
}

//-----------------------------------------------------------------------------

var yobit = {

    'id': 'yobit',
    'name': 'YoBit',
    'countries': 'RU',
    'rateLimit': 2000, // responses are cached every 2 seconds
    'version': '3',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766910-cdcbfdae-5eea-11e7-9859-03fea873272d.jpg',
        'api': 'https://yobit.net',
        'www': 'https://www.yobit.net',
        'doc': 'https://www.yobit.net/en/api/',
    },
    'api': {
        'api': {
            'get': [
                'depth/{pairs}',
                'info',
                'ticker/{pairs}',
                'trades/{pairs}',
            ],
        },
        'tapi': {
            'post': [
                'ActiveOrders',
                'CancelOrder',
                'GetDepositAddress',
                'getInfo',
                'OrderInfo',
                'Trade',
                'TradeHistory',
                'WithdrawCoinsToAddress',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.apiGetInfo ();
        let keys = Object.keys (markets['pairs']);
        let result = [];
        for (let p = 0; p < keys.length; p++) {
            let id = keys[p];
            let market = markets['pairs'][id];
            let symbol = id.toUpperCase ().replace ('_', '/');
            let [ base, quote ] = symbol.split ('/');
            base = this.commonCurrencyCode (base);
            quote = this.commonCurrencyCode (quote);
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.tapiPostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        for (let c = 0; c < this.currencies.length; c++) {
            let currency = this.currencies[c];
            let lowercase = currency.toLowerCase ();
            let account = this.account ();
            if ('funds' in balances)
                if (lowercase in balances['funds'])
                    account['free'] = balances['funds'][lowercase];
            if ('funds_incl_orders' in balances)
                if (lowercase in balances['funds_incl_orders'])
                    account['total'] = balances['funds_incl_orders'][lowercase];
            if (account['total'] && account['free'])
                account['used'] = account['total'] - account['free'];
            result[currency] = account;
        }
        return result;
    },

    async fetchOrderBook (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.apiGetDepthPairs (this.extend ({
            'pairs': market['id'],
        }, params));
        let orderbook = response[market['id']];
        let timestamp = this.milliseconds ();
        let bids = ('bids' in orderbook) ? orderbook['bids'] : [];
        let asks = ('asks' in orderbook) ? orderbook['asks'] : [];
        return {
            'bids': bids,
            'asks': asks,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
        };
    },

    async fetchTicker (symbol) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let tickers = await this.apiGetTickerPairs ({
            'pairs': market['id'],
        });
        let ticker = tickers[market['id']];
        let timestamp = ticker['updated'] * 1000;
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': parseFloat (ticker['high']),
            'low': parseFloat (ticker['low']),
            'bid': parseFloat (ticker['buy']),
            'ask': parseFloat (ticker['sell']),
            'vwap': undefined,
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': parseFloat (ticker['last']),
            'change': undefined,
            'percentage': undefined,
            'average': parseFloat (ticker['avg']),
            'baseVolume': parseFloat (ticker['vol_cur']),
            'quoteVolume': parseFloat (ticker['vol']),
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let timestamp = trade['timestamp'] * 1000;
        let side = (trade['type'] == 'bid') ? 'buy' : 'sell';
        return {
            'info': trade,
            'id': trade['tid'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.apiGetTradesPairs (this.extend ({
            'pairs': market['id'],
        }, params));
        return this.parseTrades (response[market['id']], market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let rate = price.toString ();
        let response = await this.tapiPostTrade (this.extend ({
            'pair': this.marketId (symbol),
            'type': side,
            'amount': amount,
            'rate': price.toFixed (8),
        }, params));
        return {
            'info': response,
            'id': response['return']['order_id'].toString (),
        };
    },

    cancelOrder (id, params = {}) {
        return this.tapiPostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        let result = await this.tapiPostWithdrawCoinsToAddress (this.extend ({
            'coinName': currency,
            'amount': amount,
            'address': address,
        }, params));
        return {
            'info': result,
            'id': undefined,
        };
    },

    async request (path, api = 'api', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/' + api;
        if (api == 'api') {
            url += '/' + this.version + '/' + this.implodeParams (path, params);
            let query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length)
                url += '?' + this.urlencode (query);
        } else {
            let nonce = this.nonce ();
            let query = this.extend ({ 'method': path, 'nonce': nonce }, params);
            body = this.urlencode (query);
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'key': this.apiKey,
                'sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//-----------------------------------------------------------------------------

var yunbi = extend (acx, {

    'id': 'yunbi',
    'name': 'YUNBI',
    'countries': 'CN',
    'rateLimit': 1000,
    'version': 'v2',
    'hasCORS': false,
    'hasFetchTickers': true,
    'hasFetchOHLCV': true,
    'timeframes': {
        '1m': '1',
        '5m': '5',
        '15m': '15',
        '30m': '30',
        '1h': '60',
        '2h': '120',
        '4h': '240',
        '12h': '720',
        '1d': '1440',
        '3d': '4320',
        '1w': '10080',
    },
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/28570548-4d646c40-7147-11e7-9cf6-839b93e6d622.jpg',
        'api': 'https://yunbi.com',
        'www': 'https://yunbi.com',
        'doc': [
            'https://yunbi.com/documents/api/guide',
            'https://yunbi.com/swagger/',
        ],
    },
    'api': {
        'public': {
            'get': [
                'tickers',
                'tickers/{market}',
                'markets',
                'order_book',
                'k',
                'depth',
                'trades',
                'k_with_pending_trades',
                'timestamp',
                'addresses/{address}',
                'partners/orders/{id}/trades',
            ],
        },
        'private': {
            'get': [
                'deposits',
                'members/me',
                'deposit',
                'deposit_address',
                'order',
                'orders',
                'trades/my',
            ],
            'post': [
                'order/delete',
                'orders',
                'orders/multi',
                'orders/clear',
            ],
        },
    },
})

//-----------------------------------------------------------------------------

var zaif = {

    'id': 'zaif',
    'name': 'Zaif',
    'countries': 'JP',
    'rateLimit': 2000,
    'version': '1',
    'hasCORS': false,
    'urls': {
        'logo': 'https://user-images.githubusercontent.com/1294454/27766927-39ca2ada-5eeb-11e7-972f-1b4199518ca6.jpg',
        'api': 'https://api.zaif.jp',
        'www': 'https://zaif.jp',
        'doc': [
            'http://techbureau-api-document.readthedocs.io/ja/latest/index.html',
            'https://corp.zaif.jp/api-docs',
            'https://corp.zaif.jp/api-docs/api_links',
            'https://www.npmjs.com/package/zaif.jp',
            'https://github.com/you21979/node-zaif',
        ],
    },
    'api': {
        'public': {
            'get': [
                'depth/{pair}',
                'currencies/{pair}',
                'currencies/all',
                'currency_pairs/{pair}',
                'currency_pairs/all',
                'last_price/{pair}',
                'ticker/{pair}',
                'trades/{pair}',
            ],
        },
        'private': {
            'post': [
                'active_orders',
                'cancel_order',
                'deposit_history',
                'get_id_info',
                'get_info',
                'get_info2',
                'get_personal_info',
                'trade',
                'trade_history',
                'withdraw',
                'withdraw_history',
            ],
        },
        'ecapi': {
            'post': [
                'createInvoice',
                'getInvoice',
                'getInvoiceIdsByOrderNumber',
                'cancelInvoice',
            ],
        },
    },

    async fetchMarkets () {
        let markets = await this.publicGetCurrencyPairsAll ();
        let result = [];
        for (let p = 0; p < markets.length; p++) {
            let market = markets[p];
            let id = market['currency_pair'];
            let symbol = market['name'];
            let [ base, quote ] = symbol.split ('/');
            result.push ({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': market,
            });
        }
        return result;
    },

    async fetchBalance (params = {}) {
        await this.loadMarkets ();
        let response = await this.privatePostGetInfo ();
        let balances = response['return'];
        let result = { 'info': balances };
        let currencies = Object.keys (balances['funds']);
        for (let c = 0; c < currencies.length; c++) {
            let currency = currencies[c];
            let balance = balances['funds'][currency];
            let uppercase = currency.toUpperCase ();
            let account = {
                'free': balance,
                'used': 0.0,
                'total': balance,
            };
            if ('deposit' in balances) {
                if (currency in balances['deposit']) {
                    account['total'] = balances['deposit'][currency];
                    account['used'] = account['total'] - account['free'];
                }
            }
            result[uppercase] = account;
        }
        return result;
    },

    async fetchOrderBook (market, params = {}) {
        await this.loadMarkets ();
        let orderbook = await this.publicGetDepthPair (this.extend ({
            'pair': this.marketId (market),
        }, params));
        return this.parseOrderBook (orderbook);
    },

    async fetchTicker (market) {
        await this.loadMarkets ();
        let ticker = await this.publicGetTickerPair ({
            'pair': this.marketId (market),
        });
        let timestamp = this.milliseconds ();
        return {
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'high': ticker['high'],
            'low': ticker['low'],
            'bid': ticker['bid'],
            'ask': ticker['ask'],
            'vwap': ticker['vwap'],
            'open': undefined,
            'close': undefined,
            'first': undefined,
            'last': ticker['last'],
            'change': undefined,
            'percentage': undefined,
            'average': undefined,
            'baseVolume': undefined,
            'quoteVolume': ticker['volume'],
            'info': ticker,
        };
    },

    parseTrade (trade, market = undefined) {
        let side = (trade['trade_type'] == 'bid') ? 'buy' : 'sell';
        let timestamp = trade['date'] * 1000;
        let id = undefined;
        if ('id' in trade) {
            id = trade['id'];
        } else if ('tid' in trade) {
            id = trade['tid'];
        }
        if (!market)
            market = this.markets_by_id[trade['currency_pair']];
        return {
            'id': id.toString (),
            'info': trade,
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'symbol': market['symbol'],
            'type': undefined,
            'side': side,
            'price': trade['price'],
            'amount': trade['amount'],
        };
    },

    async fetchTrades (symbol, params = {}) {
        await this.loadMarkets ();
        let market = this.market (symbol);
        let response = await this.publicGetTradesPair (this.extend ({
            'pair': market['id'],
        }, params));
        return this.parseTrades (response, market);
    },

    async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
        await this.loadMarkets ();
        if (type == 'market')
            throw new ExchangeError (this.id + ' allows limit orders only');
        let response = await this.privatePostTrade (this.extend ({
            'currency_pair': this.marketId (symbol),
            'action': (side == 'buy') ? 'bid' : 'ask',
            'amount': amount,
            'price': price,
        }, params));
        return {
            'info': response,
            'id': response['return']['order_id'].toString (),
        };
    },

    cancelOrder (id, params = {}) {
        return this.privatePostCancelOrder (this.extend ({
            'order_id': id,
        }, params));
    },

    parseOrder (order, market = undefined) {
        let side = (order['action'] == 'bid') ? 'buy' : 'sell';
        let timestamp = parseInt (order['timestamp']) * 1000;
        if (!market)
            market = this.markets_by_id[order['currency_pair']];
        return {
            'id': order['id'].toString (),
            'timestamp': timestamp,
            'datetime': this.iso8601 (timestamp),
            'status': 'open',
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': order['price'],
            'amount': order['amount'],
            'trades': undefined,
        };
    },

    parseOrders (orders, market = undefined) {
        let ids = Object.keys (orders);
        let result = [];
        for (let i = 0; i < ids.length; i++) {
            let id = ids[i];
            let order = orders[id];
            let extended = this.extend (order, { 'id': id });
            result.push (this.parseOrder (extended, market));
        }
        return result;
    },

    async fetchOpenOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        // let request = {
        //     'is_token': false,
        //     'is_token_both': false,
        // };
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostActiveOrders (this.extend (request, params));
        return this.parseOrders (response['return'], market);
    },

    async fetchClosedOrders (symbol = undefined, params = {}) {
        await this.loadMarkets ();
        let market = undefined;
        // let request = {
        //     'from': 0,
        //     'count': 1000,
        //     'from_id': 0,
        //     'end_id': 1000,
        //     'order': 'DESC',
        //     'since': 1503821051,
        //     'end': 1503821051,
        //     'is_token': false,
        // };
        let request = {};
        if (symbol) {
            market = this.market (symbol);
            request['currency_pair'] = market['id'];
        }
        let response = await this.privatePostTradeHistory (this.extend (request, params));
        return this.parseOrders (response['return'], market);
    },

    async withdraw (currency, amount, address, params = {}) {
        await this.loadMarkets ();
        if (currency == 'JPY')
            throw new ExchangeError (this.id + ' does not allow ' + currency + ' withdrawals');
        let result = await this.privatePostWithdraw (this.extend ({
            'currency': currency,
            'amount': amount,
            'address': address,
            // 'message': 'Hi!', // XEM only
            // 'opt_fee': 0.003, // BTC and MONA only
        }, params));
        return {
            'info': result,
            'id': result['return']['txid'],
            'fee': result['return']['fee'],
        };
    },

    async request (path, api = 'api', method = 'GET', params = {}, headers = undefined, body = undefined) {
        let url = this.urls['api'] + '/';
        if (api == 'public') {
            url += 'api/' + this.version + '/' + this.implodeParams (path, params);
        } else {
            url += (api == 'ecapi') ? 'ecapi' : 'tapi';
            let nonce = this.nonce ();
            body = this.urlencode (this.extend ({
                'method': path,
                'nonce': nonce,
            }, params));
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Key': this.apiKey,
                'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
            };
        }
        let response = await this.fetch (url, method, headers, body);
        if ('error' in response)
            throw new ExchangeError (this.id + ' ' + response['error']);
        if ('success' in response)
            if (!response['success'])
                throw new ExchangeError (this.id + ' ' + this.json (response));
        return response;
    },
}

//=============================================================================

var exchanges = {

    '_1broker':          _1broker,
    '_1btcxe':           _1btcxe,
    'acx':                acx,
    'anxpro':             anxpro,
    'binance':            binance,
    'bit2c':              bit2c,
    'bitbay':             bitbay,
    'bitcoincoid':        bitcoincoid,
    'bitfinex':           bitfinex,
    'bitfinex2':          bitfinex2,
    'bitflyer':           bitflyer,
    'bithumb':            bithumb,
    'bitlish':            bitlish,
    'bitmarket':          bitmarket,
    'bitmex':             bitmex,
    'bitso':              bitso,
    'bitstamp1':          bitstamp1,
    'bitstamp':           bitstamp,
    'bittrex':            bittrex,
    'bl3p':               bl3p,
    'bleutrade':          bleutrade,
    'btcchina':           btcchina,
    'btcexchange':        btcexchange,
    'btcmarkets':         btcmarkets,
    'btctradeua':         btctradeua,
    'btcturk':            btcturk,
    'btcx':               btcx,
    'bter':               bter,
    'bxinth':             bxinth,
    'ccex':               ccex,
    'cex':                cex,
    'chbtc':              chbtc,
    'chilebit':           chilebit,
    'coincheck':          coincheck,
    'coinfloor':          coinfloor,
    'coingi':             coingi,
    'coinmarketcap':      coinmarketcap,
    'coinmate':           coinmate,
    'coinsecure':         coinsecure,
    'coinspot':           coinspot,
    'cryptopia':          cryptopia,
    'dsx':                dsx,
    'exmo':               exmo,
    'flowbtc':            flowbtc,
    'foxbit':             foxbit,
    'fybse':              fybse,
    'fybsg':              fybsg,
    'gatecoin':           gatecoin,
    'gdax':               gdax,
    'gemini':             gemini,
    'hitbtc':             hitbtc,
    'hitbtc2':            hitbtc2,
    'huobi':              huobi,
    'huobicny':           huobicny,
    'huobipro':           huobipro,
    'independentreserve': independentreserve,
    'itbit':              itbit,
    'jubi':               jubi,
    'kraken':             kraken,
    'lakebtc':            lakebtc,
    'livecoin':           livecoin,
    'liqui':              liqui,
    'luno':               luno,
    'mercado':            mercado,
    'mixcoins':           mixcoins,
    'nova':               nova,
    'okcoincny':          okcoincny,
    'okcoinusd':          okcoinusd,
    'okex':               okex,
    'paymium':            paymium,
    'poloniex':           poloniex,
    'quadrigacx':         quadrigacx,
    'quoine':             quoine,
    'southxchange':       southxchange,
    'surbitcoin':         surbitcoin,
    'therock':            therock,
    'urdubit':            urdubit,
    'vaultoro':           vaultoro,
    'vbtc':               vbtc,
    'virwox':             virwox,
    'wex':                wex,
    'xbtce':              xbtce,
    'yobit':              yobit,
    'yunbi':              yunbi,
    'zaif':               zaif,
}

let defineAllExchanges = function (exchanges) {
    let result = {}
    for (let id in exchanges) {
        result[id] = function (params) {
            return new Exchange (extend (exchanges[id], params))
        }
    }
    result.exchanges = Object.keys (exchanges)
    return result
}

//-----------------------------------------------------------------------------

const ccxt = Object.assign (defineAllExchanges (exchanges), {

    version,

    // Exchange constructor (do not use directly, will be replaced by a class soon)

    Exchange,

    // exceptions

    CCXTError,
    ExchangeError,
    NotSupported,
    AuthenticationError,
    InsufficientFunds,
    NetworkError,
    DDoSProtection,
    RequestTimeout,
    ExchangeNotAvailable,

    // common utility functions

    sleep,
    timeout,
    capitalize,
    keysort,
    extend,
    omit,
    indexBy,
    sortBy,
    flatten,
    unique,
    pluck,
    urlencode,
    sum,
    decimal,
    safeFloat,

    // underscore aliases

    index_by: indexBy,
    sort_by: sortBy,

    // crypto functions

    binaryConcat,
    stringToBinary,
    binaryToString,
    stringToBase64,
    utf16ToBase64,
    base64ToBinary,
    base64ToString,
    urlencodeBase64,
    hash,
    hmac,
    jwt,

})

//-----------------------------------------------------------------------------

if (isCommonJS) {

    module.exports = ccxt

} else {

    window.ccxt = ccxt
}

//-----------------------------------------------------------------------------

}) () // end of namespace

}).call(this,require('_process'))

},{"_process":37,"crypto-js":11,"qs":39}],3:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));
},{"./cipher-core":4,"./core":5,"./enc-base64":6,"./evpkdf":8,"./md5":13}],4:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./evpkdf"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./evpkdf"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));
},{"./core":5,"./evpkdf":8}],5:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
},{}],6:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));
},{"./core":5}],7:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));
},{"./core":5}],8:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));
},{"./core":5,"./hmac":10,"./sha1":29}],9:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));
},{"./cipher-core":4,"./core":5}],10:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));
},{"./core":5}],11:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	return CryptoJS;

}));
},{"./aes":3,"./cipher-core":4,"./core":5,"./enc-base64":6,"./enc-utf16":7,"./evpkdf":8,"./format-hex":9,"./hmac":10,"./lib-typedarrays":12,"./md5":13,"./mode-cfb":14,"./mode-ctr":16,"./mode-ctr-gladman":15,"./mode-ecb":17,"./mode-ofb":18,"./pad-ansix923":19,"./pad-iso10126":20,"./pad-iso97971":21,"./pad-nopadding":22,"./pad-zeropadding":23,"./pbkdf2":24,"./rabbit":26,"./rabbit-legacy":25,"./rc4":27,"./ripemd160":28,"./sha1":29,"./sha224":30,"./sha256":31,"./sha3":32,"./sha384":33,"./sha512":34,"./tripledes":35,"./x64-core":36}],12:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));
},{"./core":5}],13:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));
},{"./core":5}],14:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	return CryptoJS.mode.CFB;

}));
},{"./cipher-core":4,"./core":5}],15:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	return CryptoJS.mode.CTRGladman;

}));
},{"./cipher-core":4,"./core":5}],16:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	return CryptoJS.mode.CTR;

}));
},{"./cipher-core":4,"./core":5}],17:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	return CryptoJS.mode.ECB;

}));
},{"./cipher-core":4,"./core":5}],18:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	return CryptoJS.mode.OFB;

}));
},{"./cipher-core":4,"./core":5}],19:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Ansix923;

}));
},{"./cipher-core":4,"./core":5}],20:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	return CryptoJS.pad.Iso10126;

}));
},{"./cipher-core":4,"./core":5}],21:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	return CryptoJS.pad.Iso97971;

}));
},{"./cipher-core":4,"./core":5}],22:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	return CryptoJS.pad.NoPadding;

}));
},{"./cipher-core":4,"./core":5}],23:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS.pad.ZeroPadding;

}));
},{"./cipher-core":4,"./core":5}],24:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha1", "./hmac"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.PBKDF2;

}));
},{"./core":5,"./hmac":10,"./sha1":29}],25:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	return CryptoJS.RabbitLegacy;

}));
},{"./cipher-core":4,"./core":5,"./enc-base64":6,"./evpkdf":8,"./md5":13}],26:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	return CryptoJS.Rabbit;

}));
},{"./cipher-core":4,"./core":5,"./enc-base64":6,"./evpkdf":8,"./md5":13}],27:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	return CryptoJS.RC4;

}));
},{"./cipher-core":4,"./core":5,"./enc-base64":6,"./evpkdf":8,"./md5":13}],28:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	return CryptoJS.RIPEMD160;

}));
},{"./core":5}],29:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));
},{"./core":5}],30:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./sha256"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./sha256"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	return CryptoJS.SHA224;

}));
},{"./core":5,"./sha256":31}],31:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));
},{"./core":5}],32:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	return CryptoJS.SHA3;

}));
},{"./core":5,"./x64-core":36}],33:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core", "./sha512"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	return CryptoJS.SHA384;

}));
},{"./core":5,"./sha512":34,"./x64-core":36}],34:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./x64-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./x64-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	return CryptoJS.SHA512;

}));
},{"./core":5,"./x64-core":36}],35:[function(require,module,exports){
;(function (root, factory, undef) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	return CryptoJS.TripleDES;

}));
},{"./cipher-core":4,"./core":5,"./enc-base64":6,"./evpkdf":8,"./md5":13}],36:[function(require,module,exports){
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	return CryptoJS;

}));
},{"./core":5}],37:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],38:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],39:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":38,"./parse":40,"./stringify":41}],40:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function parseObjectRecursive(chain, val, options) {
    if (!chain.length) {
        return val;
    }

    var root = chain.shift();

    var obj;
    if (root === '[]') {
        obj = [];
        obj = obj.concat(parseObject(chain, val, options));
    } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
        var index = parseInt(cleanRoot, 10);
        if (
            !isNaN(index)
            && root !== cleanRoot
            && String(index) === cleanRoot
            && index >= 0
            && (options.parseArrays && index <= options.arrayLimit)
        ) {
            obj = [];
            obj[index] = parseObject(chain, val, options);
        } else {
            obj[cleanRoot] = parseObject(chain, val, options);
        }
    }

    return obj;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

module.exports = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":42}],41:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

module.exports = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats.default;
    } else if (!Object.prototype.hasOwnProperty.call(formats.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":38,"./utils":42}],42:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

exports.arrayToObject = function (source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

exports.merge = function (target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = exports.arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = exports.merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = exports.merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

exports.assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

exports.decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

exports.encode = function (str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D    // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

exports.compact = function (obj, references) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }

    var refs = references || [];
    var lookup = refs.indexOf(obj);
    if (lookup !== -1) {
        return refs[lookup];
    }

    refs.push(obj);

    if (Array.isArray(obj)) {
        var compacted = [];

        for (var i = 0; i < obj.length; ++i) {
            if (obj[i] && typeof obj[i] === 'object') {
                compacted.push(exports.compact(obj[i], refs));
            } else if (typeof obj[i] !== 'undefined') {
                compacted.push(obj[i]);
            }
        }

        return compacted;
    }

    var keys = Object.keys(obj);
    keys.forEach(function (key) {
        obj[key] = exports.compact(obj[key], refs);
    });

    return obj;
};

exports.isRegExp = function (obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

exports.isBuffer = function (obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjY3h0LmJyb3dzZXIuanMiLCJjY3h0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9hZXMuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NpcGhlci1jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9lbmMtdXRmMTYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2V2cGtkZi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvZm9ybWF0LWhleC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL2xpYi10eXBlZGFycmF5cy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbWQ1LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLWNmYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHItZ2xhZG1hbi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvbW9kZS1jdHIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL21vZGUtZWNiLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tb2RlLW9mYi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLWFuc2l4OTIzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYWQtaXNvMTAxMjYuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3BhZC1pc285Nzk3MS5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLW5vcGFkZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcGFkLXplcm9wYWRkaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9wYmtkZjIuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC1sZWdhY3kuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3JhYmJpdC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvcmM0LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9yaXBlbWQxNjAuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTEuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTIyNC5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvc2hhMjU2LmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy9zaGEzODQuanMiLCJub2RlX21vZHVsZXMvY3J5cHRvLWpzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9jcnlwdG8tanMvdHJpcGxlZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NyeXB0by1qcy94NjQtY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMiLCJub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3FzL2xpYi91dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeHRsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdnZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDandCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogIEEgZW50cnkgcG9pbnQgZm9yIHRoZSBicm93c2VyIGJ1bmRsZSB2ZXJzaW9uLiBUaGlzIGdldHMgY29tcGlsZWQgYnk6XG4gICAgICAgIFxuICAgICAgICBicm93c2VyaWZ5IC0tZGVidWcgLi9jY3h0LmJyb3dzZXIuanMgPiAuL2J1aWxkL2NjeHQuYnJvd3Nlci5qc1xuICovXG5cbndpbmRvdy5jY3h0ID0gcmVxdWlyZSAoJy4vY2N4dCcpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG5cbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNyBJZ29yIEtyb2l0b3JcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBkZXBlbmRlbmNpZXNcblxuY29uc3QgQ3J5cHRvSlMgPSByZXF1aXJlICgnY3J5cHRvLWpzJylcbiAgICAsIHFzICAgICAgID0gcmVxdWlyZSAoJ3FzJykgLy8gcXVlcnlzdHJpbmdcbiAgICAvLyAsIHdzICAgICAgID0gcmVxdWlyZSAoJ3dzJykgLy8gd2Vic29ja2V0XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRoaXMgaXMgdXBkYXRlZCBieSB2c3MuanMgd2hlbiBidWlsZGluZ1xuXG5jb25zdCB2ZXJzaW9uID0gJzEuNy4xMjMnXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHBsYXRmb3JtIGRldGVjdGlvblxuXG5jb25zdCBpc05vZGUgICAgID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICwgaXNDb21tb25KUyA9ICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jbGFzcyBDQ1hURXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIC8vIGEgd29ya2Fyb3VuZCB0byBtYWtlIGBpbnN0YW5jZW9mIENDWFRFcnJvcmAgd29yayBpbiBFUzVcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IENDWFRFcnJvclxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gQ0NYVEVycm9yLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgRXhjaGFuZ2VFcnJvciBleHRlbmRzIENDWFRFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBFeGNoYW5nZUVycm9yXG4gICAgICAgIHRoaXMuX19wcm90b19fICAgPSBFeGNoYW5nZUVycm9yLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgTm90U3VwcG9ydGVkIGV4dGVuZHMgRXhjaGFuZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIgKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBOb3RTdXBwb3J0ZWRcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IE5vdFN1cHBvcnRlZC5wcm90b3R5cGVcbiAgICAgICAgdGhpcy5tZXNzYWdlICAgICA9IG1lc3NhZ2VcbiAgICB9XG59XG5cbmNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFeGNoYW5nZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IEF1dGhlbnRpY2F0aW9uRXJyb3JcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEF1dGhlbnRpY2F0aW9uRXJyb3IucHJvdG90eXBlXG4gICAgICAgIHRoaXMubWVzc2FnZSAgICAgPSBtZXNzYWdlXG4gICAgfVxufVxuXG5jbGFzcyBJbnN1ZmZpY2llbnRGdW5kcyBleHRlbmRzIEV4Y2hhbmdlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gSW5zdWZmaWNpZW50RnVuZHNcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEluc3VmZmljaWVudEZ1bmRzLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgTmV0d29ya0Vycm9yIGV4dGVuZHMgQ0NYVEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgICAgICBzdXBlciAobWVzc2FnZSlcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IE5ldHdvcmtFcnJvclxuICAgICAgICB0aGlzLl9fcHJvdG9fXyAgID0gTmV0d29ya0Vycm9yLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgRERvU1Byb3RlY3Rpb24gZXh0ZW5kcyBOZXR3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gRERvU1Byb3RlY3Rpb25cbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEREb1NQcm90ZWN0aW9uLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgUmVxdWVzdFRpbWVvdXQgZXh0ZW5kcyBOZXR3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gUmVxdWVzdFRpbWVvdXRcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IFJlcXVlc3RUaW1lb3V0LnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuY2xhc3MgRXhjaGFuZ2VOb3RBdmFpbGFibGUgZXh0ZW5kcyBOZXR3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyIChtZXNzYWdlKVxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgdGhpcy5fX3Byb3RvX18gICA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlLnByb3RvdHlwZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgICAgID0gbWVzc2FnZVxuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdXRpbGl0eSBoZWxwZXJzXG5cbmNvbnN0IHNldFRpbWVvdXRfc2FmZSA9IChkb25lLCBtcywgdGFyZ2V0VGltZSA9IERhdGUubm93ICgpICsgbXMpID0+IHsgLy8gc2V0VGltZW91dCBjYW4gZmlyZSBlYXJsaWVyIHRoYW4gc3BlY2lmaWVkLCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCBkb2VzIG5vdCBoYXBwZW4uLi5cblxuICAgIHNldFRpbWVvdXQgKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdCA9IHRhcmdldFRpbWUgLSBEYXRlLm5vdyAoKVxuICAgICAgICBpZiAocmVzdCA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXRfc2FmZSAoZG9uZSwgcmVzdCwgdGFyZ2V0VGltZSkgLy8gdHJ5IHNsZWVwIG1vcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgKClcbiAgICAgICAgfVxuICAgIH0sIG1zKVxufVxuXG5jb25zdCBzbGVlcCA9IG1zID0+IG5ldyBQcm9taXNlIChyZXNvbHZlID0+IHNldFRpbWVvdXRfc2FmZSAocmVzb2x2ZSwgbXMpKVxuXG5jb25zdCBkZWNpbWFsID0gZmxvYXQgPT4gcGFyc2VGbG9hdCAoZmxvYXQpLnRvU3RyaW5nICgpXG5cbmNvbnN0IHRpbWVvdXQgPSAobXMsIHByb21pc2UpID0+XG4gICAgICAgIFByb21pc2UucmFjZSAoW1xuICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgIHNsZWVwIChtcykudGhlbiAoKCkgPT4geyB0aHJvdyBuZXcgUmVxdWVzdFRpbWVvdXQgKCdyZXF1ZXN0IHRpbWVkIG91dCcpIH0pXG4gICAgICAgIF0pXG5cbmNvbnN0IGNhcGl0YWxpemUgPSBzdHJpbmcgPT4gc3RyaW5nLmxlbmd0aCA/IChzdHJpbmcuY2hhckF0ICgwKS50b1VwcGVyQ2FzZSAoKSArIHN0cmluZy5zbGljZSAoMSkpIDogc3RyaW5nXG5cbmNvbnN0IGtleXNvcnQgPSBvYmplY3QgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgT2JqZWN0LmtleXMgKG9iamVjdCkuc29ydCAoKS5mb3JFYWNoIChrZXkgPT4gcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XSlcbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGV4dGVuZCA9ICguLi5hcmdzKSA9PiBPYmplY3QuYXNzaWduICh7fSwgLi4uYXJncylcblxuY29uc3Qgb21pdCA9IChvYmplY3QsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBleHRlbmQgKG9iamVjdClcbiAgICBmb3IgKGNvbnN0IHggb2YgYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0W3hdXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSAoeCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiB4KVxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRba11cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG59XG5cbmNvbnN0IGluZGV4QnkgPSAoYXJyYXksIGtleSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkgKGFycmF5KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGFycmF5W2ldXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnRba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtlbGVtZW50W2tleV1dID0gZWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChhcnJheSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGFycmF5W2lkXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudFtrZXldICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2VsZW1lbnRba2V5XV0gPSBlbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBzb3J0QnkgPSAoYXJyYXksIGtleSwgZGVzY2VuZGluZyA9IGZhbHNlKSA9PiB7XG4gICAgZGVzY2VuZGluZyA9IGRlc2NlbmRpbmcgPyAtMSA6IDFcbiAgICByZXR1cm4gYXJyYXkuc29ydCAoKGEsIGIpID0+ICgoYVtrZXldIDwgYltrZXldKSA/IC1kZXNjZW5kaW5nIDogKChhW2tleV0gPiBiW2tleV0pID8gZGVzY2VuZGluZyA6IDApKSlcbn1cblxuY29uc3QgZmxhdHRlbiA9IChhcnJheSwgcmVzdWx0ID0gW10pID0+IHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSAodmFsdWUpKSB7XG4gICAgICAgICAgICBmbGF0dGVuICh2YWx1ZSwgcmVzdWx0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHZhbHVlKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuY29uc3QgdW5pcXVlID0gYXJyYXkgPT4gYXJyYXkuZmlsdGVyICgodmFsdWUsIGluZGV4LCBzZWxmKSA9PiAoc2VsZi5pbmRleE9mICh2YWx1ZSkgPT0gaW5kZXgpKVxuXG5jb25zdCBwbHVjayA9IChhcnJheSwga2V5KSA9PiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyIChlbGVtZW50ID0+ICh0eXBlb2YgZWxlbWVudFtrZXldICE9ICd1bmRlZmluZWQnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCAoZWxlbWVudCA9PiBlbGVtZW50W2tleV0pXG5cbmNvbnN0IHVybGVuY29kZSA9IG9iamVjdCA9PiBxcy5zdHJpbmdpZnkgKG9iamVjdClcblxuY29uc3Qgc3VtID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhcmdzLmZpbHRlciAoYXJnID0+IHR5cGVvZiBhcmcgIT0gJ3VuZGVmaW5lZCcpXG4gICAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID4gMCkgP1xuICAgICAgICByZXN1bHQucmVkdWNlICgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApIDogdW5kZWZpbmVkXG59XG5cbmNvbnN0IHNhZmVGbG9hdCA9IChvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgcmV0dXJuICgoa2V5IGluIG9iamVjdCkgJiYgKG9iamVjdFtrZXldKSkgPyBwYXJzZUZsb2F0IChvYmplY3Rba2V5XSkgOiBkZWZhdWx0VmFsdWVcbn1cblxuY29uc3Qgb3JkZXJlZCA9IHggPT4geCAvLyBhIHN0dWIgdG8ga2VlcCBhc3NvYyBrZXlzIGluIG9yZGVyLCBpbiBKUyBpdCBkb2VzIG5vdGhpbmcsIGl0J3MgbW9zdGx5IGZvciBQeXRob25cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gYSBjcm9zcy1wbGF0Zm9ybSBGZXRjaCBBUElcblxuY29uc3Qgbm9kZUZldGNoICAgPSBpc05vZGUgJiYgbW9kdWxlLnJlcXVpcmUgKCdub2RlLWZldGNoJykgICAgICAgICAvLyB1c2luZyBtb2R1bGUucmVxdWlyZSB0byBwcmV2ZW50IFdlYnBhY2sgLyBSZWFjdCBOYXRpdmUgZnJvbSB0cnlpbmcgdG8gaW5jbHVkZSBpdFxuICAgICwgd2luZG93RmV0Y2ggPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmZldGNoKSAvLyBuYXRpdmUgRmV0Y2ggQVBJIChpbiBuZXdlciBicm93c2VycylcbiAgICAsIHhockZldGNoICAgID0gKHVybCwgb3B0aW9ucywgdmVyYm9zZSA9IGZhbHNlKSA9PiAgICAgICAgICAgICAgLy8gYSBxdWljayBhZC1ob2MgcG9seWZpbGwgKGZvciBvbGRlciBicm93c2VycylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cgKHVybCwgb3B0aW9ucylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCAoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbiAobWV0aG9kLCB1cmwsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlICh4aHIucmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIFs0MDMsIDQwNCwgLi4uXS5pbmRleE9mICh4aHIuc3RhdHVzKSA+PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yIChtZXRob2QsIHVybCwgeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5oZWFkZXJzICE9ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gb3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIgKGhlYWRlciwgb3B0aW9ucy5oZWFkZXJzW2hlYWRlcl0pXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCAob3B0aW9ucy5ib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuY29uc3QgZmV0Y2ggPSBub2RlRmV0Y2ggfHwgd2luZG93RmV0Y2ggfHwgeGhyRmV0Y2hcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc3RyaW5nIOKGkOKGkiBiaW5hcnkg4oaQ4oaSIGJhc2U2NCBjb252ZXJzaW9uIHJvdXRpbmVzXG5cbmNvbnN0IHN0cmluZ1RvQmluYXJ5ID0gc3RyID0+IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSAoc3RyLmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykgeyBhcnJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTsgfVxuICAgIHJldHVybiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSAoYXJyKVxufVxuXG5jb25zdCBzdHJpbmdUb0Jhc2U2NCA9IHN0cmluZyA9PiBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlIChzdHJpbmcpLnRvU3RyaW5nIChDcnlwdG9KUy5lbmMuQmFzZTY0KVxuICAgICwgdXRmMTZUb0Jhc2U2NCAgPSBzdHJpbmcgPT4gQ3J5cHRvSlMuZW5jLlV0ZjE2IC5wYXJzZSAoc3RyaW5nKS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jLkJhc2U2NClcbiAgICAsIGJhc2U2NFRvQmluYXJ5ID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZylcbiAgICAsIGJhc2U2NFRvU3RyaW5nID0gc3RyaW5nID0+IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UgKHN0cmluZykudG9TdHJpbmcgKENyeXB0b0pTLmVuYy5VdGY4KVxuICAgICwgYmluYXJ5VG9TdHJpbmcgPSBzdHJpbmcgPT4gc3RyaW5nXG5cbmNvbnN0IGJpbmFyeUNvbmNhdCA9ICguLi5hcmdzKSA9PiBhcmdzLnJlZHVjZSAoKGEsIGIpID0+IGEuY29uY2F0IChiKSlcblxuLy8gdXJsLXNhZmUtYmFzZTY0IHdpdGhvdXQgZXF1YWxzIHNpZ25zLCB3aXRoICsgcmVwbGFjZWQgYnkgLSBhbmQgc2xhc2hlcyByZXBsYWNlZCBieSB1bmRlcnNjb3Jlc1xuY29uc3QgdXJsZW5jb2RlQmFzZTY0ID0gYmFzZTY0c3RyaW5nID0+IGJhc2U2NHN0cmluZy5yZXBsYWNlICgvWz1dKyQvLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSAoL1xcKy9nLCAnLScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UgKC9cXC8vZywgJ18nKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBjcnlwdG9ncmFwaHlcblxuY29uc3QgaGFzaCA9IChyZXF1ZXN0LCBoYXNoID0gJ21kNScsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gQ3J5cHRvSlNbaGFzaC50b1VwcGVyQ2FzZSAoKV0gKHJlcXVlc3QpXG4gICAgcmV0dXJuIChkaWdlc3QgPT0gJ2JpbmFyeScpID8gcmVzdWx0IDogcmVzdWx0LnRvU3RyaW5nIChDcnlwdG9KUy5lbmNbY2FwaXRhbGl6ZSAoZGlnZXN0KV0pXG59XG5cbmNvbnN0IGhtYWMgPSAocmVxdWVzdCwgc2VjcmV0LCBoYXNoID0gJ3NoYTI1NicsIGRpZ2VzdCA9ICdoZXgnKSA9PiB7XG4gICAgY29uc3QgZW5jb2RpbmcgPSAoZGlnZXN0ID09ICdiaW5hcnknKSA/ICdMYXRpbjEnIDogY2FwaXRhbGl6ZSAoZGlnZXN0KVxuICAgIHJldHVybiBDcnlwdG9KU1snSG1hYycgKyBoYXNoLnRvVXBwZXJDYXNlICgpXSAocmVxdWVzdCwgc2VjcmV0KS50b1N0cmluZyAoQ3J5cHRvSlMuZW5jW2NhcGl0YWxpemUgKGVuY29kaW5nKV0pXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGEgSlNPTiBXZWIgVG9rZW4gYXV0aGVudGljYXRpb24gbWV0aG9kXG5cbmNvbnN0IGp3dCA9IChyZXF1ZXN0LCBzZWNyZXQsIGFsZyA9ICdIUzI1NicsIGhhc2ggPSAnc2hhMjU2JykgPT4ge1xuICAgIGNvbnN0IGVuY29kZWRIZWFkZXIgPSB1cmxlbmNvZGVCYXNlNjQgKHN0cmluZ1RvQmFzZTY0IChKU09OLnN0cmluZ2lmeSAoeyAnYWxnJzogYWxnLCAndHlwJzogJ0pXVCcgfSkpKVxuICAgICAgICAsIGVuY29kZWREYXRhID0gdXJsZW5jb2RlQmFzZTY0IChzdHJpbmdUb0Jhc2U2NCAoSlNPTi5zdHJpbmdpZnkgKHJlcXVlc3QpKSlcbiAgICAgICAgLCB0b2tlbiA9IFsgZW5jb2RlZEhlYWRlciwgZW5jb2RlZERhdGEgXS5qb2luICgnLicpXG4gICAgICAgICwgc2lnbmF0dXJlID0gdXJsZW5jb2RlQmFzZTY0ICh1dGYxNlRvQmFzZTY0IChobWFjICh0b2tlbiwgc2VjcmV0LCBoYXNoLCAndXRmMTYnKSkpXG4gICAgcmV0dXJuIFsgdG9rZW4sIHNpZ25hdHVyZSBdLmpvaW4gKCcuJylcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gY29uc3QgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKVxuLy8gY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0ICh0aGlzLnVybHNbJ3dlYnNvY2tldCddKVxuLy8gd3Mub24gKCdvcGVuJywgZnVuY3Rpb24gb3BlbiAoKSB7XG4vLyAgICAgY29uc29sZS5sb2cgKCdjb25uZWN0ZWQnKVxuLy8gICAgIC8vIHdzLnNlbmQgKERhdGUubm93ICgpKVxuLy8gfSlcbi8vIHdzLm9uICgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSAoKSB7XG4vLyAgICAgY29uc29sZS5sb2cgKCdkaXNjb25uZWN0ZWQnKVxuLy8gfSk7XG4vLyB3cy5vbiAoJ21lc3NhZ2UnLCBmdW5jdGlvbiBpbmNvbWluZyAoZGF0YSkge1xuLy8gICAgIC8vIGNvbnNvbGUubG9nIChgUm91bmR0cmlwIHRpbWU6ICR7RGF0ZS5ub3coKSAtIGRhdGF9IG1zYCk7XG4vLyAgICAgc2V0VGltZW91dCAoZnVuY3Rpb24gdGltZW91dCAoKSB7XG4vLyAgICAgICAgIHdzLnNlbmQgKERhdGUubm93ICgpKVxuLy8gICAgIH0sIDUwMClcbi8vIH0pXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHRoZSBiYXNlIGNsYXNzXG5cbmNvbnN0IEV4Y2hhbmdlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuXG4gICAgdGhpcy5oYXNoID0gaGFzaFxuICAgIHRoaXMuaG1hYyA9IGhtYWNcbiAgICB0aGlzLmp3dCA9IGp3dCAvLyBKU09OIFdlYiBUb2tlblxuICAgIHRoaXMuYmluYXJ5Q29uY2F0ID0gYmluYXJ5Q29uY2F0XG4gICAgdGhpcy5zdHJpbmdUb0JpbmFyeSA9IHN0cmluZ1RvQmluYXJ5XG4gICAgdGhpcy5zdHJpbmdUb0Jhc2U2NCA9IHN0cmluZ1RvQmFzZTY0XG4gICAgdGhpcy5iYXNlNjRUb0JpbmFyeSA9IGJhc2U2NFRvQmluYXJ5XG4gICAgdGhpcy5iYXNlNjRUb1N0cmluZyA9IGJhc2U2NFRvU3RyaW5nXG4gICAgdGhpcy5iaW5hcnlUb1N0cmluZyA9IGJpbmFyeVRvU3RyaW5nXG4gICAgdGhpcy51dGYxNlRvQmFzZTY0ID0gdXRmMTZUb0Jhc2U2NFxuICAgIHRoaXMudXJsZW5jb2RlID0gdXJsZW5jb2RlXG4gICAgdGhpcy5lbmNvZGVVUklDb21wb25lbnQgPSBlbmNvZGVVUklDb21wb25lbnRcbiAgICB0aGlzLm9taXQgPSBvbWl0XG4gICAgdGhpcy5wbHVjayA9IHBsdWNrXG4gICAgdGhpcy51bmlxdWUgPSB1bmlxdWVcbiAgICB0aGlzLmV4dGVuZCA9IGV4dGVuZFxuICAgIHRoaXMuZmxhdHRlbiA9IGZsYXR0ZW5cbiAgICB0aGlzLmluZGV4QnkgPSBpbmRleEJ5XG4gICAgdGhpcy5zb3J0QnkgPSBzb3J0QnlcbiAgICB0aGlzLmtleXNvcnQgPSBrZXlzb3J0XG4gICAgdGhpcy5kZWNpbWFsID0gZGVjaW1hbFxuICAgIHRoaXMuc2FmZUZsb2F0ID0gc2FmZUZsb2F0XG4gICAgdGhpcy5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZVxuICAgIHRoaXMuanNvbiA9IEpTT04uc3RyaW5naWZ5XG4gICAgdGhpcy5zdW0gPSBzdW1cbiAgICB0aGlzLm9yZGVyZWQgPSBvcmRlcmVkXG5cbiAgICB0aGlzLmVuY29kZSA9IHN0cmluZyA9PiBzdHJpbmdcbiAgICB0aGlzLmRlY29kZSA9IHN0cmluZyA9PiBzdHJpbmdcblxuICAgIGlmIChpc05vZGUpXG4gICAgICAgIHRoaXMubm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb24ubWF0Y2ggKC9cXGQrXFwuXFxkKy5cXGQrLykgWzBdXG5cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3JkZXJzID0ge31cbiAgICAgICAgdGhpcy50cmFkZXMgPSB7fVxuICAgICAgICBpZiAodGhpcy5hcGkpXG4gICAgICAgICAgICB0aGlzLmRlZmluZVJlc3RBcGkgKHRoaXMuYXBpLCAncmVxdWVzdCcpO1xuICAgICAgICBpZiAodGhpcy5tYXJrZXRzKVxuICAgICAgICAgICAgdGhpcy5zZXRNYXJrZXRzICh0aGlzLm1hcmtldHMpO1xuICAgIH1cblxuICAgIHRoaXMuZGVmaW5lUmVzdEFwaSA9IGZ1bmN0aW9uIChhcGksIG1ldGhvZE5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBPYmplY3Qua2V5cyAoYXBpKS5mb3JFYWNoICh0eXBlID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzIChhcGlbdHlwZV0pLmZvckVhY2ggKGh0dHBNZXRob2QgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB1cmxzID0gYXBpW3R5cGVdW2h0dHBNZXRob2RdXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmwgPSB1cmxzW2ldLnRyaW0gKClcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNwbGl0UGF0aCA9IHVybC5zcGxpdCAoL1teYS16QS1aMC05XS8pXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZU1ldGhvZCAgPSBodHRwTWV0aG9kLnRvVXBwZXJDYXNlICgpXG4gICAgICAgICAgICAgICAgICAgIGxldCBsb3dlcmNhc2VNZXRob2QgID0gaHR0cE1ldGhvZC50b0xvd2VyQ2FzZSAoKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY2FtZWxjYXNlTWV0aG9kICA9IGNhcGl0YWxpemUgKGxvd2VyY2FzZU1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbWVsY2FzZVN1ZmZpeCAgPSBzcGxpdFBhdGgubWFwIChjYXBpdGFsaXplKS5qb2luICgnJylcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuZGVyc2NvcmVTdWZmaXggPSBzcGxpdFBhdGgubWFwICh4ID0+IHgudHJpbSAoKS50b0xvd2VyQ2FzZSAoKSkuZmlsdGVyICh4ID0+IHgubGVuZ3RoID4gMCkuam9pbiAoJ18nKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW1lbGNhc2VTdWZmaXguaW5kZXhPZiAoY2FtZWxjYXNlTWV0aG9kKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbWVsY2FzZVN1ZmZpeCA9IGNhbWVsY2FzZVN1ZmZpeC5zbGljZSAoY2FtZWxjYXNlTWV0aG9kLmxlbmd0aClcblxuICAgICAgICAgICAgICAgICAgICBpZiAodW5kZXJzY29yZVN1ZmZpeC5pbmRleE9mIChsb3dlcmNhc2VNZXRob2QpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJzY29yZVN1ZmZpeCA9IHVuZGVyc2NvcmVTdWZmaXguc2xpY2UgKGxvd2VyY2FzZU1ldGhvZC5sZW5ndGgpXG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbWVsY2FzZSAgPSB0eXBlICsgY2FtZWxjYXNlTWV0aG9kICsgY2FwaXRhbGl6ZSAoY2FtZWxjYXNlU3VmZml4KVxuICAgICAgICAgICAgICAgICAgICBsZXQgdW5kZXJzY29yZSA9IHR5cGUgKyAnXycgKyBsb3dlcmNhc2VNZXRob2QgKyAnXycgKyB1bmRlcnNjb3JlU3VmZml4XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdWZmaXhlcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdjYW1lbGNhc2UnIGluIG9wdGlvbnNbJ3N1ZmZpeGVzJ10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWxjYXNlICs9IG9wdGlvbnNbJ3N1ZmZpeGVzJ11bJ2NhbWVsY2FzZSddXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3VuZGVyc2NvcmUnIGluIG9wdGlvbnMuc3VmZml4ZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kZXJzY29yZSArPSBvcHRpb25zWydzdWZmaXhlcyddWyd1bmRlcnNjb3JlJ11cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgndW5kZXJzY29yZV9zdWZmaXgnIGluIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlcnNjb3JlICs9IG9wdGlvbnMudW5kZXJzY29yZVN1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCdjYW1lbGNhc2Vfc3VmZml4JyBpbiBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FtZWxjYXNlICs9IG9wdGlvbnMuY2FtZWxjYXNlU3VmZml4O1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gYXN5bmMgcGFyYW1zID0+IHRoaXNbbWV0aG9kTmFtZV0gKHVybCwgdHlwZSwgdXBwZXJjYXNlTWV0aG9kLCBwYXJhbXMpXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tjYW1lbGNhc2VdICA9IHBhcnRpYWxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1t1bmRlcnNjb3JlXSA9IHBhcnRpYWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIHRoaXMuaW5pdGlhbGl6ZVN0cmVhbWluZ0FQSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQgKHRoaXMudXJsc1snd2Vic29ja2V0J10pXG4gICAgLy8gICAgIHdzLm9uICgnb3BlbicsIGZ1bmN0aW9uIG9wZW4gKCkge1xuICAgIC8vICAgICAgICAgY29uc29sZS5sb2cgKCdjb25uZWN0ZWQnKVxuICAgIC8vICAgICAgICAgLy8gd3Muc2VuZCAoRGF0ZS5ub3cgKCkpXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHdzLm9uICgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSAoKSB7XG4gICAgLy8gICAgICAgICBjb25zb2xlLmxvZyAoJ2Rpc2Nvbm5lY3RlZCcpXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHdzLm9uICgnbWVzc2FnZScsIGZ1bmN0aW9uIGluY29taW5nIChkYXRhKSB7XG4gICAgLy8gICAgICAgICAvLyBjb25zb2xlLmxvZyAoYFJvdW5kdHJpcCB0aW1lOiAke0RhdGUubm93KCkgLSBkYXRhfSBtc2ApO1xuICAgIC8vICAgICAgICAgc2V0VGltZW91dCAoZnVuY3Rpb24gdGltZW91dCAoKSB7XG4gICAgLy8gICAgICAgICAgICAgd3Muc2VuZCAoRGF0ZS5ub3cgKCkpXG4gICAgLy8gICAgICAgICB9LCA1MDApXG4gICAgLy8gICAgIH0pXG4gICAgLy8gfSxcblxuICAgIC8vIGludGVybmFsIHJhdGUtbGltaXRpbmcgUkVTVCBwb2xsZXJcblxuICAgIGxldCBsYXN0UmVzdFJlcXVlc3RUaW1lc3RhbXAgPSAwXG4gICAgICAsIGxhc3RSZXN0UG9sbFRpbWVzdGFtcCA9IDBcbiAgICAgICwgcmVzdFJlcXVlc3RRdWV1ZSA9IFtdXG4gICAgICAsIHJlc3RQb2xsZXJMb29wSXNSdW5uaW5nID0gZmFsc2VcbiAgICAgICwgcnVuUmVzdFBvbGxlckxvb3AgPSBhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgaWYgKCFyZXN0UG9sbGVyTG9vcElzUnVubmluZykge1xuXG4gICAgICAgICAgICByZXN0UG9sbGVyTG9vcElzUnVubmluZyA9IHRydWVcbiAgICAgICAgICAgIGxhc3RSZXN0UG9sbFRpbWVzdGFtcCA9IE1hdGgubWF4IChsYXN0UmVzdFBvbGxUaW1lc3RhbXAsIGxhc3RSZXN0UmVxdWVzdFRpbWVzdGFtcClcblxuICAgICAgICAgICAgd2hpbGUgKHJlc3RSZXF1ZXN0UXVldWUubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAgICAgLy8gcmF0ZSBsaW1pdGVyXG5cbiAgICAgICAgICAgICAgICBsZXQgZWxhcHNlZCA9IHRoaXMubWlsbGlzZWNvbmRzICgpIC0gbGFzdFJlc3RQb2xsVGltZXN0YW1wXG4gICAgICAgICAgICAgICAgbGV0IGRlbGF5ID0gdGhpcy5yYXRlTGltaXQgLSBlbGFwc2VkXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCAoZGVsYXkpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHsgYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0gPSByZXN0UmVxdWVzdFF1ZXVlLnNoaWZ0ICgpXG4gICAgICAgICAgICAgICAgbGFzdFJlc3RQb2xsVGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKClcblxuICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVJlc3RSZXF1ZXN0ICguLi5hcmdzKVxuICAgICAgICAgICAgICAgICAgICAgLnRoZW4gKHJlc29sdmUpXG4gICAgICAgICAgICAgICAgICAgICAuY2F0Y2ggKHJlamVjdClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdFBvbGxlckxvb3BJc1J1bm5pbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNzdWVSZXN0UmVxdWVzdCA9ICguLi5hcmdzKSA9PiB7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlUmF0ZUxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXN0UmVxdWVzdFF1ZXVlLnB1c2ggKHsgYXJncywgcmVzb2x2ZSwgcmVqZWN0IH0pXG4gICAgICAgICAgICAgICAgcnVuUmVzdFBvbGxlckxvb3AgKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRlUmVzdFJlcXVlc3QgKC4uLmFyZ3MpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4ZWN1dGVSZXN0UmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgbGFzdFJlc3RSZXF1ZXN0VGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKClcblxuICAgICAgICBsZXQgcHJvbWlzZSA9XG4gICAgICAgICAgICBmZXRjaCAodXJsLCB7ICdtZXRob2QnOiBtZXRob2QsICdoZWFkZXJzJzogaGVhZGVycywgJ2JvZHknOiBib2R5IH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoIChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZU5vdEF2YWlsYWJsZSAoWyB0aGlzLmlkLCBtZXRob2QsIHVybCwgZS50eXBlLCBlLm1lc3NhZ2UgXS5qb2luICgnICcpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlIC8vIHJldGhyb3cgYWxsIHVua25vd24gZXJyb3JzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbiAocmVzcG9uc2UgPT4gdGhpcy5oYW5kbGVSZXN0RXJyb3JzIChyZXNwb25zZSwgdXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuIChyZXNwb25zZSA9PiB0aGlzLmhhbmRsZVJlc3RSZXNwb25zZSAocmVzcG9uc2UsIHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KSlcblxuICAgICAgICByZXR1cm4gdGltZW91dCAodGhpcy50aW1lb3V0LCBwcm9taXNlKVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2ggPSBmdW5jdGlvbiAodXJsLCBtZXRob2QgPSAnR0VUJywgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGlmIChpc05vZGUgJiYgdGhpcy51c2VyQWdlbnQpXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudXNlckFnZW50ID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBleHRlbmQgKHsgJ1VzZXItQWdlbnQnOiB0aGlzLnVzZXJBZ2VudCB9LCBoZWFkZXJzKVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR5cGVvZiB0aGlzLnVzZXJBZ2VudCA9PSAnb2JqZWN0JykgJiYgKCdVc2VyLUFnZW50JyBpbiB0aGlzLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IGV4dGVuZCAodGhpcy51c2VyQWdlbnQsIGhlYWRlcnMpXG5cbiAgICAgICAgaWYgKHRoaXMucHJveHkubGVuZ3RoKVxuICAgICAgICAgICAgaGVhZGVycyA9IGV4dGVuZCAoeyAnT3JpZ2luJzogJyonIH0sIGhlYWRlcnMpXG5cbiAgICAgICAgdXJsID0gdGhpcy5wcm94eSArIHVybFxuXG4gICAgICAgIGlmICh0aGlzLnZlcmJvc2UpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyAodGhpcy5pZCwgbWV0aG9kLCB1cmwsIFwiXFxuUmVxdWVzdDpcXG5cIiwgaGVhZGVycywgYm9keSlcblxuICAgICAgICByZXR1cm4gaXNzdWVSZXN0UmVxdWVzdCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpXG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVSZXN0RXJyb3JzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0ICgpLnRoZW4gKHRleHQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyAodGhpcy5pZCwgbWV0aG9kLCB1cmwsIHRleHQgPyAoXCJcXG5SZXNwb25zZTpcXG5cIiArIHRleHQpIDogJycpXG4gICAgICAgICAgICBpZiAoKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDApICYmIChyZXNwb25zZS5zdGF0dXMgPD0gMzAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgbGV0IGVycm9yID0gdW5kZWZpbmVkXG4gICAgICAgICAgICBsZXQgZGV0YWlscyA9IHRleHRcbiAgICAgICAgICAgIGlmIChbIDQyOSBdLmluZGV4T2YgKHJlc3BvbnNlLnN0YXR1cykgPj0gMCkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gRERvU1Byb3RlY3Rpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoWyA0MDQsIDQwOSwgNDIyLCA1MDAsIDUwMSwgNTAyLCA1MjAsIDUyMSwgNTIyLCA1MjUgXS5pbmRleE9mIChyZXNwb25zZS5zdGF0dXMpID49IDApIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFsgNDAwLCA0MDMsIDQwNSwgNTAzIF0uaW5kZXhPZiAocmVzcG9uc2Uuc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRkb3NQcm90ZWN0aW9uID0gdGV4dC5tYXRjaCAoL2Nsb3VkZmxhcmV8aW5jYXBzdWxhL2kpXG4gICAgICAgICAgICAgICAgaWYgKGRkb3NQcm90ZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gRERvU1Byb3RlY3Rpb25cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEV4Y2hhbmdlTm90QXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSB0ZXh0ICsgJyAocG9zc2libGUgcmVhc29uczogJyArIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnZhbGlkIEFQSSBrZXlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYWQgb3Igb2xkIG5vbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdleGNoYW5nZSBpcyBkb3duIG9yIG9mZmxpbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29uIG1haW50ZW5hbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdERG9TIHByb3RlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JhdGUtbGltaXRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4gKCcsICcpICsgJyknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChbIDQwOCwgNTA0IF0uaW5kZXhPZiAocmVzcG9uc2Uuc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBSZXF1ZXN0VGltZW91dFxuICAgICAgICAgICAgfSBlbHNlIGlmIChbIDQwMSwgNTExIF0uaW5kZXhPZiAocmVzcG9uc2Uuc3RhdHVzKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBBdXRoZW50aWNhdGlvbkVycm9yXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gRXhjaGFuZ2VFcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnN0YXR1c1RleHQsIGRldGFpbHMgXS5qb2luICgnICcpKVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlUmVzdFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlLCB1cmwsIG1ldGhvZCA9ICdHRVQnLCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcmVzcG9uc2UgIT0gJ3N0cmluZycpIHx8IChyZXNwb25zZS5sZW5ndGggPCAyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAoW3RoaXMuaWQsIG1ldGhvZCwgdXJsLCAncmV0dXJuZWQgZW1wdHkgcmVzcG9uc2UnXS5qb2luICgnICcpKVxuXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSAocmVzcG9uc2UpXG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICAgICAgICBsZXQgbWFpbnRlbmFuY2UgPSByZXNwb25zZS5tYXRjaCAoL29mZmxpbmV8YnVzeXxyZXRyeXx3YWl0fHVuYXZhaWxhYmxlfG1haW50YWlufG1haW50ZW5hbmNlfG1haW50ZW5hbmNpbmcvaSlcbiAgICAgICAgICAgIGxldCBkZG9zUHJvdGVjdGlvbiA9IHJlc3BvbnNlLm1hdGNoICgvY2xvdWRmbGFyZXxpbmNhcHN1bGF8b3ZlcmxvYWQvaSlcblxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yID0gRXhjaGFuZ2VOb3RBdmFpbGFibGVcbiAgICAgICAgICAgICAgICBsZXQgZGV0YWlscyA9ICdub3QgYWNjZXNzaWJsZSBmcm9tIHRoaXMgbG9jYXRpb24gYXQgdGhlIG1vbWVudCdcbiAgICAgICAgICAgICAgICBpZiAobWFpbnRlbmFuY2UpXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnb2ZmbGluZSwgb24gbWFpbnRlbmFuY2Ugb3IgdW5yZWFjaGFibGUgZnJvbSB0aGlzIGxvY2F0aW9uIGF0IHRoZSBtb21lbnQnXG4gICAgICAgICAgICAgICAgaWYgKGRkb3NQcm90ZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IEREb1NQcm90ZWN0aW9uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yIChbIHRoaXMuaWQsIG1ldGhvZCwgdXJsLCBkZXRhaWxzIF0uam9pbiAoJyAnKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMudmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyAodGhpcy5pZCwgbWV0aG9kLCB1cmwsICdlcnJvcicsIGUsIFwicmVzcG9uc2UgYm9keTpcXG4nXCIgKyByZXNwb25zZSArIFwiJ1wiKVxuXG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldE1hcmtldHMgPSBmdW5jdGlvbiAobWFya2V0cykge1xuICAgICAgICBsZXQgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyAobWFya2V0cylcbiAgICAgICAgdGhpcy5tYXJrZXRzID0gaW5kZXhCeSAodmFsdWVzLCAnc3ltYm9sJylcbiAgICAgICAgdGhpcy5tYXJrZXRzQnlJZCA9IGluZGV4QnkgKG1hcmtldHMsICdpZCcpXG4gICAgICAgIHRoaXMubWFya2V0c19ieV9pZCA9IHRoaXMubWFya2V0c0J5SWRcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gT2JqZWN0LmtleXMgKHRoaXMubWFya2V0cykuc29ydCAoKVxuICAgICAgICB0aGlzLmlkcyA9IE9iamVjdC5rZXlzICh0aGlzLm1hcmtldHNfYnlfaWQpLnNvcnQgKClcbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnBsdWNrICh2YWx1ZXMuZmlsdGVyIChtYXJrZXQgPT4gJ2Jhc2UnIGluIG1hcmtldCksICdiYXNlJylcbiAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5wbHVjayAodmFsdWVzLmZpbHRlciAobWFya2V0ID0+ICdxdW90ZScgaW4gbWFya2V0KSwgJ3F1b3RlJylcbiAgICAgICAgdGhpcy5jdXJyZW5jaWVzID0gdGhpcy51bmlxdWUgKGJhc2UuY29uY2F0IChxdW90ZSkpXG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtldHNcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRNYXJrZXRzID0gZnVuY3Rpb24gKHJlbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghcmVsb2FkICYmIHRoaXMubWFya2V0cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtldHNCeUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZXNvbHZlICh0aGlzLnNldE1hcmtldHMgKHRoaXMubWFya2V0cykpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlICgocmVzb2x2ZSwgcmVqZWN0KSA9PiByZXNvbHZlICh0aGlzLm1hcmtldHMpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoTWFya2V0cyAoKS50aGVuIChtYXJrZXRzID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE1hcmtldHMgKG1hcmtldHMpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaFRpY2tlcnMgPSBmdW5jdGlvbiAoc3ltYm9scyA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaFRpY2tlcnMgbm90IHN1cHBvcnRlZCB5ZXQnKVxuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hPcmRlciA9IGZ1bmN0aW9uIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlciBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hPcmRlcnMgPSBmdW5jdGlvbiAocGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlcnMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZldGNoT3Blbk9yZGVycyA9IGZ1bmN0aW9uIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQgKHRoaXMuaWQgKyAnIGZldGNoT3Blbk9yZGVycyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hDbG9zZWRPcmRlcnMgPSBmdW5jdGlvbiAoc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaENsb3NlZE9yZGVycyBub3Qgc3VwcG9ydGVkIHlldCcpO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hNYXJrZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHJlc29sdmUgKHRoaXMubWFya2V0cykpXG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaE9yZGVyU3RhdHVzID0gYXN5bmMgZnVuY3Rpb24gKGlkLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gYXdhaXQgZmV0Y2hPcmRlciAoaWQpXG4gICAgICAgIHJldHVybiBvcmRlclsnc3RhdHVzJ11cbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZnJlZSc6IDAuMCxcbiAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgPSBmdW5jdGlvbiAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN1YnN0aXR1dGVDb21tb25DdXJyZW5jeUNvZGVzKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmN5XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnWEJUJylcbiAgICAgICAgICAgIHJldHVybiAnQlRDJ1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JDQycpXG4gICAgICAgICAgICByZXR1cm4gJ0JDSCdcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEUksnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJ1xuICAgICAgICByZXR1cm4gY3VycmVuY3lcbiAgICB9XG5cbiAgICB0aGlzLm1hcmtldCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuICgoKHR5cGVvZiBzeW1ib2wgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgKHR5cGVvZiB0aGlzLm1hcmtldHMgIT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAodHlwZW9mIHRoaXMubWFya2V0c1tzeW1ib2xdICE9ICd1bmRlZmluZWQnKSkgP1xuICAgICAgICAgICAgICAgIHRoaXMubWFya2V0c1tzeW1ib2xdIDpcbiAgICAgICAgICAgICAgICBzeW1ib2wpXG4gICAgfVxuXG4gICAgdGhpcy5tYXJrZXRfaWQgPVxuICAgIHRoaXMubWFya2V0SWQgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtldCAoc3ltYm9sKS5pZCB8fCBzeW1ib2xcbiAgICB9XG5cbiAgICB0aGlzLm1hcmtldF9pZHMgPVxuICAgIHRoaXMubWFya2V0SWRzID0gZnVuY3Rpb24gKHN5bWJvbHMpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbHMubWFwIChzeW1ib2wgPT4gdGhpcy5tYXJrZXRJZChzeW1ib2wpKTtcbiAgICB9XG5cbiAgICB0aGlzLnN5bWJvbCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2V0IChzeW1ib2wpLnN5bWJvbCB8fCBzeW1ib2xcbiAgICB9XG5cbiAgICB0aGlzLmV4dHJhY3RfcGFyYW1zID1cbiAgICB0aGlzLmV4dHJhY3RQYXJhbXMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHZhciByZSA9IC97KFthLXpBLVowLTlfXSs/KX0vZ1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdXG4gICAgICAgIGxldCBtYXRjaFxuICAgICAgICB3aGlsZSAobWF0Y2ggPSByZS5leGVjIChzdHJpbmcpKVxuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoIChtYXRjaFsxXSlcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICB9XG5cbiAgICB0aGlzLmltcGxvZGVfcGFyYW1zID1cbiAgICB0aGlzLmltcGxvZGVQYXJhbXMgPSBmdW5jdGlvbiAoc3RyaW5nLCBwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gcGFyYW1zKVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UgKCd7JyArIHByb3BlcnR5ICsgJ30nLCBwYXJhbXNbcHJvcGVydHldKVxuICAgICAgICByZXR1cm4gc3RyaW5nXG4gICAgfVxuXG4gICAgdGhpcy51cmwgPSBmdW5jdGlvbiAocGF0aCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlQmlkQXNrID0gZnVuY3Rpb24gKGJpZGFzaywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAxKSB7XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKGJpZGFza1twcmljZUtleV0pXG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0IChiaWRhc2tbYW1vdW50S2V5XSlcbiAgICAgICAgcmV0dXJuIFsgcHJpY2UsIGFtb3VudCBdXG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZUJpZEFza3MgPSBmdW5jdGlvbiAoYmlkYXNrcywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAxKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzIChiaWRhc2tzKS5tYXAgKGJpZGFzayA9PiB0aGlzLnBhcnNlQmlkQXNrIChiaWRhc2ssIHByaWNlS2V5LCBhbW91bnRLZXkpKVxuICAgIH1cblxuICAgIHRoaXMucGFyc2VPcmRlckJvb2sgPSBmdW5jdGlvbiAob3JkZXJib29rLCB0aW1lc3RhbXAgPSB1bmRlZmluZWQsIGJpZHNLZXkgPSAnYmlkcycsIGFza3NLZXkgPSAnYXNrcycsIHByaWNlS2V5ID0gMCwgYW1vdW50S2V5ID0gMSkge1xuICAgICAgICB0aW1lc3RhbXAgPSB0aW1lc3RhbXAgfHwgdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnYmlkcyc6IChiaWRzS2V5IGluIG9yZGVyYm9vaykgPyB0aGlzLnBhcnNlQmlkQXNrcyAob3JkZXJib29rW2JpZHNLZXldLCBwcmljZUtleSwgYW1vdW50S2V5KSA6IFtdLFxuICAgICAgICAgICAgJ2Fza3MnOiAoYXNrc0tleSBpbiBvcmRlcmJvb2spID8gdGhpcy5wYXJzZUJpZEFza3MgKG9yZGVyYm9va1thc2tzS2V5XSwgcHJpY2VLZXksIGFtb3VudEtleSkgOiBbXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHRoaXMucGFyc2VUcmFkZXMgPSBmdW5jdGlvbiAodHJhZGVzLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMgKHRyYWRlcykubWFwICh0cmFkZSA9PiB0aGlzLnBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpKVxuICAgIH1cblxuICAgIHRoaXMucGFyc2VPcmRlcnMgPSBmdW5jdGlvbiAob3JkZXJzLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMgKG9yZGVycykubWFwIChvcmRlciA9PiB0aGlzLnBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQpKVxuICAgIH1cblxuICAgIHRoaXMucGFyc2VPSExDViA9IGZ1bmN0aW9uIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9obGN2XG4gICAgfVxuXG4gICAgdGhpcy5wYXJzZU9ITENWcyA9IGZ1bmN0aW9uIChvaGxjdnMsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzIChvaGxjdnMpLm1hcCAob2hsY3YgPT4gdGhpcy5wYXJzZU9ITENWIChvaGxjdiwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCkpXG4gICAgfVxuXG4gICAgdGhpcy5jcmVhdGVMaW1pdEJ1eU9yZGVyID0gZnVuY3Rpb24gKG1hcmtldCwgYW1vdW50LCBwcmljZSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgIChtYXJrZXQsICdsaW1pdCcsICdidXknLCBhbW91bnQsIHByaWNlLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgdGhpcy5jcmVhdGVMaW1pdFNlbGxPcmRlciA9IGZ1bmN0aW9uIChtYXJrZXQsIGFtb3VudCwgcHJpY2UsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yZGVyIChtYXJrZXQsICdsaW1pdCcsICdzZWxsJywgYW1vdW50LCBwcmljZSwgcGFyYW1zKVxuICAgIH1cblxuICAgIHRoaXMuY3JlYXRlTWFya2V0QnV5T3JkZXIgPSBmdW5jdGlvbiAobWFya2V0LCBhbW91bnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU9yZGVyIChtYXJrZXQsICdtYXJrZXQnLCAnYnV5JywgYW1vdW50LCB1bmRlZmluZWQsIHBhcmFtcylcbiAgICB9XG5cbiAgICB0aGlzLmNyZWF0ZU1hcmtldFNlbGxPcmRlciA9IGZ1bmN0aW9uIChtYXJrZXQsIGFtb3VudCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlT3JkZXIgKG1hcmtldCwgJ21hcmtldCcsICdzZWxsJywgYW1vdW50LCB1bmRlZmluZWQsIHBhcmFtcylcbiAgICB9XG5cbiAgICB0aGlzLmNhbGN1bGF0ZUZlZVJhdGUgPSBmdW5jdGlvbiAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIgPSAndGFrZXInLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBjb25zdCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXVxuICAgICAgICByZXR1cm4geyAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sICdyYXRlJzogbWFya2V0W3Rha2VyT3JNYWtlcl0gfVxuICAgIH1cblxuICAgIHRoaXMuY2FsY3VsYXRlRmVlID0gZnVuY3Rpb24gKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSwgdGFrZXJPck1ha2VyID0gJ3Rha2VyJywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGZlZSA9IHRoaXMuY2FsY3VsYXRlRmVlUmF0ZSAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIsIHBhcmFtcylcbiAgICAgICAgZmVlWydjb3N0J10gPSBhbW91bnQgKiBwcmljZSAqIGZlZVsncmF0ZSddXG4gICAgICAgIHJldHVybiBmZWVcbiAgICB9XG5cbiAgICB0aGlzLmlzbzg2MDEgICAgICAgICA9IHRpbWVzdGFtcCA9PiBuZXcgRGF0ZSAodGltZXN0YW1wKS50b0lTT1N0cmluZyAoKVxuICAgIHRoaXMucGFyc2U4NjAxICAgICAgID0gRGF0ZS5wYXJzZVxuICAgIHRoaXMuc2Vjb25kcyAgICAgICAgID0gKCkgPT4gTWF0aC5mbG9vciAodGhpcy5taWxsaXNlY29uZHMgKCkgLyAxMDAwKVxuICAgIHRoaXMubWljcm9zZWNvbmRzICAgID0gKCkgPT4gTWF0aC5mbG9vciAodGhpcy5taWxsaXNlY29uZHMgKCkgKiAxMDAwKVxuICAgIHRoaXMubWlsbGlzZWNvbmRzICAgID0gRGF0ZS5ub3dcbiAgICB0aGlzLm5vbmNlICAgICAgICAgICA9IHRoaXMuc2Vjb25kc1xuICAgIHRoaXMuaWQgICAgICAgICAgICAgID0gdW5kZWZpbmVkXG4gICAgdGhpcy5lbmFibGVSYXRlTGltaXQgPSBmYWxzZVxuICAgIHRoaXMucmF0ZUxpbWl0ICAgICAgID0gMjAwMCAgLy8gbWlsbGlzZWNvbmRzID0gc2Vjb25kcyAqIDEwMDBcbiAgICB0aGlzLnRpbWVvdXQgICAgICAgICA9IDEwMDAwIC8vIG1pbGxpc2Vjb25kcyA9IHNlY29uZHMgKiAxMDAwXG4gICAgdGhpcy52ZXJib3NlICAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMudXNlckFnZW50ICAgICAgID0gZmFsc2VcbiAgICB0aGlzLnR3b2ZhICAgICAgICAgICA9IGZhbHNlIC8vIHR3by1mYWN0b3IgYXV0aGVudGljYXRpb25cbiAgICB0aGlzLnN1YnN0aXR1dGVDb21tb25DdXJyZW5jeUNvZGVzID0gdHJ1ZVxuICAgIHRoaXMudGltZWZyYW1lcyAgICAgID0gdW5kZWZpbmVkXG4gICAgdGhpcy5oYXNQdWJsaWNBUEkgICAgICAgICA9IHRydWVcbiAgICB0aGlzLmhhc1ByaXZhdGVBUEkgICAgICAgID0gdHJ1ZVxuICAgIHRoaXMuaGFzQ09SUyAgICAgICAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hUaWNrZXJzICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hPSExDViAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hPcmRlciAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hPcmRlcnMgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hPcGVuT3JkZXJzICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzRmV0Y2hDbG9zZWRPcmRlcnMgPSBmYWxzZVxuICAgIHRoaXMuaGFzRGVwb3NpdCAgICAgICAgICAgPSBmYWxzZVxuICAgIHRoaXMuaGFzV2l0aGRyYXcgICAgICAgICAgPSBmYWxzZVxuXG4gICAgdGhpcy5iYWxhbmNlICAgID0ge31cbiAgICB0aGlzLm9yZGVyYm9va3MgPSB7fVxuICAgIHRoaXMuZmVlcyAgICAgICA9IHt9XG4gICAgdGhpcy5vcmRlcnMgICAgID0ge31cbiAgICB0aGlzLnRyYWRlcyAgICAgPSB7fVxuXG4gICAgdGhpcy5ZbWRITVMgPSBmdW5jdGlvbiAodGltZXN0YW1wLCBpbmZpeCA9ICcgJykge1xuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlICh0aW1lc3RhbXApXG4gICAgICAgIGxldCBZID0gZGF0ZS5nZXRVVENGdWxsWWVhciAoKVxuICAgICAgICBsZXQgbSA9IGRhdGUuZ2V0VVRDTW9udGggKCkgKyAxXG4gICAgICAgIGxldCBkID0gZGF0ZS5nZXRVVENEYXRlICgpXG4gICAgICAgIGxldCBIID0gZGF0ZS5nZXRVVENIb3VycyAoKVxuICAgICAgICBsZXQgTSA9IGRhdGUuZ2V0VVRDTWludXRlcyAoKVxuICAgICAgICBsZXQgUyA9IGRhdGUuZ2V0VVRDU2Vjb25kcyAoKVxuICAgICAgICBtID0gbSA8IDEwID8gKCcwJyArIG0pIDogbVxuICAgICAgICBkID0gZCA8IDEwID8gKCcwJyArIGQpIDogZFxuICAgICAgICBIID0gSCA8IDEwID8gKCcwJyArIEgpIDogSFxuICAgICAgICBNID0gTSA8IDEwID8gKCcwJyArIE0pIDogTVxuICAgICAgICBTID0gUyA8IDEwID8gKCcwJyArIFMpIDogU1xuICAgICAgICByZXR1cm4gWSArICctJyArIG0gKyAnLScgKyBkICsgaW5maXggKyBIICsgJzonICsgTSArICc6JyArIFNcbiAgICB9XG5cbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IHtcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogJ2NjeHQvJyArIHZlcnNpb24gK1xuICAgICAgICAgICAgICAgICcgKCtodHRwczovL2dpdGh1Yi5jb20va3JvaXRvci9jY3h0KScgK1xuICAgICAgICAgICAgICAgICcgTm9kZS5qcy8nICsgdGhpcy5ub2RlVmVyc2lvbiArICcgKEphdmFTY3JpcHQpJ1xuICAgICAgICB9XG5cbiAgICAvLyBwcmVwZW5kZWQgdG8gVVJMLCBsaWtlIGh0dHBzOi8vcHJveHkuY29tL2h0dHBzOi8vZXhjaGFuZ2UuY29tL2FwaS4uLlxuICAgIHRoaXMucHJveHkgPSAnJ1xuXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29uZmlnKVxuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IGNvbmZpZ1twcm9wZXJ0eV1cblxuICAgIHRoaXMuYWNjb3VudCAgICAgICAgICAgICAgICAgID0gdGhpcy5hY2NvdW50XG4gICAgdGhpcy5mZXRjaF9iYWxhbmNlICAgICAgICAgICAgPSB0aGlzLmZldGNoQmFsYW5jZVxuICAgIHRoaXMuZmV0Y2hfb3JkZXJfYm9vayAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyQm9va1xuICAgIHRoaXMuZmV0Y2hfdGlja2VycyAgICAgICAgICAgID0gdGhpcy5mZXRjaFRpY2tlcnNcbiAgICB0aGlzLmZldGNoX3RpY2tlciAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUaWNrZXJcbiAgICB0aGlzLmZldGNoX3RyYWRlcyAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hUcmFkZXNcbiAgICB0aGlzLmZldGNoX29yZGVyICAgICAgICAgICAgICA9IHRoaXMuZmV0Y2hPcmRlclxuICAgIHRoaXMuZmV0Y2hfb3JkZXJzICAgICAgICAgICAgID0gdGhpcy5mZXRjaE9yZGVyc1xuICAgIHRoaXMuZmV0Y2hfb3Blbl9vcmRlcnMgICAgICAgID0gdGhpcy5mZXRjaE9wZW5PcmRlcnNcbiAgICB0aGlzLmZldGNoX2Nsb3NlZF9vcmRlcnMgICAgICA9IHRoaXMuZmV0Y2hDbG9zZWRPcmRlcnNcbiAgICB0aGlzLmZldGNoX29yZGVyX3N0YXR1cyAgICAgICA9IHRoaXMuZmV0Y2hPcmRlclN0YXR1c1xuICAgIHRoaXMuZmV0Y2hfbWFya2V0cyAgICAgICAgICAgID0gdGhpcy5mZXRjaE1hcmtldHNcbiAgICB0aGlzLmxvYWRfbWFya2V0cyAgICAgICAgICAgICA9IHRoaXMubG9hZE1hcmtldHNcbiAgICB0aGlzLnNldF9tYXJrZXRzICAgICAgICAgICAgICA9IHRoaXMuc2V0TWFya2V0c1xuICAgIHRoaXMucGFyc2VfYmlkYXNrICAgICAgICAgICAgID0gdGhpcy5wYXJzZUJpZEFza1xuICAgIHRoaXMucGFyc2VfYmlkYXNrcyAgICAgICAgICAgID0gdGhpcy5wYXJzZUJpZEFza3NcbiAgICB0aGlzLnBhcnNlX29yZGVyX2Jvb2sgICAgICAgICA9IHRoaXMucGFyc2VPcmRlckJvb2tcbiAgICB0aGlzLnBhcnNlX3RyYWRlcyAgICAgICAgICAgICA9IHRoaXMucGFyc2VUcmFkZXNcbiAgICB0aGlzLnBhcnNlX29yZGVycyAgICAgICAgICAgICA9IHRoaXMucGFyc2VPcmRlcnNcbiAgICB0aGlzLnBhcnNlX29obGN2ICAgICAgICAgICAgICA9IHRoaXMucGFyc2VPSExDVlxuICAgIHRoaXMucGFyc2Vfb2hsY3ZzICAgICAgICAgICAgID0gdGhpcy5wYXJzZU9ITENWc1xuICAgIHRoaXMuY3JlYXRlX2xpbWl0X2J1eV9vcmRlciAgID0gdGhpcy5jcmVhdGVMaW1pdEJ1eU9yZGVyXG4gICAgdGhpcy5jcmVhdGVfbGltaXRfc2VsbF9vcmRlciAgPSB0aGlzLmNyZWF0ZUxpbWl0QnV5T3JkZXJcbiAgICB0aGlzLmNyZWF0ZV9tYXJrZXRfYnV5X29yZGVyICA9IHRoaXMuY3JlYXRlTGltaXRCdXlPcmRlclxuICAgIHRoaXMuY3JlYXRlX21hcmtldF9zZWxsX29yZGVyID0gdGhpcy5jcmVhdGVMaW1pdEJ1eU9yZGVyXG4gICAgdGhpcy5jcmVhdGVfb3JkZXIgICAgICAgICAgICAgPSB0aGlzLmNyZWF0ZU9yZGVyXG4gICAgdGhpcy5jYWxjdWxhdGVfZmVlICAgICAgICAgICAgPSB0aGlzLmNhbGN1bGF0ZUZlZVxuICAgIHRoaXMuY2FsY3VsYXRlX2ZlZV9yYXRlICAgICAgID0gdGhpcy5jYWxjdWxhdGVGZWVSYXRlXG5cbiAgICB0aGlzLmluaXQgKClcbn1cblxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG52YXIgXzFicm9rZXIgPSB7XG5cbiAgICAnaWQnOiAnXzFicm9rZXInLFxuICAgICduYW1lJzogJzFCcm9rZXInLFxuICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAnaGFzUHVibGljQVBJJzogZmFsc2UsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFtJzogJzYwJyxcbiAgICAgICAgJzE1bSc6ICc5MDAnLFxuICAgICAgICAnMWgnOiAnMzYwMCcsXG4gICAgICAgICcxZCc6ICc4NjQwMCcsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjAyMS00MjBiZDlmYy01ZWNiLTExZTctOGVkNi01NmQwMDgxZWZlZDIuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovLzFicm9rZXIuY29tL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly8xYnJva2VyLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly8xYnJva2VyLmNvbS8/Yz1lbi9jb250ZW50L2FwaS1kb2N1bWVudGF0aW9uJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnbWFya2V0L2JhcnMnLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvY2F0ZWdvcmllcycsXG4gICAgICAgICAgICAgICAgJ21hcmtldC9kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L2xpc3QnLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvcXVvdGVzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvb3BlbicsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2Nsb3NlJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24vY2xvc2VfY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24vZWRpdCcsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdwb3NpdGlvbi9vcGVuJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24vc2hhcmVkL2dldCcsXG4gICAgICAgICAgICAgICAgJ3NvY2lhbC9wcm9maWxlX3N0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAgICdzb2NpYWwvcHJvZmlsZV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICd1c2VyL2JpdGNvaW5fZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAndXNlci9kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAndXNlci9vdmVydmlldycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvcXVvdGFfc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAndXNlci90cmFuc2FjdGlvbl9sb2cnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hDYXRlZ29yaWVzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWFya2V0Q2F0ZWdvcmllcyAoKTtcbiAgICAgICAgLy8gdGhleSByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGFtb25nIHRoZWlyIGNhdGVnb3JpZXMsIHd0Zj9cbiAgICAgICAgbGV0IGNhdGVnb3JpZXMgPSByZXNwb25zZVsncmVzcG9uc2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhdGVnb3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzW2ldKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoIChjYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgdGhpc18gPSB0aGlzOyAvLyB3b3JrYXJvdW5kIGZvciBCYWJlbCBidWcgKG5vdCBwYXNzaW5nIGB0aGlzYCB0byBfcmVjdXJzaXZlKCkgY2FsbClcbiAgICAgICAgbGV0IGNhdGVnb3JpZXMgPSBhd2FpdCB0aGlzLmZldGNoQ2F0ZWdvcmllcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNhdGVnb3JpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjYXRlZ29yeSA9IGNhdGVnb3JpZXNbY107XG4gICAgICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXNfLnByaXZhdGVHZXRNYXJrZXRMaXN0ICh7XG4gICAgICAgICAgICAgICAgJ2NhdGVnb3J5JzogY2F0ZWdvcnkudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1sncmVzcG9uc2UnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydyZXNwb25zZSddW3BdO1xuICAgICAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKChjYXRlZ29yeSA9PSAnRk9SRVgnKSB8fCAoY2F0ZWdvcnkgPT0gJ0NSWVBUTycpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gJ1VTRCc7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmFzZSA9IHRoaXNfLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSB0aGlzXy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFVzZXJPdmVydmlldyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYmFsYW5jZVsncmVzcG9uc2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3RhbCA9IHBhcnNlRmxvYXQgKHJlc3BvbnNlWydiYWxhbmNlJ10pO1xuICAgICAgICByZXN1bHRbJ0JUQyddWydmcmVlJ10gPSB0b3RhbDtcbiAgICAgICAgcmVzdWx0WydCVEMnXVsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRNYXJrZXRRdW90ZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9scyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3BvbnNlJ11bMF07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJib29rWyd1cGRhdGVkJ10pO1xuICAgICAgICBsZXQgYmlkUHJpY2UgPSBwYXJzZUZsb2F0IChvcmRlcmJvb2tbJ2JpZCddKTtcbiAgICAgICAgbGV0IGFza1ByaWNlID0gcGFyc2VGbG9hdCAob3JkZXJib29rWydhc2snXSk7XG4gICAgICAgIGxldCBiaWQgPSBbIGJpZFByaWNlLCB1bmRlZmluZWQgXTtcbiAgICAgICAgbGV0IGFzayA9IFsgYXNrUHJpY2UsIHVuZGVmaW5lZCBdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdiaWRzJzogWyBiaWQgXSxcbiAgICAgICAgICAgICdhc2tzJzogWyBhc2sgXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUcmFkZXMgKCkgbWV0aG9kIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWFya2V0QmFycyAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncmVzb2x1dGlvbic6IDYwLFxuICAgICAgICAgICAgJ2xpbWl0JzogMSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLmZldGNoT3JkZXJCb29rIChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzdWx0WydyZXNwb25zZSddWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2wnXSksXG4gICAgICAgICAgICAnYmlkJzogb3JkZXJib29rWydiaWRzJ11bMF1bMF0sXG4gICAgICAgICAgICAnYXNrJzogb3JkZXJib29rWydhc2tzJ11bMF1bMF0sXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydjJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMucGFyc2U4NjAxIChvaGxjdlsnZGF0ZSddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydvJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2gnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnbCddKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydjJ10pLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncmVzb2x1dGlvbic6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydkYXRlX3N0YXJ0J10gPSB0aGlzLmlzbzg2MDEgKHNpbmNlKTsgLy8gdGhleSBhbHNvIHN1cHBvcnQgZGF0ZV9lbmRcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0TWFya2V0QmFycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzdWx0WydyZXNwb25zZSddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnbWFyZ2luJzogYW1vdW50LFxuICAgICAgICAgICAgJ2RpcmVjdGlvbic6IChzaWRlID09ICdzZWxsJykgPyAnc2hvcnQnIDogJ2xvbmcnLFxuICAgICAgICAgICAgJ2xldmVyYWdlJzogMSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9yZGVyWyd0eXBlJ10gKz0gJ19tYXJrZXQnO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXJDcmVhdGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsncmVzcG9uc2UnXVsnb3JkZXJfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0T3JkZXJDYW5jZWwgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhcGlLZXkgZm9yIGFsbCByZXF1ZXN0cycpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGggKyAnLnBocCc7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7ICd0b2tlbic6IHRoaXMuYXBpS2V5IH0sIHBhcmFtcyk7XG4gICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCk7XG4gICAgICAgIGlmICgnd2FybmluZycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3dhcm5pbmcnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ2Vycm9yJ10pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjcnlwdG9jYXBpdGFsID0ge1xuXG4gICAgJ2lkJzogJ2NyeXB0b2NhcGl0YWwnLFxuICAgICduYW1lJzogJ0NyeXB0byBDYXBpdGFsJyxcbiAgICAnY29tbWVudCc6ICdDcnlwdG8gQ2FwaXRhbCBBUEknLFxuICAgICdjb3VudHJpZXMnOiAnUEEnLCAvLyBQYW5hbWFcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFkJzogJzF5ZWFyJyxcbiAgICB9LFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkzMTU4LTdhMTNmMTQwLTY0YWMtMTFlNy04OWNjLWEzYjQ0MWYwYjBmOC5qcGcnLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY3J5cHRvY2FwaXRhbC5jbycsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NhcCcsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnc3RhdHMnLFxuICAgICAgICAgICAgICAgICdoaXN0b3JpY2FsLXByaWNlcycsXG4gICAgICAgICAgICAgICAgJ29yZGVyLWJvb2snLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZXMtYW5kLWluZm8nLFxuICAgICAgICAgICAgICAgICdvcGVuLW9yZGVycycsXG4gICAgICAgICAgICAgICAgJ3VzZXItdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAnYnRjLWRlcG9zaXQtYWRkcmVzcy9nZXQnLFxuICAgICAgICAgICAgICAgICdidGMtZGVwb3NpdC1hZGRyZXNzL25ldycsXG4gICAgICAgICAgICAgICAgJ2RlcG9zaXRzL2dldCcsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL2dldCcsXG4gICAgICAgICAgICAgICAgJ29yZGVycy9uZXcnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvZWRpdCcsXG4gICAgICAgICAgICAgICAgJ29yZGVycy9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMvbmV3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzQW5kSW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsnYmFsYW5jZXMtYW5kLWluZm8nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSwgY3VycmVuY3ksIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZVsnb25faG9sZCddLCBjdXJyZW5jeSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ29yZGVyLWJvb2snXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkJywgJ2FzaycsICdwcmljZScsICdvcmRlcl9hbW91bnQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKG1hcmtldCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN0YXRzICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydzdGF0cyddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21heCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21pbiddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF9wcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2RhaWx5X2NoYW5nZSddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndG90YWxfYnRjX3RyYWRlZCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFkJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ2RhdGUnXSArICcgMDA6MDA6MDAnKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydwcmljZSddKSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRIaXN0b3JpY2FsUHJpY2VzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3RpbWVmcmFtZSc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9obGN2cyA9IHRoaXMub21pdCAocmVzcG9uc2VbJ2hpc3RvcmljYWwtcHJpY2VzJ10sICdyZXF1ZXN0X2N1cnJlbmN5Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChvaGxjdnMsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ21ha2VyX3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhbnNhY3Rpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IHRoaXMub21pdCAocmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddLCAncmVxdWVzdF9jdXJyZW5jeScpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAodHJhZGVzLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnY3VycmVuY3knOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydsaW1pdF9wcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzTmV3ICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHQsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyc0NhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhd2Fsc05ldyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKGFtb3VudCksXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXVsndXVpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmlkID09ICdjcnlwdG9jYXBpdGFsJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBpcyBhbiBhYnN0cmFjdCBiYXNlIEFQSSBmb3IgXzFidGN4ZScpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIHF1ZXJ5WydzaWduYXR1cmUnXSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3JzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCByZXNwb25zZVsnZXJyb3JzJ10ubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSByZXNwb25zZVsnZXJyb3JzJ11bZV07XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2ggKGVycm9yWydjb2RlJ10gKyAnOiAnICsgZXJyb3JbJ21lc3NhZ2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuam9pbiAoJyAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgXzFidGN4ZSA9IGV4dGVuZCAoY3J5cHRvY2FwaXRhbCwge1xuXG4gICAgJ2lkJzogJ18xYnRjeGUnLFxuICAgICduYW1lJzogJzFCVENYRScsXG4gICAgJ2NvdW50cmllcyc6ICdQQScsIC8vIFBhbmFtYVxuICAgICdjb21tZW50JzogJ0NyeXB0byBDYXBpdGFsIEFQSScsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MDQ5LTJiMjk0NDA4LTVlY2MtMTFlNy04NWNjLWFkYWZmMDEzZGMxYS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vMWJ0Y3hlLmNvbS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vMWJ0Y3hlLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly8xYnRjeGUuY29tL2FwaS1kb2NzLnBocCcsXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICdVU0QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdCVEMvQ05ZJzogeyAnaWQnOiAnQ05ZJywgJ3N5bWJvbCc6ICdCVEMvQ05ZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAgICAgJ0JUQy9SVUInOiB7ICdpZCc6ICdSVUInLCAnc3ltYm9sJzogJ0JUQy9SVUInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnUlVCJyB9LFxuICAgICAgICAnQlRDL0NIRic6IHsgJ2lkJzogJ0NIRicsICdzeW1ib2wnOiAnQlRDL0NIRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDSEYnIH0sXG4gICAgICAgICdCVEMvSlBZJzogeyAnaWQnOiAnSlBZJywgJ3N5bWJvbCc6ICdCVEMvSlBZJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgJ0JUQy9HQlAnOiB7ICdpZCc6ICdHQlAnLCAnc3ltYm9sJzogJ0JUQy9HQlAnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnR0JQJyB9LFxuICAgICAgICAnQlRDL0NBRCc6IHsgJ2lkJzogJ0NBRCcsICdzeW1ib2wnOiAnQlRDL0NBRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDQUQnIH0sXG4gICAgICAgICdCVEMvQVVEJzogeyAnaWQnOiAnQVVEJywgJ3N5bWJvbCc6ICdCVEMvQVVEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0FVRCcgfSxcbiAgICAgICAgJ0JUQy9BRUQnOiB7ICdpZCc6ICdBRUQnLCAnc3ltYm9sJzogJ0JUQy9BRUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQUVEJyB9LFxuICAgICAgICAnQlRDL0JHTic6IHsgJ2lkJzogJ0JHTicsICdzeW1ib2wnOiAnQlRDL0JHTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdCR04nIH0sXG4gICAgICAgICdCVEMvQ1pLJzogeyAnaWQnOiAnQ1pLJywgJ3N5bWJvbCc6ICdCVEMvQ1pLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0NaSycgfSxcbiAgICAgICAgJ0JUQy9ES0snOiB7ICdpZCc6ICdES0snLCAnc3ltYm9sJzogJ0JUQy9ES0snLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnREtLJyB9LFxuICAgICAgICAnQlRDL0hLRCc6IHsgJ2lkJzogJ0hLRCcsICdzeW1ib2wnOiAnQlRDL0hLRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdIS0QnIH0sXG4gICAgICAgICdCVEMvSFJLJzogeyAnaWQnOiAnSFJLJywgJ3N5bWJvbCc6ICdCVEMvSFJLJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0hSSycgfSxcbiAgICAgICAgJ0JUQy9IVUYnOiB7ICdpZCc6ICdIVUYnLCAnc3ltYm9sJzogJ0JUQy9IVUYnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSFVGJyB9LFxuICAgICAgICAnQlRDL0lMUyc6IHsgJ2lkJzogJ0lMUycsICdzeW1ib2wnOiAnQlRDL0lMUycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdJTFMnIH0sXG4gICAgICAgICdCVEMvSU5SJzogeyAnaWQnOiAnSU5SJywgJ3N5bWJvbCc6ICdCVEMvSU5SJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0lOUicgfSxcbiAgICAgICAgJ0JUQy9NVVInOiB7ICdpZCc6ICdNVVInLCAnc3ltYm9sJzogJ0JUQy9NVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTVVSJyB9LFxuICAgICAgICAnQlRDL01YTic6IHsgJ2lkJzogJ01YTicsICdzeW1ib2wnOiAnQlRDL01YTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdNWE4nIH0sXG4gICAgICAgICdCVEMvTk9LJzogeyAnaWQnOiAnTk9LJywgJ3N5bWJvbCc6ICdCVEMvTk9LJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ05PSycgfSxcbiAgICAgICAgJ0JUQy9OWkQnOiB7ICdpZCc6ICdOWkQnLCAnc3ltYm9sJzogJ0JUQy9OWkQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTlpEJyB9LFxuICAgICAgICAnQlRDL1BMTic6IHsgJ2lkJzogJ1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICdCVEMvUk9OJzogeyAnaWQnOiAnUk9OJywgJ3N5bWJvbCc6ICdCVEMvUk9OJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1JPTicgfSxcbiAgICAgICAgJ0JUQy9TRUsnOiB7ICdpZCc6ICdTRUsnLCAnc3ltYm9sJzogJ0JUQy9TRUsnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0VLJyB9LFxuICAgICAgICAnQlRDL1NHRCc6IHsgJ2lkJzogJ1NHRCcsICdzeW1ib2wnOiAnQlRDL1NHRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTR0QnIH0sXG4gICAgICAgICdCVEMvVEhCJzogeyAnaWQnOiAnVEhCJywgJ3N5bWJvbCc6ICdCVEMvVEhCJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1RIQicgfSxcbiAgICAgICAgJ0JUQy9UUlknOiB7ICdpZCc6ICdUUlknLCAnc3ltYm9sJzogJ0JUQy9UUlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVFJZJyB9LFxuICAgICAgICAnQlRDL1pBUic6IHsgJ2lkJzogJ1pBUicsICdzeW1ib2wnOiAnQlRDL1pBUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdaQVInIH0sXG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGFjeCA9IHtcblxuICAgICdpZCc6ICdhY3gnLFxuICAgICduYW1lJzogJ0FDWCcsXG4gICAgJ2NvdW50cmllcyc6ICdBVScsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICcxbSc6ICcxJyxcbiAgICAgICAgJzVtJzogJzUnLFxuICAgICAgICAnMTVtJzogJzE1JyxcbiAgICAgICAgJzMwbSc6ICczMCcsXG4gICAgICAgICcxaCc6ICc2MCcsXG4gICAgICAgICcyaCc6ICcxMjAnLFxuICAgICAgICAnNGgnOiAnMjQwJyxcbiAgICAgICAgJzEyaCc6ICc3MjAnLFxuICAgICAgICAnMWQnOiAnMTQ0MCcsXG4gICAgICAgICczZCc6ICc0MzIwJyxcbiAgICAgICAgJzF3JzogJzEwMDgwJyxcbiAgICB9LFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMjQ3NjE0LTFmZTYxYzc0LTk2MjEtMTFlNy05ZThjLWYxYTYyN2FmYTI3OS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYWN4LmlvL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9hY3guaW8nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYWN4LmlvL2RvY3VtZW50cy9hcGlfdjInLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ21hcmtldHMnLCAvLyBHZXQgYWxsIGF2YWlsYWJsZSBtYXJrZXRzXG4gICAgICAgICAgICAgICAgJ3RpY2tlcnMnLCAvLyBHZXQgdGlja2VyIG9mIGFsbCBtYXJrZXRzXG4gICAgICAgICAgICAgICAgJ3RpY2tlcnMve21hcmtldH0nLCAvLyBHZXQgdGlja2VyIG9mIHNwZWNpZmljIG1hcmtldFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLCAvLyBHZXQgcmVjZW50IHRyYWRlcyBvbiBtYXJrZXQsIGVhY2ggdHJhZGUgaXMgaW5jbHVkZWQgb25seSBvbmNlIFRyYWRlcyBhcmUgc29ydGVkIGluIHJldmVyc2UgY3JlYXRpb24gb3JkZXIuXG4gICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2snLCAvLyBHZXQgdGhlIG9yZGVyIGJvb2sgb2Ygc3BlY2lmaWVkIG1hcmtldFxuICAgICAgICAgICAgICAgICdkZXB0aCcsIC8vIEdldCBkZXB0aCBvciBzcGVjaWZpZWQgbWFya2V0IEJvdGggYXNrcyBhbmQgYmlkcyBhcmUgc29ydGVkIGZyb20gaGlnaGVzdCBwcmljZSB0byBsb3dlc3QuXG4gICAgICAgICAgICAgICAgJ2snLCAvLyBHZXQgT0hMQyhrIGxpbmUpIG9mIHNwZWNpZmljIG1hcmtldFxuICAgICAgICAgICAgICAgICdrX3dpdGhfcGVuZGluZ190cmFkZXMnLCAvLyBHZXQgSyBkYXRhIHdpdGggcGVuZGluZyB0cmFkZXMsIHdoaWNoIGFyZSB0aGUgdHJhZGVzIG5vdCBpbmNsdWRlZCBpbiBLIGRhdGEgeWV0LCBiZWNhdXNlIHRoZXJlJ3MgZGVsYXkgYmV0d2VlbiB0cmFkZSBnZW5lcmF0ZWQgYW5kIHByb2Nlc3NlZCBieSBLIGRhdGEgZ2VuZXJhdG9yXG4gICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsIC8vIEdldCBzZXJ2ZXIgY3VycmVudCB0aW1lLCBpbiBzZWNvbmRzIHNpbmNlIFVuaXggZXBvY2hcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnbWVtYmVycy9tZScsIC8vIEdldCB5b3VyIHByb2ZpbGUgYW5kIGFjY291bnRzIGluZm9cbiAgICAgICAgICAgICAgICAnZGVwb3NpdHMnLCAvLyBHZXQgeW91ciBkZXBvc2l0cyBoaXN0b3J5XG4gICAgICAgICAgICAgICAgJ2RlcG9zaXQnLCAvLyBHZXQgZGV0YWlscyBvZiBzcGVjaWZpYyBkZXBvc2l0XG4gICAgICAgICAgICAgICAgJ2RlcG9zaXRfYWRkcmVzcycsIC8vIFdoZXJlIHRvIGRlcG9zaXQgVGhlIGFkZHJlc3MgZmllbGQgY291bGQgYmUgZW1wdHkgd2hlbiBhIG5ldyBhZGRyZXNzIGlzIGdlbmVyYXRpbmcgKGUuZy4gZm9yIGJpdGNvaW4pLCB5b3Ugc2hvdWxkIHRyeSBhZ2FpbiBsYXRlciBpbiB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgJ29yZGVycycsIC8vIEdldCB5b3VyIG9yZGVycywgcmVzdWx0cyBpcyBwYWdpbmF0ZWRcbiAgICAgICAgICAgICAgICAnb3JkZXInLCAvLyBHZXQgaW5mb3JtYXRpb24gb2Ygc3BlY2lmaWVkIG9yZGVyXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy9teScsIC8vIEdldCB5b3VyIGV4ZWN1dGVkIHRyYWRlcyBUcmFkZXMgYXJlIHNvcnRlZCBpbiByZXZlcnNlIGNyZWF0aW9uIG9yZGVyLlxuICAgICAgICAgICAgICAgICd3aXRoZHJhd3MnLCAvLyBHZXQgeW91ciBjcnlwdG9jdXJyZW5jeSB3aXRoZHJhd3NcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLCAvLyBHZXQgeW91ciBjcnlwdG9jdXJyZW5jeSB3aXRoZHJhd1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcnMnLCAvLyBDcmVhdGUgYSBTZWxsL0J1eSBvcmRlclxuICAgICAgICAgICAgICAgICdvcmRlcnMvbXVsdGknLCAvLyBDcmVhdGUgbXVsdGlwbGUgc2VsbC9idXkgb3JkZXJzXG4gICAgICAgICAgICAgICAgJ29yZGVycy9jbGVhcicsIC8vIENhbmNlbCBhbGwgbXkgb3JkZXJzXG4gICAgICAgICAgICAgICAgJ29yZGVyL2RlbGV0ZScsIC8vIENhbmNlbCBhbiBvcmRlclxuICAgICAgICAgICAgICAgICd3aXRoZHJhdycsIC8vIENyZWF0ZSBhIHdpdGhkcmF3XG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRNZW1iZXJzTWUgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydhY2NvdW50cyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydiYWxhbmNlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnbG9ja2VkJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdsaW1pdCc6IDMwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWydhdCddICogMTAwMDtcbiAgICAgICAgdGlja2VyID0gdGlja2VyWyd0aWNrZXInXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQ7XG4gICAgICAgICAgICBpZiAoaWQgaW4gdGhpcy5tYXJrZXRzX2J5X2lkKSB7XG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2Vyc01hcmtldCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAvLyBsb29rcyBsaWtlIHRoZXkgc3dpdGNoZWQgdGhpcyBlbmRwb2ludCBvZmZcbiAgICAgICAgLy8gaXQgcmV0dXJucyA1MDMgU2VydmljZSBUZW1wb3JhcmlseSBVbmF2YWlsYWJsZSBhbHdheXNcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlcG9uc2UsIG1hcmtldCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlswXSAqIDEwMDAsXG4gICAgICAgICAgICBvaGxjdlsxXSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzVdLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBpZiAoIWxpbWl0KVxuICAgICAgICAgICAgbGltaXQgPSA1MDA7IC8vIGRlZmF1bHQgaXMgMzBcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3BlcmlvZCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICAgICAgJ2xpbWl0JzogbGltaXQsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSlcbiAgICAgICAgICAgIHJlcXVlc3RbJ3RpbWVzdGFtcCddID0gc2luY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICd2b2x1bWUnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkX3R5cGUnOiB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKSB7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlLnRvU3RyaW5nICgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlcnMgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyRGVsZXRlICh7ICdpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3N1bSc6IGFtb3VudCxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvYXBpJyArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICcuanNvbic7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyByZXF1ZXN0O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMua2V5c29ydCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYWNjZXNzX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICd0b25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBtZXRob2QgKyAnfCcgKyByZXF1ZXN0ICsgJ3wnICsgcXVlcnk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IHF1ZXJ5ICsgJyZzaWduYXR1cmU9JyArIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgc3VmZml4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gc3VmZml4O1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGFueHBybyA9IHtcblxuICAgICdpZCc6ICdhbnhwcm8nLFxuICAgICduYW1lJzogJ0FOWFBybycsXG4gICAgJ2NvdW50cmllcyc6IFsgJ0pQJywgJ1NHJywgJ0hLJywgJ05aJyBdLFxuICAgICd2ZXJzaW9uJzogJzInLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NTk4My1mZDg1OTVkYS01ZWM5LTExZTctODJlMy1hZGIzYWI4YzI2MTIuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FueHByby5jb20vYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2FueHByby5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHA6Ly9kb2NzLmFueHYyLmFwaWFyeS5pbycsXG4gICAgICAgICAgICAnaHR0cHM6Ly9hbnhwcm8uY29tL3BhZ2VzL2FwaScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3tjdXJyZW5jeV9wYWlyfS9tb25leS9kZXB0aC9mdWxsJyxcbiAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L3RyYWRlL2ZldGNoJywgLy8gZGlzYWJsZWQgYnkgQU5YUHJvXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXIvYWRkJyxcbiAgICAgICAgICAgICAgICAne2N1cnJlbmN5X3BhaXJ9L21vbmV5L29yZGVyL2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ3tjdXJyZW5jeV9wYWlyfS9tb25leS9vcmRlci9xdW90ZScsXG4gICAgICAgICAgICAgICAgJ3tjdXJyZW5jeV9wYWlyfS9tb25leS9vcmRlci9yZXN1bHQnLFxuICAgICAgICAgICAgICAgICd7Y3VycmVuY3lfcGFpcn0vbW9uZXkvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnbW9uZXkve2N1cnJlbmN5fS9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnbW9uZXkve2N1cnJlbmN5fS9zZW5kX3NpbXBsZScsXG4gICAgICAgICAgICAgICAgJ21vbmV5L2luZm8nLFxuICAgICAgICAgICAgICAgICdtb25leS90cmFkZS9saXN0JyxcbiAgICAgICAgICAgICAgICAnbW9uZXkvd2FsbGV0L2hpc3RvcnknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ0JUQ1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdCVEMvSEtEJzogeyAnaWQnOiAnQlRDSEtEJywgJ3N5bWJvbCc6ICdCVEMvSEtEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0hLRCcgfSxcbiAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdCVENFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAnQlRDL0NBRCc6IHsgJ2lkJzogJ0JUQ0NBRCcsICdzeW1ib2wnOiAnQlRDL0NBRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDQUQnIH0sXG4gICAgICAgICdCVEMvQVVEJzogeyAnaWQnOiAnQlRDQVVEJywgJ3N5bWJvbCc6ICdCVEMvQVVEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0FVRCcgfSxcbiAgICAgICAgJ0JUQy9TR0QnOiB7ICdpZCc6ICdCVENTR0QnLCAnc3ltYm9sJzogJ0JUQy9TR0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0dEJyB9LFxuICAgICAgICAnQlRDL0pQWSc6IHsgJ2lkJzogJ0JUQ0pQWScsICdzeW1ib2wnOiAnQlRDL0pQWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICdCVEMvR0JQJzogeyAnaWQnOiAnQlRDR0JQJywgJ3N5bWJvbCc6ICdCVEMvR0JQJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0dCUCcgfSxcbiAgICAgICAgJ0JUQy9OWkQnOiB7ICdpZCc6ICdCVENOWkQnLCAnc3ltYm9sJzogJ0JUQy9OWkQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnTlpEJyB9LFxuICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ0xUQ0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdET0dFL0JUQyc6IHsgJ2lkJzogJ0RPR0VCVEMnLCAnc3ltYm9sJzogJ0RPR0UvQlRDJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdTVFIvQlRDJzogeyAnaWQnOiAnU1RSQlRDJywgJ3N5bWJvbCc6ICdTVFIvQlRDJywgJ2Jhc2UnOiAnU1RSJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1hSUC9CVEMnOiB7ICdpZCc6ICdYUlBCVEMnLCAnc3ltYm9sJzogJ1hSUC9CVEMnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RNb25leUluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZVsnV2FsbGV0cyddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIGJhbGFuY2VbJ1dhbGxldHMnXSkge1xuICAgICAgICAgICAgICAgIGxldCB3YWxsZXQgPSBiYWxhbmNlWydXYWxsZXRzJ11bY3VycmVuY3ldO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKHdhbGxldFsnQXZhaWxhYmxlX0JhbGFuY2UnXVsndmFsdWUnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKHdhbGxldFsnQmFsYW5jZSddWyd2YWx1ZSddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVBhaXJNb25leURlcHRoRnVsbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ2RhdGFVcGRhdGVUaW1lJ10pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHQgLyAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Ftb3VudCcpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAobWFya2V0KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lQYWlyTW9uZXlUaWNrZXIgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9wYWlyJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdCA9IHBhcnNlSW50ICh0aWNrZXJbJ2RhdGFVcGRhdGVUaW1lJ10pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHQgLyAxMDAwKTtcbiAgICAgICAgbGV0IGJpZCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXJbJ2J1eSddLCAndmFsdWUnKTtcbiAgICAgICAgbGV0IGFzayA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSwgJ3ZhbHVlJyk7O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ11bJ3ZhbHVlJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J11bJ3ZhbHVlJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IGJpZCxcbiAgICAgICAgICAgICdhc2snOiBhc2ssXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddWyd2YWx1ZSddKSxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXVsndmFsdWUnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZnJ11bJ3ZhbHVlJ10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddWyd2YWx1ZSddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGVycm9yID0gdGhpcy5pZCArICcgc3dpdGNoZWQgb2ZmIHRoZSB0cmFkZXMgZW5kcG9pbnQsIHNlZSB0aGVpciBkb2NzIGF0IGh0dHA6Ly9kb2NzLmFueHYyLmFwaWFyeS5pby9yZWZlcmVuY2UvbWFya2V0LWRhdGEvY3VycmVuY3lwYWlybW9uZXl0cmFkZWZldGNoLWRpc2FibGVkJztcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljR2V0Q3VycmVuY3lQYWlyTW9uZXlUcmFkZUZldGNoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5X3BhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICAgICAgJ2Ftb3VudF9pbnQnOiBwYXJzZUludCAoYW1vdW50ICogMTAwMDAwMDAwKSwgLy8gMTBeOFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlX2ludCddID0gcGFyc2VJbnQgKHByaWNlICogMTAwMDAwKTsgLy8gMTBeNVxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEN1cnJlbmN5UGFpck9yZGVyQWRkICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHRbJ2RhdGEnXVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDdXJyZW5jeVBhaXJPcmRlckNhbmNlbCAoeyAnb2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TW9uZXlDdXJyZW5jeVNlbmRTaW1wbGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhbW91bnRfaW50JzogcGFyc2VJbnQgKGFtb3VudCAqIDEwMDAwMDAwMCksIC8vIDEwXjhcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3VsdCddWyd1dWlkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcmVxdWVzdDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzZWNyZXQgPSB0aGlzLmJhc2U2NFRvQmluYXJ5ICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHJlcXVlc3QgKyBcIlxcMFwiICsgYm9keTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgc2VjcmV0LCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ1Jlc3QtS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1Jlc3QtU2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgncmVzdWx0JyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsncmVzdWx0J10gPT0gJ3N1Y2Nlc3MnKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYmluYW5jZSA9IHtcblxuICAgICdpZCc6ICdiaW5hbmNlJyxcbiAgICAnbmFtZSc6ICdCaW5hbmNlJyxcbiAgICAnY291bnRyaWVzJzogJ0NOJywgLy8gQ2hpbmFcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICczbSc6ICczbScsXG4gICAgICAgICc1bSc6ICc1bScsXG4gICAgICAgICcxNW0nOiAnMTVtJyxcbiAgICAgICAgJzMwbSc6ICczMG0nLFxuICAgICAgICAnMWgnOiAnMWgnLFxuICAgICAgICAnMmgnOiAnMmgnLFxuICAgICAgICAnNGgnOiAnNGgnLFxuICAgICAgICAnNmgnOiAnNmgnLFxuICAgICAgICAnOGgnOiAnOGgnLFxuICAgICAgICAnMTJoJzogJzEyaCcsXG4gICAgICAgICcxZCc6ICcxZCcsXG4gICAgICAgICczZCc6ICczZCcsXG4gICAgICAgICcxdyc6ICcxdycsXG4gICAgICAgICcxTSc6ICcxTScsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yOTYwNDAyMC1kNTQ4M2NkYy04N2VlLTExZTctOTRjNy1kMWE4ZDkxNjkyOTMuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5iaW5hbmNlLmNvbS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJpbmFuY2UuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5iaW5hbmNlLmNvbS9yZXN0YXBpcHViLmh0bWwnLFxuICAgICAgICAnZmVlcyc6ICdodHRwczovL2JpbmFuY2UuemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMTE1MDAwNDI5MzMyJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdwaW5nJyxcbiAgICAgICAgICAgICAgICAndGltZScsXG4gICAgICAgICAgICAgICAgJ2RlcHRoJyxcbiAgICAgICAgICAgICAgICAnYWdnVHJhZGVzJyxcbiAgICAgICAgICAgICAgICAna2xpbmVzJyxcbiAgICAgICAgICAgICAgICAndGlja2VyLzI0aHInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICdhbGxPcmRlcnMnLFxuICAgICAgICAgICAgICAgICdhY2NvdW50JyxcbiAgICAgICAgICAgICAgICAnbXlUcmFkZXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ29yZGVyL3Rlc3QnLFxuICAgICAgICAgICAgICAgICd1c2VyRGF0YVN0cmVhbScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAndXNlckRhdGFTdHJlYW0nXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICd1c2VyRGF0YVN0cmVhbScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ2ZlZXMnOiB7XG4gICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDEsXG4gICAgICAgICAgICAnbWFrZXInOiAwLjAwMSxcbiAgICAgICAgfSxcbiAgICAgICAgJ2Z1bmRpbmcnOiB7XG4gICAgICAgICAgICAnd2l0aGRyYXcnOiB7XG4gICAgICAgICAgICAgICAgJ0JOQic6IDEuMCxcbiAgICAgICAgICAgICAgICAnQlRDJzogMC4wMDA1LFxuICAgICAgICAgICAgICAgICdFVEgnOiAwLjAwNSxcbiAgICAgICAgICAgICAgICAnTFRDJzogMC4wMDEsXG4gICAgICAgICAgICAgICAgJ05FTyc6IDAuMCxcbiAgICAgICAgICAgICAgICAnUVRVTSc6IDAuMSxcbiAgICAgICAgICAgICAgICAnU05UJzogMS4wLFxuICAgICAgICAgICAgICAgICdFT1MnOiAwLjEsXG4gICAgICAgICAgICAgICAgJ0JDQyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAnR0FTJzogMC4wLFxuICAgICAgICAgICAgICAgICdVU0RUJzogNS4wLFxuICAgICAgICAgICAgICAgICdIU1InOiAwLjAwMDEsXG4gICAgICAgICAgICAgICAgJ09BWCc6IDAuMSxcbiAgICAgICAgICAgICAgICAnRE5UJzogMS4wLFxuICAgICAgICAgICAgICAgICdNQ08nOiAwLjEsXG4gICAgICAgICAgICAgICAgJ0lDTic6IDAuMSxcbiAgICAgICAgICAgICAgICAnV1RDJzogMC4xLFxuICAgICAgICAgICAgICAgICdPTUcnOiAwLjEsXG4gICAgICAgICAgICAgICAgJ1pSWCc6IDEuMCxcbiAgICAgICAgICAgICAgICAnU1RSQVQnOiAwLjEsXG4gICAgICAgICAgICAgICAgJ1NOR0xTJzogMS4wLFxuICAgICAgICAgICAgICAgICdCUVgnOiAxLjAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCTkIvQlRDJzogeyAnaWQnOiAnQk5CQlRDJywgJ3N5bWJvbCc6ICdCTkIvQlRDJywgJ2Jhc2UnOiAnQk5CJywgJ3F1b3RlJzogJ0JUQycsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnTkVPL0JUQyc6IHsgJ2lkJzogJ05FT0JUQycsICdzeW1ib2wnOiAnTkVPL0JUQycsICdiYXNlJzogJ05FTycsICdxdW90ZSc6ICdCVEMnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICdFVEhCVEMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdIU1IvQlRDJzogeyAnaWQnOiAnSFNSQlRDJywgJ3N5bWJvbCc6ICdIU1IvQlRDJywgJ2Jhc2UnOiAnSFNSJywgJ3F1b3RlJzogJ0JUQycsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ0xUQ0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ0dBUy9CVEMnOiB7ICdpZCc6ICdHQVNCVEMnLCAnc3ltYm9sJzogJ0dBUy9CVEMnLCAnYmFzZSc6ICdHQVMnLCAncXVvdGUnOiAnQlRDJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdIQ0MvQlRDJzogeyAnaWQnOiAnSENDQlRDJywgJ3N5bWJvbCc6ICdIQ0MvQlRDJywgJ2Jhc2UnOiAnSENDJywgJ3F1b3RlJzogJ0JUQycsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnQkNIL0JUQyc6IHsgJ2lkJzogJ0JDQ0JUQycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ0JOQi9FVEgnOiB7ICdpZCc6ICdCTkJFVEgnLCAnc3ltYm9sJzogJ0JOQi9FVEgnLCAnYmFzZSc6ICdCTkInLCAncXVvdGUnOiAnRVRIJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdETlQvRVRIJzogeyAnaWQnOiAnRE5URVRIJywgJ3N5bWJvbCc6ICdETlQvRVRIJywgJ2Jhc2UnOiAnRE5UJywgJ3F1b3RlJzogJ0VUSCcsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnT0FYL0VUSCc6IHsgJ2lkJzogJ09BWEVUSCcsICdzeW1ib2wnOiAnT0FYL0VUSCcsICdiYXNlJzogJ09BWCcsICdxdW90ZSc6ICdFVEgnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ01DTy9FVEgnOiB7ICdpZCc6ICdNQ09FVEgnLCAnc3ltYm9sJzogJ01DTy9FVEgnLCAnYmFzZSc6ICdNQ08nLCAncXVvdGUnOiAnRVRIJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdCVE0vRVRIJzogeyAnaWQnOiAnQlRNRVRIJywgJ3N5bWJvbCc6ICdCVE0vRVRIJywgJ2Jhc2UnOiAnQlRNJywgJ3F1b3RlJzogJ0VUSCcsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnU05UL0VUSCc6IHsgJ2lkJzogJ1NOVEVUSCcsICdzeW1ib2wnOiAnU05UL0VUSCcsICdiYXNlJzogJ1NOVCcsICdxdW90ZSc6ICdFVEgnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ0VPUy9FVEgnOiB7ICdpZCc6ICdFT1NFVEgnLCAnc3ltYm9sJzogJ0VPUy9FVEgnLCAnYmFzZSc6ICdFT1MnLCAncXVvdGUnOiAnRVRIJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdCTlQvRVRIJzogeyAnaWQnOiAnQk5URVRIJywgJ3N5bWJvbCc6ICdCTlQvRVRIJywgJ2Jhc2UnOiAnQk5UJywgJ3F1b3RlJzogJ0VUSCcsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnSUNOL0VUSCc6IHsgJ2lkJzogJ0lDTkVUSCcsICdzeW1ib2wnOiAnSUNOL0VUSCcsICdiYXNlJzogJ0lDTicsICdxdW90ZSc6ICdFVEgnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICAgICAgJ0JUQy9VU0RUJzogeyAnaWQnOiAnQlRDVVNEVCcsICdzeW1ib2wnOiAnQlRDL1VTRFQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEVCcsICd0YWtlcic6IDAuMDAxLCAnbWFrZXInOiAwLjAwMSB9LFxuICAgICAgICAnRVRIL1VTRFQnOiB7ICdpZCc6ICdFVEhVU0RUJywgJ3N5bWJvbCc6ICdFVEgvVVNEVCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVU0RUJywgJ3Rha2VyJzogMC4wMDEsICdtYWtlcic6IDAuMDAxIH0sXG4gICAgICAgICdRVFVNL0VUSCc6IHsgJ2lkJzogJ1FUVU1FVEgnLCAnc3ltYm9sJzogJ1FUVU0vRVRIJywgJ2Jhc2UnOiAnUVRVTScsICdxdW90ZSc6ICdFVEgnLCAndGFrZXInOiAwLjAwMSwgJ21ha2VyJzogMC4wMDEgfSxcbiAgICB9LFxuXG4gICAgY2FsY3VsYXRlRmVlUmF0ZSAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIgPSAndGFrZXInLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQga2V5ID0gKHNpZGUgPT0gJ3NlbGwnKSA/ICdiYXNlJyA6ICdxdW90ZSc7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgcmV0dXJuIHsgJ2N1cnJlbmN5JzogbWFya2V0W2tleV0sICdyYXRlJzogbWFya2V0W3Rha2VyT3JNYWtlcl0gfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBY2NvdW50ICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlcyddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGFzc2V0ID0gYmFsYW5jZVsnYXNzZXQnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChhc3NldCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2ZyZWUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydsb2NrZWQnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogMC4wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnbGltaXQnOiAxMDAsIC8vIGRlZmF1bHQgPSBtYXhpbXVtID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ2Nsb3NlVGltZSddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoUHJpY2UnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dQcmljZSddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZFByaWNlJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrUHJpY2UnXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnd2VpZ2h0ZWRBdmdQcmljZSddKSxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuUHJpY2UnXSksXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ByZXZDbG9zZVByaWNlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ByaWNlQ2hhbmdlUGVyY2VudCddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcjI0aHIgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0sXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsxXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsyXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlszXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdls0XSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdls1XSksXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdpbnRlcnZhbCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0WydsaW1pdCddID0gKGxpbWl0KSA/IGxpbWl0IDogNTAwOyAvLyBkZWZhdWx0ID09IG1heCA9PSA1MDBcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnRUaW1lJ10gPSBzaW5jZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRLbGluZXMgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wRmllbGQgPSAoJ1QnIGluIHRyYWRlKSA/ICdUJyA6ICd0aW1lJztcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlW3RpbWVzdGFtcEZpZWxkXTtcbiAgICAgICAgbGV0IHByaWNlRmllbGQgPSAoJ3AnIGluIHRyYWRlKSA/ICdwJyA6ICdwcmljZSc7XG4gICAgICAgIGxldCBwcmljZSA9IHBhcnNlRmxvYXQgKHRyYWRlW3ByaWNlRmllbGRdKTtcbiAgICAgICAgbGV0IGFtb3VudEZpZWxkID0gKCdxJyBpbiB0cmFkZSkgPyAncScgOiAncXR5JztcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKHRyYWRlW2Ftb3VudEZpZWxkXSk7XG4gICAgICAgIGxldCBpZEZpZWxkID0gKCdhJyBpbiB0cmFkZSkgPyAnYScgOiAnaWQnO1xuICAgICAgICBsZXQgaWQgPSB0cmFkZVtpZEZpZWxkXS50b1N0cmluZyAoKTtcbiAgICAgICAgbGV0IHNpZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnbScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHNpZGUgPSAnc2VsbCc7XG4gICAgICAgICAgICBpZiAodHJhZGVbJ20nXSlcbiAgICAgICAgICAgICAgICBzaWRlID0gJ2J1eSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXNCdXllciA9IHRyYWRlWydpc0J1eWVyJ107XG4gICAgICAgICAgICBsZXQgaXNNYWtlciA9IHRyYWRlWydpc01ha2VyJ107XG4gICAgICAgICAgICBpZiAoaXNCdXllcikge1xuICAgICAgICAgICAgICAgIHNpZGUgPSBpc01ha2VyID8gJ3NlbGwnIDogJ2J1eSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNpZGUgPSBpc01ha2VyID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QWdnVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIC8vICdmcm9tSWQnOiAxMjMsICAgIC8vIElEIHRvIGdldCBhZ2dyZWdhdGUgdHJhZGVzIGZyb20gSU5DTFVTSVZFLlxuICAgICAgICAgICAgLy8gJ3N0YXJ0VGltZSc6IDQ1NiwgLy8gVGltZXN0YW1wIGluIG1zIHRvIGdldCBhZ2dyZWdhdGUgdHJhZGVzIGZyb20gSU5DTFVTSVZFLlxuICAgICAgICAgICAgLy8gJ2VuZFRpbWUnOiA3ODksICAgLy8gVGltZXN0YW1wIGluIG1zIHRvIGdldCBhZ2dyZWdhdGUgdHJhZGVzIHVudGlsIElOQ0xVU0lWRS5cbiAgICAgICAgICAgICdsaW1pdCc6IDUwMCwgICAgICAgIC8vIGRlZmF1bHQgPSBtYXhpbXVtID0gNTAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXJTdGF0dXMgKHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09ICdORVcnKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKHN0YXR1cyA9PSAnUEFSVElBTExZX0ZJTExFRCcpXG4gICAgICAgICAgICByZXR1cm4gJ29wZW4nO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdGSUxMRUQnKVxuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICBpZiAoc3RhdHVzID09ICdDQU5DRUxFRCcpXG4gICAgICAgICAgICByZXR1cm4gJ2NhbmNlbGVkJztcbiAgICAgICAgcmV0dXJuIHN0YXR1cy50b0xvd2VyQ2FzZSAoKTtcbiAgICB9LFxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc3RhdHVzID0gdGhpcy5wYXJzZU9yZGVyU3RhdHVzIChvcmRlclsnc3RhdHVzJ10pO1xuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlkID0gb3JkZXJbJ3N5bWJvbCddO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJbJ3RpbWUnXTtcbiAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlRmxvYXQgKG9yZGVyWydvcmlnUXR5J10pO1xuICAgICAgICBsZXQgZmlsbGVkID0gdGhpcy5zYWZlRmxvYXQgKG9yZGVyLCAnZXhlY3V0ZWRRdHknLCAwLjApO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gTWF0aC5tYXggKGFtb3VudCAtIGZpbGxlZCwgMC4wKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnb3JkZXJJZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyWyd0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAnc2lkZSc6IG9yZGVyWydzaWRlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0IChvcmRlclsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAnc3RhdHVzJzogc3RhdHVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBwcmljZSA9IHBhcnNlRmxvYXQgKHByaWNlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQudG9GaXhlZCAoOCksXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZS50b0ZpeGVkICg4KSxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICd0aW1lSW5Gb3JjZSc6ICdHVEMnLCAvLyBHb29kIFRvIENhbmNlbCAoZGVmYXVsdClcbiAgICAgICAgICAgIC8vICd0aW1lSW5Gb3JjZSc6ICdJT0MnLCAvLyBJbW1lZGlhdGUgT3IgQ2FuY2VsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXJJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9ICgnc3ltYm9sJyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIHN5bWJvbCA9IHBhcmFtc1snc3ltYm9sJ107XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsICdzeW1ib2wnKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0T3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ29yZGVySWQnOiBpZC50b1N0cmluZyAoKSxcbiAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJzIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoJ3N5bWJvbCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gcGFyYW1zWydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCAnc3ltYm9sJyk7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRBbGxPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoIXN5bWJvbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBmZXRjaE9wZW5PcmRlcnMgcmVxdWlyZXMgYSBzeW1ib2wgcGFyYW0nKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRPcGVuT3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVySWQnOiBwYXJzZUludCAoaWQpLFxuICAgICAgICAgICAgLy8gJ29yaWdDbGllbnRPcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAndGltZXN0YW1wJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuc2VjcmV0ICsgJ3wnICsgcXVlcnk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAoYXV0aCksICdzaGEyNTYnKTtcbiAgICAgICAgICAgIHF1ZXJ5ICs9ICcmJyArICdzaWduYXR1cmU9JyArIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtTUJYLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBxdWVyeTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydjb2RlJ10gPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBiaXQyYyA9IHtcblxuICAgICdpZCc6ICdiaXQyYycsXG4gICAgJ25hbWUnOiAnQml0MkMnLFxuICAgICdjb3VudHJpZXMnOiAnSUwnLCAvLyBJc3JhZWxcbiAgICAncmF0ZUxpbWl0JzogMzAwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MTE5LTM1OTMyMjBlLTVlY2UtMTFlNy04YjNhLTVhMDQxZjZiY2MzZi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdDJjLmNvLmlsJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXQyYy5jby5pbCcsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0MmMuY28uaWwvaG9tZS9hcGknLFxuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9PZmVyRS9iaXQyYycsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnRXhjaGFuZ2VzL3twYWlyfS9UaWNrZXInLFxuICAgICAgICAgICAgICAgICdFeGNoYW5nZXMve3BhaXJ9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgJ0V4Y2hhbmdlcy97cGFpcn0vdHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvQmFsYW5jZS92MicsXG4gICAgICAgICAgICAgICAgJ01lcmNoYW50L0NyZWF0ZUNoZWNrb3V0JyxcbiAgICAgICAgICAgICAgICAnT3JkZXIvQWNjb3VudEhpc3RvcnknLFxuICAgICAgICAgICAgICAgICdPcmRlci9BZGRDb2luRnVuZHNSZXF1ZXN0JyxcbiAgICAgICAgICAgICAgICAnT3JkZXIvQWRkRnVuZCcsXG4gICAgICAgICAgICAgICAgJ09yZGVyL0FkZE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnT3JkZXIvQWRkT3JkZXJNYXJrZXRQcmljZUJ1eScsXG4gICAgICAgICAgICAgICAgJ09yZGVyL0FkZE9yZGVyTWFya2V0UHJpY2VTZWxsJyxcbiAgICAgICAgICAgICAgICAnT3JkZXIvQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdPcmRlci9NeU9yZGVycycsXG4gICAgICAgICAgICAgICAgJ1BheW1lbnQvR2V0TXlJZCcsXG4gICAgICAgICAgICAgICAgJ1BheW1lbnQvU2VuZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvTklTJzogeyAnaWQnOiAnQnRjTmlzJywgJ3N5bWJvbCc6ICdCVEMvTklTJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ05JUycgfSxcbiAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdMdGNCdGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTFRDL05JUyc6IHsgJ2lkJzogJ0x0Y05pcycsICdzeW1ib2wnOiAnTFRDL05JUycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdOSVMnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QWNjb3VudEJhbGFuY2VWMiAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9ICdBVkFJTEFCTEVfJyArIGN1cnJlbmN5O1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VbYXZhaWxhYmxlXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZVtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlc1BhaXJPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKG1hcmtldCkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZXNQYWlyVGlja2VyICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsJ10pLFxuICAgICAgICAgICAgJ2JpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhc2snOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xsJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2J10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2EnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlc1BhaXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdE9yZGVyQWRkT3JkZXInO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnQW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ1BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdNYXJrZXRQcmljZScgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ1ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWydUb3RhbCddID0gYW1vdW50ICogcHJpY2U7XG4gICAgICAgICAgICBvcmRlclsnSXNCaWQnXSA9IChzaWRlID09ICdidXknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiByZXN1bHRbJ05ld09yZGVyJ11bJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyQ2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmpzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdGJheSA9IHtcblxuICAgICdpZCc6ICdiaXRiYXknLFxuICAgICduYW1lJzogJ0JpdEJheScsXG4gICAgJ2NvdW50cmllcyc6IFsgJ1BMJywgJ0VVJyBdLCAvLyBQb2xhbmRcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ2hhc1dpdGhkcmF3JzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjEzMi05NzhhN2JkOC01ZWNlLTExZTctOTU0MC1iYzk2ZDFlOWJiYjguanBnJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdGJheS5uZXQnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2JpdGJheS5uZXQvQVBJL1B1YmxpYycsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2JpdGJheS5uZXQvQVBJL1RyYWRpbmcvdHJhZGluZ0FwaS5waHAnLFxuICAgICAgICB9LFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYml0YmF5Lm5ldC9wdWJsaWMtYXBpJyxcbiAgICAgICAgICAgICdodHRwczovL2JpdGJheS5uZXQvYWNjb3VudC90YWItYXBpJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vQml0QmF5TmV0L0FQSScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne2lkfS9hbGwnLFxuICAgICAgICAgICAgICAgICd7aWR9L21hcmtldCcsXG4gICAgICAgICAgICAgICAgJ3tpZH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAne2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICd7aWR9L3RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnQlRDVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdCVENFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAnQlRDL1BMTic6IHsgJ2lkJzogJ0JUQ1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICdMVEMvVVNEJzogeyAnaWQnOiAnTFRDVVNEJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0xUQy9FVVInOiB7ICdpZCc6ICdMVENFVVInLCAnc3ltYm9sJzogJ0xUQy9FVVInLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAnTFRDL1BMTic6IHsgJ2lkJzogJ0xUQ1BMTicsICdzeW1ib2wnOiAnTFRDL1BMTicsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0VUSC9VU0QnOiB7ICdpZCc6ICdFVEhVU0QnLCAnc3ltYm9sJzogJ0VUSC9VU0QnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnRVRIL0VVUic6IHsgJ2lkJzogJ0VUSEVVUicsICdzeW1ib2wnOiAnRVRIL0VVUicsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdFVEgvUExOJzogeyAnaWQnOiAnRVRIUExOJywgJ3N5bWJvbCc6ICdFVEgvUExOJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICdFVEhCVEMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTFNLL1VTRCc6IHsgJ2lkJzogJ0xTS1VTRCcsICdzeW1ib2wnOiAnTFNLL1VTRCcsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdMU0svRVVSJzogeyAnaWQnOiAnTFNLRVVSJywgJ3N5bWJvbCc6ICdMU0svRVVSJywgJ2Jhc2UnOiAnTFNLJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ0xTSy9QTE4nOiB7ICdpZCc6ICdMU0tQTE4nLCAnc3ltYm9sJzogJ0xTSy9QTE4nLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnUExOJyB9LFxuICAgICAgICAnTFNLL0JUQyc6IHsgJ2lkJzogJ0xTS0JUQycsICdzeW1ib2wnOiAnTFNLL0JUQycsICdiYXNlJzogJ0xTSycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydhdmFpbGFibGUnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2xvY2tlZCddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAobWFya2V0KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldElkVGlja2VyICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXgnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydtaW4nXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHBhcnNlRmxvYXQgKHRpY2tlclsndndhcCddKSxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZlcmFnZSddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3BheW1lbnRfY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBpc0ZpYXQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGxldCBmaWF0Q3VycmVuY2llcyA9IHtcbiAgICAgICAgICAgICdVU0QnOiB0cnVlLFxuICAgICAgICAgICAgJ0VVUic6IHRydWUsXG4gICAgICAgICAgICAnUExOJzogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN1cnJlbmN5IGluIGZpYXRDdXJyZW5jaWVzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmlzRmlhdCAoY3VycmVuY3kpKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAncHJpdmF0ZVBvc3RXaXRoZHJhdyc7XG4gICAgICAgICAgICAvLyByZXF1ZXN0WydhY2NvdW50J10gPSBwYXJhbXNbJ2FjY291bnQnXTsgLy8gdGhleSBkZW1hbmQgYW4gYWNjb3VudCBudW1iZXJcbiAgICAgICAgICAgIC8vIHJlcXVlc3RbJ2V4cHJlc3MnXSA9IHBhcmFtc1snZXhwcmVzcyddOyAvLyB3aGF0ZXZlciBpdCBtZWFucywgdGhleSBkb24ndCBleHBsYWluXG4gICAgICAgICAgICAvLyByZXF1ZXN0WydiaWMnXSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0VHJhbnNmZXInO1xuICAgICAgICAgICAgcmVxdWVzdFsnYWRkcmVzcyddID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICcuanNvbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ21vbWVudCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBUEktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FQSS1IYXNoJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBiaXRjb2luY29pZCA9IHtcblxuICAgICdpZCc6ICdiaXRjb2luY29pZCcsXG4gICAgJ25hbWUnOiAnQml0Y29pbi5jby5pZCcsXG4gICAgJ2NvdW50cmllcyc6ICdJRCcsIC8vIEluZG9uZXNpYVxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYxMzgtMDQzYzc3ODYtNWVjZi0xMWU3LTg4MmItODA5YzE0ZjM4YjUzLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vdmlwLmJpdGNvaW4uY28uaWQvYXBpJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vdmlwLmJpdGNvaW4uY28uaWQvdGFwaScsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0Y29pbi5jby5pZCcsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly92aXAuYml0Y29pbi5jby5pZC9kb3dubG9hZHMvQklUQ09JTkNPSUQtQVBJLURPQ1VNRU5UQVRJT04ucGRmJyxcbiAgICAgICAgICAgICdodHRwczovL3ZpcC5iaXRjb2luLmNvLmlkL3RyYWRlX2FwaScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne3BhaXJ9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3twYWlyfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICd7cGFpcn0vZGVwdGgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAndHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9JRFInOiAgeyAnaWQnOiAnYnRjX2lkcicsICdzeW1ib2wnOiAnQlRDL0lEUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2J0YycsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ0JDSC9JRFInOiAgeyAnaWQnOiAnYmNoX2lkcicsICdzeW1ib2wnOiAnQkNIL0lEUicsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2JjaCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ0VUSC9JRFInOiAgeyAnaWQnOiAnZXRoX2lkcicsICdzeW1ib2wnOiAnRVRIL0lEUicsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2V0aCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ0VUQy9JRFInOiAgeyAnaWQnOiAnZXRjX2lkcicsICdzeW1ib2wnOiAnRVRDL0lEUicsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ2V0YycsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ1hSUC9JRFInOiAgeyAnaWQnOiAneHJwX2lkcicsICdzeW1ib2wnOiAnWFJQL0lEUicsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ3hycCcsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ1haQy9JRFInOiAgeyAnaWQnOiAneHpjX2lkcicsICdzeW1ib2wnOiAnWFpDL0lEUicsICdiYXNlJzogJ1haQycsICdxdW90ZSc6ICdJRFInLCAnYmFzZUlkJzogJ3h6YycsICdxdW90ZUlkJzogJ2lkcicgfSxcbiAgICAgICAgJ0JUUy9CVEMnOiAgeyAnaWQnOiAnYnRzX2J0YycsICdzeW1ib2wnOiAnQlRTL0JUQycsICdiYXNlJzogJ0JUUycsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2J0cycsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAnZHJrX2J0YycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnZHJrJywgJ3F1b3RlSWQnOiAnYnRjJyB9LFxuICAgICAgICAnRE9HRS9CVEMnOiB7ICdpZCc6ICdkb2dlX2J0YycsICdzeW1ib2wnOiAnRE9HRS9CVEMnLCAnYmFzZSc6ICdET0dFJywgJ3F1b3RlJzogJ0JUQycsICdiYXNlSWQnOiAnZG9nZScsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiAgeyAnaWQnOiAnZXRoX2J0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2V0aCcsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ0xUQy9CVEMnOiAgeyAnaWQnOiAnbHRjX2J0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ2x0YycsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ05YVC9CVEMnOiAgeyAnaWQnOiAnbnh0X2J0YycsICdzeW1ib2wnOiAnTlhUL0JUQycsICdiYXNlJzogJ05YVCcsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ254dCcsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ1hMTS9CVEMnOiAgeyAnaWQnOiAnc3RyX2J0YycsICdzeW1ib2wnOiAnWExNL0JUQycsICdiYXNlJzogJ1hMTScsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ3N0cicsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ1hFTS9CVEMnOiAgeyAnaWQnOiAnbmVtX2J0YycsICdzeW1ib2wnOiAnWEVNL0JUQycsICdiYXNlJzogJ1hFTScsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ25lbScsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICAgICAgJ1hSUC9CVEMnOiAgeyAnaWQnOiAneHJwX2J0YycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnLCAnYmFzZUlkJzogJ3hycCcsICdxdW90ZUlkJzogJ2J0YycgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddLCBsb3dlcmNhc2UsIDAuMCk7XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZV9ob2xkJ10sIGxvd2VyY2FzZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpckRlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpclRpY2tlciAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VGbG9hdCAodGlja2VyWydzZXJ2ZXJfdGltZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gJ3ZvbF8nICsgbWFya2V0WydiYXNlSWQnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gJ3ZvbF8nICsgbWFya2V0WydxdW90ZUlkJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlcltiYXNlVm9sdW1lXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbcXVvdGVWb2x1bWVdKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQYWlyVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2UnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgb3JkZXJbYmFzZV0gPSBhbW91bnQ7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsncmV0dXJuJ11bJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdub25jZSc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHJlc3BvbnNlWydlcnJvciddKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdGZpbmV4ID0ge1xuXG4gICAgJ2lkJzogJ2JpdGZpbmV4JyxcbiAgICAnbmFtZSc6ICdCaXRmaW5leCcsXG4gICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MjQ0LWUzMjhhNTBjLTVlZDItMTFlNy05NDdiLTA0MTQxNjU3OWJiMy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZpbmV4LmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0ZmluZXguY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL2JpdGZpbmV4LnJlYWRtZS5pby92MS9kb2NzJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYml0ZmluZXhjb20vYml0ZmluZXgtYXBpLW5vZGUnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgIC8vICdjYW5kbGVzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAnbGVuZGJvb2sve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgJ2xlbmRzL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICdwdWJ0aWNrZXIve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICdzdGF0cy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbHMnLFxuICAgICAgICAgICAgICAgICdzeW1ib2xzX2RldGFpbHMnLFxuICAgICAgICAgICAgICAgICd0b2RheScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdhY2NvdW50X2luZm9zJyxcbiAgICAgICAgICAgICAgICAnYmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICdiYXNrZXRfbWFuYWdlJyxcbiAgICAgICAgICAgICAgICAnY3JlZGl0cycsXG4gICAgICAgICAgICAgICAgJ2RlcG9zaXQvbmV3JyxcbiAgICAgICAgICAgICAgICAnZnVuZGluZy9jbG9zZScsXG4gICAgICAgICAgICAgICAgJ2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdoaXN0b3J5L21vdmVtZW50cycsXG4gICAgICAgICAgICAgICAgJ2tleV9pbmZvJyxcbiAgICAgICAgICAgICAgICAnbWFyZ2luX2luZm9zJyxcbiAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICdteXRyYWRlc19mdW5kaW5nJyxcbiAgICAgICAgICAgICAgICAnb2ZmZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnb2ZmZXIvbmV3JyxcbiAgICAgICAgICAgICAgICAnb2ZmZXIvc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAnb2ZmZXJzJyxcbiAgICAgICAgICAgICAgICAnb2ZmZXJzL2hpc3QnLFxuICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwvYWxsJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL211bHRpJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL3JlcGxhY2UnLFxuICAgICAgICAgICAgICAgICdvcmRlci9uZXcnLFxuICAgICAgICAgICAgICAgICdvcmRlci9uZXcvbXVsdGknLFxuICAgICAgICAgICAgICAgICdvcmRlci9zdGF0dXMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvaGlzdCcsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2NsYWltJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb25zJyxcbiAgICAgICAgICAgICAgICAnc3VtbWFyeScsXG4gICAgICAgICAgICAgICAgJ3Rha2VuX2Z1bmRzJyxcbiAgICAgICAgICAgICAgICAndG90YWxfdGFrZW5fZnVuZHMnLFxuICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgJ3VudXNlZF90YWtlbl9mdW5kcycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xzRGV0YWlscyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydwYWlyJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYmFzZUlkID0gaWQuc2xpY2UgKDAsIDMpO1xuICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGJhc2VJZDtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHF1b3RlSWQ7XG4gICAgICAgICAgICAvLyBpc3N1ZSAjNCBCaXRmaW5leCBuYW1lcyBEYXNoIGFzIERTSCwgaW5zdGVhZCBvZiBEQVNIXG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2Jhc2VJZCc6IGJhc2VJZCxcbiAgICAgICAgICAgICAgICAncXVvdGVJZCc6IHF1b3RlSWQsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWxhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlWyd0eXBlJ10gPT0gJ2V4Y2hhbmdlJykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIC8vIGlzc3VlICM0IEJpdGZpbmV4IG5hbWVzIGRhc2ggYXMgZHNoXG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJjYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYW1vdW50J10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICAgICAgcmVzdWx0W3VwcGVyY2FzZV0gPSBhY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvb2tTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJ0aWNrZXJTeW1ib2wgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlRmxvYXQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF9wcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogcGFyc2VGbG9hdCAodGlja2VyWydtaWQnXSksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlclR5cGUgPSB0eXBlO1xuICAgICAgICBpZiAoKHR5cGUgPT0gJ2xpbWl0JykgfHwgKHR5cGUgPT0gJ21hcmtldCcpKVxuICAgICAgICAgICAgb3JkZXJUeXBlID0gJ2V4Y2hhbmdlICcgKyB0eXBlO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdvY29vcmRlcic6IGZhbHNlLFxuICAgICAgICAgICAgJ2J1eV9wcmljZV9vY28nOiAwLFxuICAgICAgICAgICAgJ3NlbGxfcHJpY2Vfb2NvJzogMCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2UudG9TdHJpbmcgKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlck5ldyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RPcmRlckNhbmNlbCAoeyAnb3JkZXJfaWQnOiBwYXJzZUludCAoaWQpIH0pO1xuICAgIH0sXG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gb3JkZXJbJ3NpZGUnXTtcbiAgICAgICAgbGV0IG9wZW4gPSBvcmRlclsnaXNfbGl2ZSddO1xuICAgICAgICBsZXQgY2FuY2VsZWQgPSBvcmRlclsnaXNfY2FuY2VsbGVkJ107XG4gICAgICAgIGxldCBzdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobWFya2V0KSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGV4Y2hhbmdlID0gb3JkZXJbJ3N5bWJvbCddLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgaWYgKGV4Y2hhbmdlIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtleGNoYW5nZV07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JkZXJUeXBlID0gb3JkZXJbJ3R5cGUnXTtcbiAgICAgICAgbGV0IGV4Y2hhbmdlID0gb3JkZXJUeXBlLmluZGV4T2YgKCdleGNoYW5nZSAnKSA+PSAwO1xuICAgICAgICBpZiAoZXhjaGFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBbIHByZWZpeCwgb3JkZXJUeXBlIF0gPSBvcmRlclsndHlwZSddLnNwbGl0ICgnICcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VGbG9hdCAob3JkZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDApO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAndHlwZSc6IG9yZGVyVHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChvcmRlclsnb3JpZ2luYWxfYW1vdW50J10pLFxuICAgICAgICAgICAgJ3JlbWFpbmluZyc6IHBhcnNlRmxvYXQgKG9yZGVyWydyZW1haW5pbmdfYW1vdW50J10pLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlclN0YXR1cyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IHBhcnNlSW50IChpZCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyIChyZXNwb25zZSk7XG4gICAgfSxcblxuICAgIGdldEN1cnJlbmN5TmFtZSAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdCVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JpdGNvaW4nO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdMVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2xpdGVjb2luJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnRVRIJykge1xuICAgICAgICAgICAgcmV0dXJuICdldGhlcmV1bSc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVuY3kgPT0gJ0VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAnZXRoZXJldW1jJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnT01OSScpIHtcbiAgICAgICAgICAgIHJldHVybiAnbWFzdGVyY29pbic7IC8vID8/P1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdaRUMnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3pjYXNoJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWE1SJykge1xuICAgICAgICAgICAgcmV0dXJuICdtb25lcm8nO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdVU0QnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3dpcmUnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdEQVNIJykge1xuICAgICAgICAgICAgcmV0dXJuICdkYXNoJztcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW5jeSA9PSAnWFJQJykge1xuICAgICAgICAgICAgcmV0dXJuICdyaXBwbGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbmN5ID09ICdFT1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Vvcyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgJyArIGN1cnJlbmN5ICsgJyBub3Qgc3VwcG9ydGVkIGZvciB3aXRoZHJhd2FsJyk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMuZ2V0Q3VycmVuY3lOYW1lIChjdXJyZW5jeSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd3aXRoZHJhd190eXBlJzogbmFtZSxcbiAgICAgICAgICAgICd3YWxsZXRzZWxlY3RlZCc6ICdleGNoYW5nZScsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnd2l0aGRyYXdhbF9pZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBub25jZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHJlcXVlc3Q7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAgICAgJ3JlcXVlc3QnOiByZXF1ZXN0LFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5zdHJpbmdUb0Jhc2U2NCAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjIChwYXlsb2FkLCBzZWNyZXQsICdzaGEzODQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtQkZYLUFQSUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdYLUJGWC1QQVlMT0FEJzogdGhpcy5kZWNvZGUgKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgICdYLUJGWC1TSUdOQVRVUkUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydtZXNzYWdlJ10uaW5kZXhPZiAoJ25vdCBlbm91Z2ggZXhjaGFuZ2UgYmFsYW5jZScpID49IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdGZpbmV4MiA9IGV4dGVuZCAoYml0ZmluZXgsIHtcblxuICAgICdpZCc6ICdiaXRmaW5leDInLFxuICAgICduYW1lJzogJ0JpdGZpbmV4IHYyJyxcbiAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAndmVyc2lvbic6ICd2MicsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiBmYWxzZSwgLy8gdHJ1ZSBidXQgYXQgbGVhc3Qgb25lIHBhaXIgaXMgcmVxdWlyZWRcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICc1bSc6ICc1bScsXG4gICAgICAgICcxNW0nOiAnMTVtJyxcbiAgICAgICAgJzMwbSc6ICczMG0nLFxuICAgICAgICAnMWgnOiAnMWgnLFxuICAgICAgICAnM2gnOiAnM2gnLFxuICAgICAgICAnNmgnOiAnNmgnLFxuICAgICAgICAnMTJoJzogJzEyaCcsXG4gICAgICAgICcxZCc6ICcxRCcsXG4gICAgICAgICcxdyc6ICc3RCcsXG4gICAgICAgICcydyc6ICcxNEQnLFxuICAgICAgICAnMU0nOiAnMU0nLFxuICAgIH0sXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYyNDQtZTMyOGE1MGMtNWVkMi0xMWU3LTk0N2ItMDQxNDE2NTc5YmIzLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYml0ZmluZXguY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRmaW5leC5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYml0ZmluZXgucmVhZG1lLmlvL3YyL2RvY3MnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9iaXRmaW5leGNvbS9iaXRmaW5leC1hcGktbm9kZScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAncGxhdGZvcm0vc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAndGlja2VycycsIC8vIHJlcGxpZXMgd2l0aCBhbiBlbXB0eSBsaXN0IDpcXFxuICAgICAgICAgICAgICAgICd0aWNrZXIve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0ve3ByZWNpc2lvbn0nLFxuICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9L1AwJyxcbiAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9QMScsXG4gICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0vUDInLFxuICAgICAgICAgICAgICAgICdib29rL3tzeW1ib2x9L1AzJyxcbiAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfS9SMCcsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbHNfZGV0YWlscycsXG4gICAgICAgICAgICAgICAgJ3N0YXRzMS97a2V5fTp7c2l6ZX06e3N5bWJvbH0ve3NpZGV9L3tzZWN0aW9ufScsXG4gICAgICAgICAgICAgICAgJ3N0YXRzMS97a2V5fTp7c2l6ZX06e3N5bWJvbH0vbG9uZy9sYXN0JyxcbiAgICAgICAgICAgICAgICAnc3RhdHMxL3trZXl9OntzaXplfTp7c3ltYm9sfS9sb25nL2hpc3QnLFxuICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L3Nob3J0L2xhc3QnLFxuICAgICAgICAgICAgICAgICdzdGF0czEve2tleX06e3NpemV9OntzeW1ib2x9L3Nob3J0L2hpc3QnLFxuICAgICAgICAgICAgICAgICdjYW5kbGVzL3RyYWRlOnt0aW1lZnJhbWV9OntzeW1ib2x9L3tzZWN0aW9ufScsXG4gICAgICAgICAgICAgICAgJ2NhbmRsZXMvdHJhZGU6e3RpbWVmcmFtZX06e3N5bWJvbH0vbGFzdCcsXG4gICAgICAgICAgICAgICAgJ2NhbmRsZXMvdHJhZGU6e3RpbWVmcmFtZX06e3N5bWJvbH0vaGlzdCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2NhbGMvdHJhZGUvYXZnJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2F1dGgvci93YWxsZXRzJyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVycy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ2F1dGgvci9vcmRlcnMve3N5bWJvbH0vbmV3JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVycy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL29yZGVyL3tzeW1ib2x9OntpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL3RyYWRlcy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvb2ZmZXJzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvb2ZmZXJzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9sb2Fucy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ2F1dGgvci9mdW5kaW5nL2xvYW5zL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICdhdXRoL3IvZnVuZGluZy9jcmVkaXRzL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvY3JlZGl0cy97c3ltYm9sfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL2Z1bmRpbmcvdHJhZGVzL3tzeW1ib2x9L2hpc3QnLFxuICAgICAgICAgICAgICAgICdhdXRoL3IvaW5mby9tYXJnaW4ve2tleX0nLFxuICAgICAgICAgICAgICAgICdhdXRoL3IvaW5mby9mdW5kaW5nL3trZXl9JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL21vdmVtZW50cy97Y3VycmVuY3l9L2hpc3QnLFxuICAgICAgICAgICAgICAgICdhdXRoL3Ivc3RhdHMvcGVyZjp7dGltZWZyYW1lfS9oaXN0JyxcbiAgICAgICAgICAgICAgICAnYXV0aC9yL2FsZXJ0cycsXG4gICAgICAgICAgICAgICAgJ2F1dGgvdy9hbGVydC9zZXQnLFxuICAgICAgICAgICAgICAgICdhdXRoL3cvYWxlcnQve3R5cGV9OntzeW1ib2x9OntwcmljZX0vZGVsJyxcbiAgICAgICAgICAgICAgICAnYXV0aC9jYWxjL29yZGVyL2F2YWlsJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JDQy9CVEMnOiB7ICdpZCc6ICd0QkNDQlRDJywgJ3N5bWJvbCc6ICdCQ0MvQlRDJywgJ2Jhc2UnOiAnQkNDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0JDQy9VU0QnOiB7ICdpZCc6ICd0QkNDVVNEJywgJ3N5bWJvbCc6ICdCQ0MvVVNEJywgJ2Jhc2UnOiAnQkNDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0JDSC9CVEMnOiB7ICdpZCc6ICd0QkNIQlRDJywgJ3N5bWJvbCc6ICdCQ0gvQlRDJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0JDSC9FVEgnOiB7ICdpZCc6ICd0QkNIRVRIJywgJ3N5bWJvbCc6ICdCQ0gvRVRIJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgJ0JDSC9VU0QnOiB7ICdpZCc6ICd0QkNIVVNEJywgJ3N5bWJvbCc6ICdCQ0gvVVNEJywgJ2Jhc2UnOiAnQkNIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0JDVS9CVEMnOiB7ICdpZCc6ICd0QkNVQlRDJywgJ3N5bWJvbCc6ICdCQ1UvQlRDJywgJ2Jhc2UnOiAnQkNVJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0JDVS9VU0QnOiB7ICdpZCc6ICd0QkNVVVNEJywgJ3N5bWJvbCc6ICdCQ1UvVVNEJywgJ2Jhc2UnOiAnQkNVJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICd0QlRDVVNEJywgJ3N5bWJvbCc6ICdCVEMvVVNEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAndERTSEJUQycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0RBU0gvVVNEJzogeyAnaWQnOiAndERTSFVTRCcsICdzeW1ib2wnOiAnREFTSC9VU0QnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0VPUy9CVEMnOiB7ICdpZCc6ICd0RU9TQlRDJywgJ3N5bWJvbCc6ICdFT1MvQlRDJywgJ2Jhc2UnOiAnRU9TJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0VPUy9FVEgnOiB7ICdpZCc6ICd0RU9TRVRIJywgJ3N5bWJvbCc6ICdFT1MvRVRIJywgJ2Jhc2UnOiAnRU9TJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgJ0VPUy9VU0QnOiB7ICdpZCc6ICd0RU9TVVNEJywgJ3N5bWJvbCc6ICdFT1MvVVNEJywgJ2Jhc2UnOiAnRU9TJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0VUQy9CVEMnOiB7ICdpZCc6ICd0RVRDQlRDJywgJ3N5bWJvbCc6ICdFVEMvQlRDJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0VUQy9VU0QnOiB7ICdpZCc6ICd0RVRDVVNEJywgJ3N5bWJvbCc6ICdFVEMvVVNEJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICd0RVRIQlRDJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0VUSC9VU0QnOiB7ICdpZCc6ICd0RVRIVVNEJywgJ3N5bWJvbCc6ICdFVEgvVVNEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0lPVC9CVEMnOiB7ICdpZCc6ICd0SU9UQlRDJywgJ3N5bWJvbCc6ICdJT1QvQlRDJywgJ2Jhc2UnOiAnSU9UJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0lPVC9FVEgnOiB7ICdpZCc6ICd0SU9URVRIJywgJ3N5bWJvbCc6ICdJT1QvRVRIJywgJ2Jhc2UnOiAnSU9UJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgJ0lPVC9VU0QnOiB7ICdpZCc6ICd0SU9UVVNEJywgJ3N5bWJvbCc6ICdJT1QvVVNEJywgJ2Jhc2UnOiAnSU9UJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICd0TFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0xUQy9VU0QnOiB7ICdpZCc6ICd0TFRDVVNEJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ09NRy9CVEMnOiB7ICdpZCc6ICd0T01HQlRDJywgJ3N5bWJvbCc6ICdPTUcvQlRDJywgJ2Jhc2UnOiAnT01HJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ09NRy9FVEgnOiB7ICdpZCc6ICd0T01HRVRIJywgJ3N5bWJvbCc6ICdPTUcvRVRIJywgJ2Jhc2UnOiAnT01HJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgJ09NRy9VU0QnOiB7ICdpZCc6ICd0T01HVVNEJywgJ3N5bWJvbCc6ICdPTUcvVVNEJywgJ2Jhc2UnOiAnT01HJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1JSVC9CVEMnOiB7ICdpZCc6ICd0UlJUQlRDJywgJ3N5bWJvbCc6ICdSUlQvQlRDJywgJ2Jhc2UnOiAnUlJUJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1JSVC9VU0QnOiB7ICdpZCc6ICd0UlJUVVNEJywgJ3N5bWJvbCc6ICdSUlQvVVNEJywgJ2Jhc2UnOiAnUlJUJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1NBTi9CVEMnOiB7ICdpZCc6ICd0U0FOQlRDJywgJ3N5bWJvbCc6ICdTQU4vQlRDJywgJ2Jhc2UnOiAnU0FOJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1NBTi9FVEgnOiB7ICdpZCc6ICd0U0FORVRIJywgJ3N5bWJvbCc6ICdTQU4vRVRIJywgJ2Jhc2UnOiAnU0FOJywgJ3F1b3RlJzogJ0VUSCcgfSxcbiAgICAgICAgJ1NBTi9VU0QnOiB7ICdpZCc6ICd0U0FOVVNEJywgJ3N5bWJvbCc6ICdTQU4vVVNEJywgJ2Jhc2UnOiAnU0FOJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1hNUi9CVEMnOiB7ICdpZCc6ICd0WE1SQlRDJywgJ3N5bWJvbCc6ICdYTVIvQlRDJywgJ2Jhc2UnOiAnWE1SJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1hNUi9VU0QnOiB7ICdpZCc6ICd0WE1SVVNEJywgJ3N5bWJvbCc6ICdYTVIvVVNEJywgJ2Jhc2UnOiAnWE1SJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1hSUC9CVEMnOiB7ICdpZCc6ICd0WFJQQlRDJywgJ3N5bWJvbCc6ICdYUlAvQlRDJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1hSUC9VU0QnOiB7ICdpZCc6ICd0WFJQVVNEJywgJ3N5bWJvbCc6ICdYUlAvVVNEJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1pFQy9CVEMnOiB7ICdpZCc6ICd0WkVDQlRDJywgJ3N5bWJvbCc6ICdaRUMvQlRDJywgJ2Jhc2UnOiAnWkVDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1pFQy9VU0QnOiB7ICdpZCc6ICd0WkVDVVNEJywgJ3N5bWJvbCc6ICdaRUMvVVNEJywgJ2Jhc2UnOiAnWkVDJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QXV0aFJXYWxsZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgcmVzcG9uc2UubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbYl07XG4gICAgICAgICAgICBsZXQgWyB0eXBlLCBjdXJyZW5jeSwgdG90YWwsIGludGVyZXN0LCBhdmFpbGFibGUgXSA9IGJhbGFuY2U7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3lbMF0gPT0gJ3QnKVxuICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gY3VycmVuY3kuc2xpY2UgKDEpO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgLy8gaXNzdWUgIzQgQml0ZmluZXggbmFtZXMgRGFzaCBhcyBEU0gsIGluc3RlYWQgb2YgREFTSFxuICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICB1cHBlcmNhc2UgPSAnREFTSCc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGF2YWlsYWJsZTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgICAgIGlmIChhY2NvdW50WydmcmVlJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCb29rU3ltYm9sUHJlY2lzaW9uICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncHJlY2lzaW9uJzogJ1IwJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdiaWRzJzogW10sXG4gICAgICAgICAgICAnYXNrcyc6IFtdLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmJvb2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvcmRlciA9IG9yZGVyYm9va1tpXTtcbiAgICAgICAgICAgIGxldCBbIHRpbWVzdGFtcCwgcHJpY2UsIGFtb3VudCBdID0gb3JkZXI7XG4gICAgICAgICAgICBsZXQgc2lkZSA9IChhbW91bnQgPiAwKSA/ICdiaWRzJyA6ICdhc2tzJztcbiAgICAgICAgICAgIGFtb3VudCA9IE1hdGguYWJzIChhbW91bnQpO1xuICAgICAgICAgICAgcmVzdWx0W3NpZGVdLnB1c2ggKFsgcHJpY2UsIGFtb3VudCwgdGltZXN0YW1wIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFsnYmlkcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYmlkcyddLCAwLCB0cnVlKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclN5bWJvbCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBbIGJpZCwgYmlkU2l6ZSwgYXNrLCBhc2tTaXplLCBjaGFuZ2UsIHBlcmNlbnRhZ2UsIGxhc3QsIHZvbHVtZSwgaGlnaCwgbG93IF0gPSB0aWNrZXI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBoaWdoLFxuICAgICAgICAgICAgJ2xvdyc6IGxvdyxcbiAgICAgICAgICAgICdiaWQnOiBiaWQsXG4gICAgICAgICAgICAnYXNrJzogYXNrLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogbGFzdCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBjaGFuZ2UsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHBlcmNlbnRhZ2UsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IFsgaWQsIHRpbWVzdGFtcCwgYW1vdW50LCBwcmljZSBdID0gdHJhZGU7XG4gICAgICAgIGxldCBzaWRlID0gKGFtb3VudCA8IDApID8gJ3NlbGwnIDogJ2J1eSc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBpZC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbEhpc3QgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndGltZWZyYW1lJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChsaW1pdClcbiAgICAgICAgICAgIHJlcXVlc3RbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgaWYgKHNpbmNlKVxuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHNpbmNlO1xuICAgICAgICByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0Q2FuZGxlc1RyYWRlVGltZWZyYW1lU3ltYm9sSGlzdCAocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgY3JlYXRlT3JkZXIgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPcmRlciBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyB3aXRoZHJhdyBub3QgaW1wbGVtZW50ZWQgeWV0Jyk7XG4gICAgfSxcblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgcmVxdWVzdDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gJy9hcGknICsgJy8nICsgcmVxdWVzdCArIG5vbmNlICsgYm9keTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTM4NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnYmZ4LW5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ2JmeC1hcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYmZ4LXNpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddLmluZGV4T2YgKCdub3QgZW5vdWdoIGV4Y2hhbmdlIGJhbGFuY2UnKSA+PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnN1ZmZpY2llbnRGdW5kcyAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufSlcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYml0Zmx5ZXIgPSB7XG5cbiAgICAnaWQnOiAnYml0Zmx5ZXInLFxuICAgICduYW1lJzogJ2JpdEZseWVyJyxcbiAgICAnY291bnRyaWVzJzogJ0pQJyxcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ3JhdGVMaW1pdCc6IDUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDUxNjQyLTU2MTU0MTgyLTY2MGUtMTFlNy05YjBkLTYwNDJkMWU2ZWRkOC5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJpdGZseWVyLmpwJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdGZseWVyLmpwJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JpdGZseWVyLmpwL0FQSScsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnZ2V0bWFya2V0cycsICAgIC8vIG9yICdtYXJrZXRzJ1xuICAgICAgICAgICAgICAgICdnZXRib2FyZCcsICAgICAgLy8gb3IgJ2JvYXJkJ1xuICAgICAgICAgICAgICAgICdnZXR0aWNrZXInLCAgICAgLy8gb3IgJ3RpY2tlcidcbiAgICAgICAgICAgICAgICAnZ2V0ZXhlY3V0aW9ucycsIC8vIG9yICdleGVjdXRpb25zJ1xuICAgICAgICAgICAgICAgICdnZXRoZWFsdGgnLFxuICAgICAgICAgICAgICAgICdnZXRjaGF0cycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2dldHBlcm1pc3Npb25zJyxcbiAgICAgICAgICAgICAgICAnZ2V0YmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2dldGNvbGxhdGVyYWwnLFxuICAgICAgICAgICAgICAgICdnZXRjb2xsYXRlcmFsYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdnZXRhZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICdnZXRjb2luaW5zJyxcbiAgICAgICAgICAgICAgICAnZ2V0Y29pbm91dHMnLFxuICAgICAgICAgICAgICAgICdnZXRiYW5rYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdnZXRkZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgJ2dldHdpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAnZ2V0Y2hpbGRvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdnZXRwYXJlbnRvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdnZXRwYXJlbnRvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2dldGV4ZWN1dGlvbnMnLFxuICAgICAgICAgICAgICAgICdnZXRwb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICdnZXR0cmFkaW5nY29tbWlzc2lvbicsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ3NlbmRjb2luJyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICdzZW5kY2hpbGRvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbGNoaWxkb3JkZXInLFxuICAgICAgICAgICAgICAgICdzZW5kcGFyZW50b3JkZXInLFxuICAgICAgICAgICAgICAgICdjYW5jZWxwYXJlbnRvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbGFsbGNoaWxkb3JkZXJzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3Byb2R1Y3RfY29kZSddO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBpZC5zcGxpdCAoJ18nKTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkO1xuICAgICAgICAgICAgbGV0IG51bUN1cnJlbmNpZXMgPSBjdXJyZW5jaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChudW1DdXJyZW5jaWVzID09IDEpIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gc3ltYm9sLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHN5bWJvbC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bUN1cnJlbmNpZXMgPT0gMikge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBjdXJyZW5jaWVzWzBdO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gY3VycmVuY2llc1sxXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBjdXJyZW5jaWVzWzFdO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gY3VycmVuY2llc1syXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IHJlc3BvbnNlLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHJlc3BvbnNlW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYWNjb3VudFsnY3VycmVuY3lfY29kZSddO1xuICAgICAgICAgICAgYmFsYW5jZXNbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1tjdXJyZW5jeV1bJ2Ftb3VudCddO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsnYXZhaWxhYmxlJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJvYXJkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RfY29kZSc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnc2l6ZScpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RfY29kZSc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jlc3RfYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9hc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2x0cCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV9ieV9wcm9kdWN0J10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3NpZGUnIGluIHRyYWRlKVxuICAgICAgICAgICAgaWYgKHRyYWRlWydzaWRlJ10pIHtcbiAgICAgICAgICAgICAgICBzaWRlID0gdHJhZGVbJ3NpZGUnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBzaWRlICsgJ19jaGlsZF9vcmRlcl9hY2NlcHRhbmNlX2lkJztcbiAgICAgICAgICAgICAgICBpZiAoaWQgaW4gdHJhZGUpXG4gICAgICAgICAgICAgICAgICAgIG9yZGVyID0gdHJhZGVbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydleGVjX2RhdGUnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ3NpemUnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4ZWN1dGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdF9jb2RlJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncHJvZHVjdF9jb2RlJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdjaGlsZF9vcmRlcl90eXBlJzogdHlwZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ3NpemUnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0U2VuZGNoaWxkb3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsnY2hpbGRfb3JkZXJfYWNjZXB0YW5jZV9pZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsY2hpbGRvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYXJlbnRfb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lfY29kZSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgIC8vICdiYW5rX2FjY291bnRfaWQnOiAxMjM0LFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnbWVzc2FnZV9pZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJylcbiAgICAgICAgICAgIHJlcXVlc3QgKz0gJ21lLyc7XG4gICAgICAgIHJlcXVlc3QgKz0gcGF0aDtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXF1ZXN0ICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgcmVxdWVzdDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBbIG5vbmNlLCBtZXRob2QsIHJlcXVlc3QsIGJvZHkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FDQ0VTUy1USU1FU1RBTVAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQUNDRVNTLVNJR04nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5zZWNyZXQpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYml0aHVtYiA9IHtcblxuICAgICdpZCc6ICdiaXRodW1iJyxcbiAgICAnbmFtZSc6ICdCaXRodW1iJyxcbiAgICAnY291bnRyaWVzJzogJ0tSJywgLy8gU291dGggS29yZWFcbiAgICAncmF0ZUxpbWl0JzogNTAwLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDU5NzE3Ny1lYTgwMDE3Mi05ZDVlLTExZTctODA0Yy1iOWQ0ZmE5YjU2YjAuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYml0aHVtYi5jb20vcHVibGljJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJpdGh1bWIuY29tJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5iaXRodW1iLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYml0aHVtYi5jb20vdTEvVVMxMjcnLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3RpY2tlci97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAndGlja2VyL2FsbCcsXG4gICAgICAgICAgICAgICAgJ29yZGVyYm9vay97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rL2FsbCcsXG4gICAgICAgICAgICAgICAgJ3JlY2VudF90cmFuc2FjdGlvbnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgJ3JlY2VudF90cmFuc2FjdGlvbnMvYWxsJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2luZm8vYWNjb3VudCcsXG4gICAgICAgICAgICAgICAgJ2luZm8vYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2luZm8vd2FsbGV0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdpbmZvL3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ2luZm8vb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnaW5mby91c2VyX3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlL3BsYWNlJyxcbiAgICAgICAgICAgICAgICAnaW5mby9vcmRlcl9kZXRhaWwnLFxuICAgICAgICAgICAgICAgICd0cmFkZS9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICd0cmFkZS9idGNfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlL2tyd19kZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAndHJhZGUva3J3X3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICd0cmFkZS9tYXJrZXRfYnV5JyxcbiAgICAgICAgICAgICAgICAndHJhZGUvbWFya2V0X3NlbGwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0tSVyc6IHsgJ2lkJzogJ0JUQycsICdzeW1ib2wnOiAnQlRDL0tSVycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdLUlcnIH0sXG4gICAgICAgICdFVEgvS1JXJzogeyAnaWQnOiAnRVRIJywgJ3N5bWJvbCc6ICdFVEgvS1JXJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0tSVycgfSxcbiAgICAgICAgJ0xUQy9LUlcnOiB7ICdpZCc6ICdMVEMnLCAnc3ltYm9sJzogJ0xUQy9LUlcnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnS1JXJyB9LFxuICAgICAgICAnRVRDL0tSVyc6IHsgJ2lkJzogJ0VUQycsICdzeW1ib2wnOiAnRVRDL0tSVycsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdLUlcnIH0sXG4gICAgICAgICdYUlAvS1JXJzogeyAnaWQnOiAnWFJQJywgJ3N5bWJvbCc6ICdYUlAvS1JXJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0tSVycgfSxcbiAgICAgICAgJ0JDSC9LUlcnOiB7ICdpZCc6ICdCQ0gnLCAnc3ltYm9sJzogJ0JDSC9LUlcnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnS1JXJyB9LFxuICAgICAgICAnWE1SL0tSVyc6IHsgJ2lkJzogJ1hNUicsICdzeW1ib2wnOiAnWE1SL0tSVycsICdiYXNlJzogJ1hNUicsICdxdW90ZSc6ICdLUlcnIH0sXG4gICAgICAgICdEQVNIL0tSVyc6IHsgJ2lkJzogJ0RBU0gnLCAnc3ltYm9sJzogJ0RBU0gvS1JXJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdLUlcnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEluZm9CYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZXMsICd0b3RhbF8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlcywgJ2luX3VzZV8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlcywgJ2F2YWlsYWJsZV8nICsgbG93ZXJjYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2tDdXJyZW5jeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb3VudCc6IDUwLCAvLyBtYXggPSA1MFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3F1YW50aXR5Jyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdtYXhfcHJpY2UnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbWluX3ByaWNlJyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eV9wcmljZScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsX3ByaWNlJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ29wZW5pbmdfcHJpY2UnKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdjbG9zaW5nX3ByaWNlJyksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0X3RyYWRlJyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhdmVyYWdlX3ByaWNlJyksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2x1bWVfMWRheScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoY3VycmVuY3kgPSAnQlRDJykge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckFsbCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcmVzcG9uc2VbJ2RhdGEnXVsnZGF0ZSddO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMub21pdCAocmVzcG9uc2VbJ2RhdGEnXSwgJ2RhdGUnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICB0aWNrZXJbJ2RhdGUnXSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlckN1cnJlbmN5ICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIC8vIGEgd29ya2Fyb3VuZCBmb3IgdGhlaXIgYnVnIGluIGRhdGUgZm9ybWF0LCBob3VycyBhcmUgbm90IDAtcGFkZGVkXG4gICAgICAgIGxldCBbIHRyYW5zYWN0aW9uX2RhdGUsIHRyYW5zYWN0aW9uX3RpbWUgXSA9IHRyYWRlWyd0cmFuc2FjdGlvbl9kYXRlJ10uc3BsaXQgKCcgJyk7XG4gICAgICAgIGxldCB0cmFuc2FjdGlvbl90aW1lX3Nob3J0ID0gdHJhbnNhY3Rpb25fdGltZS5sZW5ndGggPCA4O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25fdGltZV9zaG9ydClcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uX3RpbWUgPSAnMCcgKyB0cmFuc2FjdGlvbl90aW1lO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYW5zYWN0aW9uX2RhdGUgKyAnICcgKyB0cmFuc2FjdGlvbl90aW1lKTtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYXNrJykgPyAnc2VsbCcgOiAnYnV5JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsndW5pdHNfdHJhZGVkJ10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UmVjZW50VHJhbnNhY3Rpb25zQ3VycmVuY3kgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdjb3VudCc6IDEwMCwgLy8gbWF4ID0gMTAwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgcHJpdmF0ZSBBUEkgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICAvLyBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIC8vIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAvLyAgICAgcHJlZml4ID0gJ21hcmtldF8nO1xuICAgICAgICAvLyBsZXQgb3JkZXIgPSB7XG4gICAgICAgIC8vICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIC8vICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIC8vICAgICAncHJpY2UnOiBwcmljZSB8fCAwLFxuICAgICAgICAvLyAgICAgJ3R5cGUnOiBwcmVmaXggKyBzaWRlLFxuICAgICAgICAvLyB9O1xuICAgICAgICAvLyBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJDcmVhdGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIC8vIHJldHVybiB7XG4gICAgICAgIC8vICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAvLyAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIC8vIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHNpZGUgPSAoJ3NpZGUnIGluIHBhcmFtcyk7XG4gICAgICAgIGlmICghc2lkZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjYW5jZWxPcmRlciByZXF1aXJlcyBhIHNpZGUgcGFyYW1ldGVyIChzZWxsIG9yIGJ1eSknKTtcbiAgICAgICAgc2lkZSA9IChzaWRlID09ICdidXknKSA/ICdwdXJjaGFzZScgOiAnc2FsZXMnO1xuICAgICAgICBsZXQgY3VycmVuY3kgPSAoJ2N1cnJlbmN5JyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIWN1cnJlbmN5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyIHJlcXVpcmVzIGEgY3VycmVuY3kgcGFyYW1ldGVyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0VHJhZGVDYW5jZWwgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICAgICAgJ3R5cGUnOiBwYXJhbXNbJ3NpZGUnXSxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IHBhcmFtc1snY3VycmVuY3knXSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBlbmRwb2ludCA9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArIGVuZHBvaW50O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnZW5kUG9pbnQnOiBlbmRwb2ludCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBlbmRwb2ludCArIFwiXFwwXCIgKyBib2R5ICsgXCJcXDBcIiArIG5vbmNlO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXBpLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBcGktU2lnbic6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAnQXBpLU5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdGF0dXMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICcwMDAwJylcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYml0bGlzaCA9IHtcblxuICAgICdpZCc6ICdiaXRsaXNoJyxcbiAgICAnbmFtZSc6ICdiaXRsaXNoJyxcbiAgICAnY291bnRyaWVzJzogWyAnR0InLCAnRVUnLCAnUlUnIF0sXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2Mjc1LWRjZmM2YzMwLTVlZDMtMTFlNy04MzlkLTAwYTg0NjM4NWQwYi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYml0bGlzaC5jb20vYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdGxpc2guY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JpdGxpc2guY29tL2FwaScsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudHMnLFxuICAgICAgICAgICAgICAgICdvaGxjdicsXG4gICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlc19kZXB0aCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudHMnLFxuICAgICAgICAgICAgICAgICdvaGxjdicsXG4gICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlc19kZXB0aCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzX29wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX3RyYWRlJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX3RyYWRlc19ieV9pZHMnLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfYWxsX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZV9iY29kZScsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZV90ZW1wbGF0ZV93YWxsZXQnLFxuICAgICAgICAgICAgICAgICdjcmVhdGVfdHJhZGUnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAnbGlzdF9hY2NvdW50c19vcGVyYXRpb25zX2Zyb21fdHMnLFxuICAgICAgICAgICAgICAgICdsaXN0X2FjdGl2ZV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdsaXN0X2Jjb2RlcycsXG4gICAgICAgICAgICAgICAgJ2xpc3RfbXlfbWF0Y2hlc19mcm9tX3RzJyxcbiAgICAgICAgICAgICAgICAnbGlzdF9teV90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdsaXN0X215X3RyYWRzX2Zyb21fdHMnLFxuICAgICAgICAgICAgICAgICdsaXN0X3BheW1lbnRfbWV0aG9kcycsXG4gICAgICAgICAgICAgICAgJ2xpc3RfcGF5bWVudHMnLFxuICAgICAgICAgICAgICAgICdyZWRlZW1fY29kZScsXG4gICAgICAgICAgICAgICAgJ3Jlc2lnbicsXG4gICAgICAgICAgICAgICAgJ3NpZ25pbicsXG4gICAgICAgICAgICAgICAgJ3NpZ25vdXQnLFxuICAgICAgICAgICAgICAgICd0cmFkZV9kZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAndHJhZGVfb3B0aW9ucycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdfYnlfaWQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2tleXNbcF1dO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnbmFtZSddO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIC8vIGlzc3VlICM0IGJpdGxpc2ggbmFtZXMgRGFzaCBhcyBEU0gsIGluc3RlYWQgb2YgREFTSFxuICAgICAgICAgICAgaWYgKGJhc2UgPT0gJ0RTSCcpXG4gICAgICAgICAgICAgICAgYmFzZSA9ICdEQVNIJztcbiAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXgnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydtaW4nXSksXG4gICAgICAgICAgICAnYmlkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Fzayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2ZpcnN0J10pLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzICgpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJzICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1ttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbm93ID0gdGhpcy5zZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3RhcnQgPSBub3cgLSA4NjQwMCAqIDMwOyAvLyBsYXN0IDMwIGRheXNcbiAgICAgICAgbGV0IGludGVydmFsID0gWyBzdGFydC50b1N0cmluZyAoKSwgdW5kZWZpbmVkIF07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnB1YmxpY1Bvc3RPaGxjdiAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0aW1lX3JhbmdlJzogaW50ZXJ2YWwsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNEZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyX2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocGFyc2VJbnQgKG9yZGVyYm9va1snbGFzdCddKSAvIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXAsICdiaWQnLCAnYXNrJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWydkaXInXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnY3JlYXRlZCddIC8gMTAwMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNIaXN0b3J5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJfaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2xpc3QnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChyZXNwb25zZSk7XG4gICAgICAgIGxldCBiYWxhbmNlID0ge307XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gcmVzcG9uc2VbY3VycmVuY3ldO1xuICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIC8vIGlzc3VlICM0IGJpdGxpc2ggbmFtZXMgRGFzaCBhcyBEU0gsIGluc3RlYWQgb2YgREFTSFxuICAgICAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEU0gnKVxuICAgICAgICAgICAgICAgIGN1cnJlbmN5ID0gJ0RBU0gnO1xuICAgICAgICAgICAgYmFsYW5jZVtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2Z1bmRzJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWydob2xkZWQnXSk7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBzaWduSW4gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdFNpZ25pbiAoe1xuICAgICAgICAgICAgJ2xvZ2luJzogdGhpcy5sb2dpbixcbiAgICAgICAgICAgICdwYXNzd2QnOiB0aGlzLnBhc3N3b3JkLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXJfaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Rpcic6IChzaWRlID09ICdidXknKSA/ICdiaWQnIDogJ2FzaycsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDcmVhdGVUcmFkZSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxUcmFkZSAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmIChjdXJyZW5jeSAhPSAnQlRDJykge1xuICAgICAgICAgICAgLy8gdGhleSBkaWQgbm90IGRvY3VtZW50IG90aGVyIHR5cGVzLi4uXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBjdXJyZW50bHkgc3VwcG9ydHMgQlRDIHdpdGhkcmF3YWxzIG9ubHksIHVudGlsIHRoZXkgZG9jdW1lbnQgb3RoZXIgY3VycmVuY2llcy4uLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKGFtb3VudCksXG4gICAgICAgICAgICAnYWNjb3VudCc6IGFkZHJlc3MsXG4gICAgICAgICAgICAncGF5bWVudF9tZXRob2QnOiAnYml0Y29pbicsIC8vIHRoZXkgZGlkIG5vdCBkb2N1bWVudCBvdGhlciB0eXBlcy4uLlxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnbWVzc2FnZV9pZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAodGhpcy5leHRlbmQgKHsgJ3Rva2VuJzogdGhpcy5hcGlLZXkgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBiaXRtYXJrZXQgPSB7XG5cbiAgICAnaWQnOiAnYml0bWFya2V0JyxcbiAgICAnbmFtZSc6ICdCaXRNYXJrZXQnLFxuICAgICdjb3VudHJpZXMnOiBbICdQTCcsICdFVScgXSxcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAnaGFzV2l0aGRyYXcnOiB0cnVlLFxuICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAnOTBtJzogJzkwbScsXG4gICAgICAgICc2aCc6ICc2aCcsXG4gICAgICAgICcxZCc6ICcxZCcsXG4gICAgICAgICcxdyc6ICc3ZCcsXG4gICAgICAgICcxTSc6ICcxbScsXG4gICAgICAgICczTSc6ICczbScsXG4gICAgICAgICc2TSc6ICc2bScsXG4gICAgICAgICcxeSc6ICcxeScsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NzI1Ni1hODU1NTIwMC01ZWY5LTExZTctOTZmZC00NjlhNjVlMmIwYmQuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93d3cuYml0bWFya2V0Lm5ldCcsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3d3dy5iaXRtYXJrZXQucGwvYXBpMi8nLCAvLyBsYXN0IHNsYXNoIGlzIGNyaXRpY2FsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cuYml0bWFya2V0LnBsJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQubmV0JyxcbiAgICAgICAgXSxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQubmV0L2RvY3MucGhwP2ZpbGU9YXBpX3B1YmxpYy5odG1sJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5iaXRtYXJrZXQubmV0L2RvY3MucGhwP2ZpbGU9YXBpX3ByaXZhdGUuaHRtbCcsXG4gICAgICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL2JpdG1hcmtldC1uZXQvYXBpJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdqc29uL3ttYXJrZXR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ2pzb24ve21hcmtldH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAnanNvbi97bWFya2V0fS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdqc29uL2N0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgJ2dyYXBocy97bWFya2V0fS85MG0nLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vNmgnLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMWQnLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vN2QnLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMW0nLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vM20nLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vNm0nLFxuICAgICAgICAgICAgICAgICdncmFwaHMve21hcmtldH0vMXknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAndHJhZGluZ2Rlc2snLFxuICAgICAgICAgICAgICAgICd0cmFkaW5nZGVza1N0YXR1cycsXG4gICAgICAgICAgICAgICAgJ3RyYWRpbmdkZXNrQ29uZmlybScsXG4gICAgICAgICAgICAgICAgJ2NyeXB0b3RyYWRpbmdkZXNrJyxcbiAgICAgICAgICAgICAgICAnY3J5cHRvdHJhZGluZ2Rlc2tTdGF0dXMnLFxuICAgICAgICAgICAgICAgICdjcnlwdG90cmFkaW5nZGVza0NvbmZpcm0nLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3RmlhdCcsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3UExOUFAnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd0ZpYXRGYXN0JyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdCcsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAndHJhbnNmZXJzJyxcbiAgICAgICAgICAgICAgICAnbWFyZ2luTGlzdCcsXG4gICAgICAgICAgICAgICAgJ21hcmdpbk9wZW4nLFxuICAgICAgICAgICAgICAgICdtYXJnaW5DbG9zZScsXG4gICAgICAgICAgICAgICAgJ21hcmdpbkNhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ21hcmdpbk1vZGlmeScsXG4gICAgICAgICAgICAgICAgJ21hcmdpbkJhbGFuY2VBZGQnLFxuICAgICAgICAgICAgICAgICdtYXJnaW5CYWxhbmNlUmVtb3ZlJyxcbiAgICAgICAgICAgICAgICAnc3dhcExpc3QnLFxuICAgICAgICAgICAgICAgICdzd2FwT3BlbicsXG4gICAgICAgICAgICAgICAgJ3N3YXBDbG9zZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvUExOJzogeyAnaWQnOiAnQlRDUExOJywgJ3N5bWJvbCc6ICdCVEMvUExOJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BMTicgfSxcbiAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdCVENFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAnTFRDL1BMTic6IHsgJ2lkJzogJ0xUQ1BMTicsICdzeW1ib2wnOiAnTFRDL1BMTicsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDQlRDJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0xpdGVNaW5lWC9CVEMnOiB7ICdpZCc6ICdMaXRlTWluZVhCVEMnLCAnc3ltYm9sJzogJ0xpdGVNaW5lWC9CVEMnLCAnYmFzZSc6ICdMaXRlTWluZVgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnUGxuWC9CVEMnOiB7ICdpZCc6ICdQbG54QlRDJywgJ3N5bWJvbCc6ICdQbG5YL0JUQycsICdiYXNlJzogJ1BsblgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBsZXQgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBiYWxhbmNlID0gZGF0YVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBkYXRhIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydhdmFpbGFibGUnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBiYWxhbmNlWydhdmFpbGFibGUnXVtjdXJyZW5jeV07XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZVsnYmxvY2tlZCddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGJhbGFuY2VbJ2Jsb2NrZWQnXVtjdXJyZW5jeV07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogb3JkZXJib29rWydiaWRzJ10sXG4gICAgICAgICAgICAnYXNrcyc6IG9yZGVyYm9va1snYXNrcyddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRKc29uTWFya2V0VGlja2VyICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gJ2JpZCcpID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0cmFkZVsnZGF0ZSddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEpzb25NYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnOTBtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlsndGltZSddICogMTAwMCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WydvcGVuJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2hpZ2gnXSksXG4gICAgICAgICAgICBwYXJzZUZsb2F0IChvaGxjdlsnbG93J10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgcGFyc2VGbG9hdCAob2hsY3ZbJ3ZvbCddKSxcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnOTBtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldEdyYXBoc01hcmtldCcgKyB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2lkJyBpbiByZXNwb25zZVsnb3JkZXInXSlcbiAgICAgICAgICAgIHJlc3VsdFsnaWQnXSA9IHJlc3BvbnNlWydpZCddO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWwgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGlzRmlhdCAoY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdFVVInKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnUExOJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0ZpYXQgKGN1cnJlbmN5KSkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXdGaWF0JztcbiAgICAgICAgICAgIGlmICgnYWNjb3VudCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFsnYWNjb3VudCddID0gcGFyYW1zWydhY2NvdW50J107IC8vIGJhbmsgYWNjb3VudCBjb2RlIGZvciB3aXRoZHJhd2FsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhY2NvdW50IHBhcmFtZXRlciB0byB3aXRoZHJhdyBmaWF0IGN1cnJlbmN5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2FjY291bnQyJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0WydhY2NvdW50MiddID0gcGFyYW1zWydhY2NvdW50MiddOyAvLyBiYW5rIFNXSUZUIGNvZGUgKEVVUiBvbmx5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0VVUicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhY2NvdW50MiBwYXJhbWV0ZXIgdG8gd2l0aGRyYXcgRVVSJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3dpdGhkcmF3YWxfbm90ZScgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFsnd2l0aGRyYXdhbF9ub3RlJ10gPSBwYXJhbXNbJ3dpdGhkcmF3YWxfbm90ZSddOyAvLyBhIDEwLWNoYXJhY3RlciB1c2VyLXNwZWNpZmllZCB3aXRoZHJhd2FsIG5vdGUgKFBMTiBvbmx5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1BMTicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyB3aXRoZHJhd2FsX25vdGUgcGFyYW1ldGVyIHRvIHdpdGhkcmF3IFBMTicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ3ByaXZhdGVQb3N0V2l0aGRyYXcnO1xuICAgICAgICAgICAgcmVxdWVzdFsnYWRkcmVzcyddID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoICsgJy5qc29uJywgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICd0b25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgfSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJLUtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdBUEktSGFzaCc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYml0bWV4ID0ge1xuXG4gICAgJ2lkJzogJ2JpdG1leCcsXG4gICAgJ25hbWUnOiAnQml0TUVYJyxcbiAgICAnY291bnRyaWVzJzogJ1NDJywgLy8gU2V5Y2hlbGxlc1xuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFtJzogJzFtJyxcbiAgICAgICAgJzVtJzogJzVtJyxcbiAgICAgICAgJzFoJzogJzFoJyxcbiAgICAgICAgJzFkJzogJzFkJyxcbiAgICB9LFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2MzE5LWY2NTNjNmU2LTVlZDQtMTFlNy05MzNkLWYwYmMzNjk5YWU4Zi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmJpdG1leC5jb20vYXBwL2FwaU92ZXJ2aWV3JyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vQml0TUVYL2FwaS1jb25uZWN0b3JzL3RyZWUvbWFzdGVyL29mZmljaWFsLWh0dHAnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2Fubm91bmNlbWVudCcsXG4gICAgICAgICAgICAgICAgJ2Fubm91bmNlbWVudC91cmdlbnQnLFxuICAgICAgICAgICAgICAgICdmdW5kaW5nJyxcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICAgICAgJ2luc3RydW1lbnQvYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9hY3RpdmVBbmRJbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9hY3RpdmVJbnRlcnZhbHMnLFxuICAgICAgICAgICAgICAgICdpbnN0cnVtZW50L2NvbXBvc2l0ZUluZGV4JyxcbiAgICAgICAgICAgICAgICAnaW5zdHJ1bWVudC9pbmRpY2VzJyxcbiAgICAgICAgICAgICAgICAnaW5zdXJhbmNlJyxcbiAgICAgICAgICAgICAgICAnbGVhZGVyYm9hcmQnLFxuICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbicsXG4gICAgICAgICAgICAgICAgJ29yZGVyQm9vaycsXG4gICAgICAgICAgICAgICAgJ29yZGVyQm9vay9MMicsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJyxcbiAgICAgICAgICAgICAgICAncXVvdGUvYnVja2V0ZWQnLFxuICAgICAgICAgICAgICAgICdzY2hlbWEnLFxuICAgICAgICAgICAgICAgICdzY2hlbWEvd2Vic29ja2V0SGVscCcsXG4gICAgICAgICAgICAgICAgJ3NldHRsZW1lbnQnLFxuICAgICAgICAgICAgICAgICdzdGF0cycsXG4gICAgICAgICAgICAgICAgJ3N0YXRzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlL2J1Y2tldGVkJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JyxcbiAgICAgICAgICAgICAgICAnY2hhdCcsXG4gICAgICAgICAgICAgICAgJ2NoYXQvY2hhbm5lbHMnLFxuICAgICAgICAgICAgICAgICdjaGF0L2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbicsXG4gICAgICAgICAgICAgICAgJ2V4ZWN1dGlvbi90cmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICdub3RpZmljYXRpb24nLFxuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAndXNlcicsXG4gICAgICAgICAgICAgICAgJ3VzZXIvYWZmaWxpYXRlU3RhdHVzJyxcbiAgICAgICAgICAgICAgICAndXNlci9jaGVja1JlZmVycmFsQ29kZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvY29tbWlzc2lvbicsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICd1c2VyL21hcmdpbicsXG4gICAgICAgICAgICAgICAgJ3VzZXIvbWluV2l0aGRyYXdhbEZlZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXRIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXRTdW1tYXJ5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYXBpS2V5JyxcbiAgICAgICAgICAgICAgICAnYXBpS2V5L2Rpc2FibGUnLFxuICAgICAgICAgICAgICAgICdhcGlLZXkvZW5hYmxlJyxcbiAgICAgICAgICAgICAgICAnY2hhdCcsXG4gICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvYnVsaycsXG4gICAgICAgICAgICAgICAgJ29yZGVyL2NhbmNlbEFsbEFmdGVyJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2xvc2VQb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL2lzb2xhdGUnLFxuICAgICAgICAgICAgICAgICdwb3NpdGlvbi9sZXZlcmFnZScsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL3Jpc2tMaW1pdCcsXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aW9uL3RyYW5zZmVyTWFyZ2luJyxcbiAgICAgICAgICAgICAgICAndXNlci9jYW5jZWxXaXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAndXNlci9jb25maXJtRW1haWwnLFxuICAgICAgICAgICAgICAgICd1c2VyL2NvbmZpcm1FbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICd1c2VyL2NvbmZpcm1XaXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAndXNlci9kaXNhYmxlVEZBJyxcbiAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2xvZ291dEFsbCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvcHJlZmVyZW5jZXMnLFxuICAgICAgICAgICAgICAgICd1c2VyL3JlcXVlc3RFbmFibGVURkEnLFxuICAgICAgICAgICAgICAgICd1c2VyL3JlcXVlc3RXaXRoZHJhd2FsJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ29yZGVyL2J1bGsnLFxuICAgICAgICAgICAgICAgICd1c2VyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICdhcGlLZXknLFxuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ29yZGVyL2FsbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJbnN0cnVtZW50QWN0aXZlQW5kSW5kaWNlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0Wyd1bmRlcmx5aW5nJ107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBpc0Z1dHVyZXNDb250cmFjdCA9IGlkICE9IChiYXNlICsgcXVvdGUpO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpc0Z1dHVyZXNDb250cmFjdCA/IGlkIDogKGJhc2UgKyAnLycgKyBxdW90ZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRVc2VyTWFyZ2luICh7ICdjdXJyZW5jeSc6ICdhbGwnIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgcmVzcG9uc2UubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gcmVzcG9uc2VbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgY3VycmVuY3kgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVNYXJnaW4nXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWydhbW91bnQnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ0JUQycpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBhY2NvdW50WydmcmVlJ10gKiAwLjAwMDAwMDAxO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBhY2NvdW50Wyd0b3RhbCddICogMC4wMDAwMDAwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2tMMiAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBbXSxcbiAgICAgICAgICAgICdhc2tzJzogW10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBvID0gMDsgbyA8IG9yZGVyYm9vay5sZW5ndGg7IG8rKykge1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJib29rW29dO1xuICAgICAgICAgICAgbGV0IHNpZGUgPSAob3JkZXJbJ3NpZGUnXSA9PSAnU2VsbCcpID8gJ2Fza3MnIDogJ2JpZHMnO1xuICAgICAgICAgICAgbGV0IGFtb3VudCA9IG9yZGVyWydzaXplJ107XG4gICAgICAgICAgICBsZXQgcHJpY2UgPSBvcmRlclsncHJpY2UnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzaWRlXS5wdXNoIChbIHByaWNlLCBhbW91bnQgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdiaW5TaXplJzogJzFkJyxcbiAgICAgICAgICAgICdwYXJ0aWFsJzogdHJ1ZSxcbiAgICAgICAgICAgICdjb3VudCc6IDEsXG4gICAgICAgICAgICAncmV2ZXJzZSc6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBxdW90ZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFF1b3RlQnVja2V0ZWQgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgcXVvdGVzTGVuZ3RoID0gcXVvdGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IHF1b3RlID0gcXVvdGVzW3F1b3Rlc0xlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVCdWNrZXRlZCAocmVxdWVzdCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAocXVvdGVbJ2JpZFByaWNlJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHF1b3RlWydhc2tQcmljZSddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Nsb3NlJ10pLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydob21lTm90aW9uYWwnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2ZvcmVpZ25Ob3Rpb25hbCddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvaGxjdlsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgb2hsY3ZbJ29wZW4nXSxcbiAgICAgICAgICAgIG9obGN2WydoaWdoJ10sXG4gICAgICAgICAgICBvaGxjdlsnbG93J10sXG4gICAgICAgICAgICBvaGxjdlsnY2xvc2UnXSxcbiAgICAgICAgICAgIG9obGN2Wyd2b2x1bWUnXSxcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIC8vIHNlbmQgSlNPTiBrZXkvdmFsdWUgcGFpcnMsIHN1Y2ggYXMge1wia2V5XCI6IFwidmFsdWVcIn1cbiAgICAgICAgLy8gZmlsdGVyIGJ5IGluZGl2aWR1YWwgZmllbGRzIGFuZCBkbyBhZHZhbmNlZCBxdWVyaWVzIG9uIHRpbWVzdGFtcHNcbiAgICAgICAgbGV0IGZpbHRlciA9IHsgJ2tleSc6ICd2YWx1ZScgfTtcbiAgICAgICAgLy8gc2VuZCBhIGJhcmUgc2VyaWVzIChlLmcuIFhCVSkgdG8gbmVhcmVzdCBleHBpcmluZyBjb250cmFjdCBpbiB0aGF0IHNlcmllc1xuICAgICAgICAvLyB5b3UgY2FuIGFsc28gc2VuZCBhIHRpbWVmcmFtZSwgZS5nLiBYQlU6bW9udGhseVxuICAgICAgICAvLyB0aW1lZnJhbWVzOiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIGFuZCBiaXF1YXJ0ZXJseVxuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdiaW5TaXplJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgICAgICAncGFydGlhbCc6IHRydWUsICAgICAvLyB0cnVlID09IGluY2x1ZGUgeWV0LWluY29tcGxldGUgY3VycmVudCBiaW5zXG4gICAgICAgICAgICAvLyAnZmlsdGVyJzogZmlsdGVyLCAvLyBmaWx0ZXIgYnkgaW5kaXZpZHVhbCBmaWVsZHMgYW5kIGRvIGFkdmFuY2VkIHF1ZXJpZXNcbiAgICAgICAgICAgIC8vICdjb2x1bW5zJzogW10sICAgIC8vIHdpbGwgcmV0dXJuIGFsbCBjb2x1bW5zIGlmIG9taXR0ZWRcbiAgICAgICAgICAgIC8vICdzdGFydCc6IDAsICAgICAgIC8vIHN0YXJ0aW5nIHBvaW50IGZvciByZXN1bHRzICh3dGY/KVxuICAgICAgICAgICAgLy8gJ3JldmVyc2UnOiBmYWxzZSwgLy8gdHJ1ZSA9PSBuZXdlc3QgZmlyc3RcbiAgICAgICAgICAgIC8vICdlbmRUaW1lJzogJycsICAgIC8vIGVuZGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzdGFydFRpbWUnXSA9IHNpbmNlOyAvLyBzdGFydGluZyBkYXRlIGZpbHRlciBmb3IgcmVzdWx0c1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb3VudCddID0gbGltaXQ7IC8vIGRlZmF1bHQgMTAwXG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVCdWNrZXRlZCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGlmICgnc3ltYm9sJyBpbiB0cmFkZSlcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ3N5bWJvbCddXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyZE1hdGNoSUQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydzaXplJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiB0aGlzLmNhcGl0YWxpemUgKHNpZGUpLFxuICAgICAgICAgICAgJ29yZGVyUXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ29yZFR5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3JhdGUnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVySUQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVEZWxldGVPcmRlciAoeyAnb3JkZXJJRCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBpc0ZpYXQgKGN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnRVVSJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoY3VycmVuY3kgPT0gJ1BMTicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKGN1cnJlbmN5ICE9ICdCVEMnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIHN1cG9wcnRzIEJUQyB3aXRoZHJhd2FscyBvbmx5LCBvdGhlciBjdXJyZW5jaWVzIGNvbWluZyBzb29uLi4uJyk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogJ1hCdCcsIC8vIHRlbXBvcmFyaWx5XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICAgICAgLy8gJ290cFRva2VuJzogJzEyMzQ1NicsIC8vIHJlcXVpcmVzIGlmIHR3by1mYWN0b3IgYXV0aCAoT1RQKSBpcyBlbmFibGVkXG4gICAgICAgICAgICAvLyAnZmVlJzogMC4wMDEsIC8vIGJpdGNvaW4gbmV0d29yayBmZWVcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJSZXF1ZXN0V2l0aGRyYXdhbCAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWyd0cmFuc2FjdElEJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gJy9hcGknICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgIHF1ZXJ5ICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHF1ZXJ5O1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT0gJ1BPU1QnKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IFsgbWV0aG9kLCBxdWVyeSwgbm9uY2UsIGJvZHkgfHwgJyddLmpvaW4gKCcnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnYXBpLW5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ2FwaS1rZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYXBpLXNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBiaXRzbyA9IHtcblxuICAgICdpZCc6ICdiaXRzbycsXG4gICAgJ25hbWUnOiAnQml0c28nLFxuICAgICdjb3VudHJpZXMnOiAnTVgnLCAvLyBNZXhpY29cbiAgICAncmF0ZUxpbWl0JzogMjAwMCwgLy8gMzAgcmVxdWVzdHMgcGVyIG1pbnV0ZVxuICAgICd2ZXJzaW9uJzogJ3YzJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYzMzUtNzE1Y2U3YWEtNWVkNS0xMWU3LTg4YTgtMTczYTI3YmIzMGZlLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuYml0c28uY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdHNvLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9iaXRzby5jb20vYXBpX2luZm8nLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2F2YWlsYWJsZV9ib29rcycsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ29yZGVyX2Jvb2snLFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdhY2NvdW50X3N0YXR1cycsXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdmZWVzJyxcbiAgICAgICAgICAgICAgICAnZnVuZGluZ3MnLFxuICAgICAgICAgICAgICAgICdmdW5kaW5ncy97ZmlkfScsXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmdfZGVzdGluYXRpb24nLFxuICAgICAgICAgICAgICAgICdreWNfZG9jdW1lbnRzJyxcbiAgICAgICAgICAgICAgICAnbGVkZ2VyJyxcbiAgICAgICAgICAgICAgICAnbGVkZ2VyL3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ2xlZGdlci9mZWVzJyxcbiAgICAgICAgICAgICAgICAnbGVkZ2VyL2Z1bmRpbmdzJyxcbiAgICAgICAgICAgICAgICAnbGVkZ2VyL3dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAnbXhfYmFua19jb2RlcycsXG4gICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfdHJhZGVzL3tvaWR9JyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzL3tvaWR9JyxcbiAgICAgICAgICAgICAgICAndXNlcl90cmFkZXMnLFxuICAgICAgICAgICAgICAgICd1c2VyX3RyYWRlcy97dGlkfScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzLycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3t3aWR9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYml0Y29pbl93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAnZGViaXRfY2FyZF93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAnZXRoZXJfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgJ3Bob25lX251bWJlcicsXG4gICAgICAgICAgICAgICAgJ3Bob25lX3ZlcmlmaWNhdGlvbicsXG4gICAgICAgICAgICAgICAgJ3Bob25lX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdzcGVpX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgJ29yZGVycy97b2lkfScsXG4gICAgICAgICAgICAgICAgJ29yZGVycy9hbGwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0QXZhaWxhYmxlQm9va3MgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydwYXlsb2FkJ10ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydwYXlsb2FkJ11bcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2Jvb2snXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZC50b1VwcGVyQ2FzZSAoKS5yZXBsYWNlICgnXycsICcvJyk7XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3BheWxvYWQnXVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnbG9ja2VkJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3RvdGFsJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydwYXlsb2FkJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJib29rWyd1cGRhdGVkX2F0J10pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXAsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHtcbiAgICAgICAgICAgICdib29rJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsncGF5bG9hZCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2NyZWF0ZWRfYXQnXSk7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghbWFya2V0KSB7XG4gICAgICAgICAgICBpZiAoJ2Jvb2snIGluIHRyYWRlKVxuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnYm9vayddXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnbWFrZXJfc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3BheWxvYWQnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ21ham9yJzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncGF5bG9hZCddWydvaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVEZWxldGVPcmRlcnMgKHsgJ29pZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBxdWVyeSA9ICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyBxdWVyeTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBbIG5vbmNlLCBtZXRob2QsIHF1ZXJ5LCBib2R5IHx8ICcnIF0uam9pbiAoJycpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHJlcXVlc3QpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5hcGlLZXkgKyAnOicgKyBub25jZSArICc6JyArIHNpZ25hdHVyZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogXCJCaXRzbyBcIiArIGF1dGggfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdHN0YW1wMSA9IHtcblxuICAgICdpZCc6ICdiaXRzdGFtcDEnLFxuICAgICduYW1lJzogJ0JpdHN0YW1wIHYxJyxcbiAgICAnY291bnRyaWVzJzogJ0dCJyxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3Nzg2Mzc3LThjOGFiNTdlLTVmZTktMTFlNy04ZWE0LTJiMDViNmJjY2VlYy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldC9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJpdHN0YW1wLm5ldCcsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0L2FwaScsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndGlja2VyX2hvdXInLFxuICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAnZXVyX3VzZCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICdvcGVuX29yZGVycycsXG4gICAgICAgICAgICAgICAgJ29yZGVyX3N0YXR1cycsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9hbGxfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgJ2JpdGNvaW5fZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAndW5jb25maXJtZWRfYnRjJyxcbiAgICAgICAgICAgICAgICAncmlwcGxlX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdyaXBwbGVfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxfcmVxdWVzdHMnLFxuICAgICAgICAgICAgICAgICdiaXRjb2luX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y3VzZCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAnYnRjZXVyJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ0VVUi9VU0QnOiB7ICdpZCc6ICdldXJ1c2QnLCAnc3ltYm9sJzogJ0VVUi9VU0QnLCAnYmFzZSc6ICdFVVInLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnWFJQL1VTRCc6IHsgJ2lkJzogJ3hycHVzZCcsICdzeW1ib2wnOiAnWFJQL1VTRCcsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdYUlAvRVVSJzogeyAnaWQnOiAneHJwZXVyJywgJ3N5bWJvbCc6ICdYUlAvRVVSJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ1hSUC9CVEMnOiB7ICdpZCc6ICd4cnBidGMnLCAnc3ltYm9sJzogJ1hSUC9CVEMnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTFRDL1VTRCc6IHsgJ2lkJzogJ2x0Y3VzZCcsICdzeW1ib2wnOiAnTFRDL1VTRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdMVEMvRVVSJzogeyAnaWQnOiAnbHRjZXVyJywgJ3N5bWJvbCc6ICdMVEMvRVVSJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNidGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnRVRIL1VTRCc6IHsgJ2lkJzogJ2V0aHVzZCcsICdzeW1ib2wnOiAnRVRIL1VTRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdFVEgvRVVSJzogeyAnaWQnOiAnZXRoZXVyJywgJ3N5bWJvbCc6ICdFVEgvRVVSJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICdldGhidGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvVVNEJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy52ZXJzaW9uICsgXCIgZmV0Y2hPcmRlckJvb2sgZG9lc24ndCBzdXBwb3J0IFwiICsgc3ltYm9sICsgJywgdXNlIGl0IGZvciBCVEMvVVNEIG9ubHknKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rIChwYXJhbXMpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyYm9va1sndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvVVNEJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy52ZXJzaW9uICsgXCIgZmV0Y2hUaWNrZXIgZG9lc24ndCBzdXBwb3J0IFwiICsgc3ltYm9sICsgJywgdXNlIGl0IGZvciBCVEMvVVNEIG9ubHknKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ29wZW4nXSksXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnZGF0ZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKTtcbiAgICAgICAgfSBlbHNlIGlmICgnZGF0ZXRpbWUnIGluIHRyYWRlKSB7XG4gICAgICAgICAgICAvLyB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ2RhdGV0aW1lJ10pO1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRldGltZSddKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHlwZSddID09IDApID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIGxldCBvcmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdvcmRlcl9pZCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpO1xuICAgICAgICBpZiAoJ2N1cnJlbmN5X3BhaXInIGluIHRyYWRlKSB7XG4gICAgICAgICAgICBpZiAodHJhZGVbJ2N1cnJlbmN5X3BhaXInXSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9ICdCVEMvVVNEJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy52ZXJzaW9uICsgXCIgZmV0Y2hUcmFkZXMgZG9lc24ndCBzdXBwb3J0IFwiICsgc3ltYm9sICsgJywgdXNlIGl0IGZvciBCVEMvVVNEIG9ubHknKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYW5zYWN0aW9ucyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0aW1lJzogJ21pbnV0ZScsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBsb3dlcmNhc2UgKyAnX2JhbGFuY2UnO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBsb3dlcmNhc2UgKyAnX2F2YWlsYWJsZSc7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IGxvd2VyY2FzZSArICdfcmVzZXJ2ZWQnO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZSwgZnJlZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCB1c2VkLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc2FmZUZsb2F0IChiYWxhbmNlLCB0b3RhbCwgMC4wKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlICE9ICdsaW1pdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMudmVyc2lvbiArICcgYWNjZXB0cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXJTdGF0dXMgKG9yZGVyKSB7XG4gICAgICAgIGlmICgob3JkZXJbJ3N0YXR1cyddID09ICdRdWV1ZScpIHx8IChvcmRlclsnc3RhdHVzJ10gPT0gJ09wZW4nKSlcbiAgICAgICAgICAgIHJldHVybiAnb3Blbic7XG4gICAgICAgIGlmIChvcmRlclsnc3RhdHVzJ10gPT0gJ0ZpbmlzaGVkJylcbiAgICAgICAgICAgIHJldHVybiAnY2xvc2VkJztcbiAgICAgICAgcmV0dXJuIG9yZGVyWydzdGF0dXMnXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlclN0YXR1cyAoaWQsIHN5bWJvbCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJTdGF0dXMgKHsgJ2lkJzogaWQgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJTdGF0dXMgKHJlc3BvbnNlKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNeVRyYWRlcyAoc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBwYWlyID0gbWFya2V0ID8gbWFya2V0WydpZCddIDogJ2FsbCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHsgJ2lkJzogcGFpciB9LCBwYXJhbXMpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3Blbk9yZGVyc0lkIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLnVpZGAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5lbmNvZGUgKHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdHN0YW1wID0ge1xuXG4gICAgJ2lkJzogJ2JpdHN0YW1wJyxcbiAgICAnbmFtZSc6ICdCaXRzdGFtcCcsXG4gICAgJ2NvdW50cmllcyc6ICdHQicsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3ODYzNzctOGM4YWI1N2UtNWZlOS0xMWU3LThlYTQtMmIwNWI2YmNjZWVjLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0L2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYml0c3RhbXAubmV0JyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5iaXRzdGFtcC5uZXQvYXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcl9ib29rL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICd0aWNrZXJfaG91ci97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve3BhaXJ9LycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdiYWxhbmNlLycsXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2Uve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgJ3VzZXJfdHJhbnNhY3Rpb25zLycsXG4gICAgICAgICAgICAgICAgJ3VzZXJfdHJhbnNhY3Rpb25zL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICdvcGVuX29yZGVycy9hbGwvJyxcbiAgICAgICAgICAgICAgICAnb3Blbl9vcmRlcnMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfc3RhdHVzLycsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICdidXkve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgJ2J1eS9tYXJrZXQve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgJ3NlbGwve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgJ3NlbGwvbWFya2V0L3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICdsdGNfd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ2x0Y19hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnZXRoX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdldGhfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVyLXRvLW1haW4vJyxcbiAgICAgICAgICAgICAgICAndHJhbnNmZXItZnJvbS1tYWluLycsXG4gICAgICAgICAgICAgICAgJ3hycF93aXRoZHJhd2FsLycsXG4gICAgICAgICAgICAgICAgJ3hycF9hZGRyZXNzLycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwvb3Blbi8nLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd2FsL3N0YXR1cy8nLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd2FsL2NhbmNlbC8nLFxuICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbl9hZGRyZXNzL25ldy8nLFxuICAgICAgICAgICAgICAgICdsaXF1aWRhdGlvbl9hZGRyZXNzL2luZm8vJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9VU0QnOiB7ICdpZCc6ICdidGN1c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ2J0Y2V1cicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdFVVIvVVNEJzogeyAnaWQnOiAnZXVydXNkJywgJ3N5bWJvbCc6ICdFVVIvVVNEJywgJ2Jhc2UnOiAnRVVSJywgJ3F1b3RlJzogJ1VTRCcgfSxcbiAgICAgICAgJ1hSUC9VU0QnOiB7ICdpZCc6ICd4cnB1c2QnLCAnc3ltYm9sJzogJ1hSUC9VU0QnLCAnYmFzZSc6ICdYUlAnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnWFJQL0VVUic6IHsgJ2lkJzogJ3hycGV1cicsICdzeW1ib2wnOiAnWFJQL0VVUicsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdYUlAvQlRDJzogeyAnaWQnOiAneHJwYnRjJywgJ3N5bWJvbCc6ICdYUlAvQlRDJywgJ2Jhc2UnOiAnWFJQJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0xUQy9VU0QnOiB7ICdpZCc6ICdsdGN1c2QnLCAnc3ltYm9sJzogJ0xUQy9VU0QnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnTFRDL0VVUic6IHsgJ2lkJzogJ2x0Y2V1cicsICdzeW1ib2wnOiAnTFRDL0VVUicsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnbHRjYnRjJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0VUSC9VU0QnOiB7ICdpZCc6ICdldGh1c2QnLCAnc3ltYm9sJzogJ0VUSC9VU0QnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnRVRIL0VVUic6IHsgJ2lkJzogJ2V0aGV1cicsICdzeW1ib2wnOiAnRVRIL0VVUicsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnZXRoYnRjJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJib29rWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdkYXRlJyBpbiB0cmFkZSkge1xuICAgICAgICAgICAgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pO1xuICAgICAgICB9IGVsc2UgaWYgKCdkYXRldGltZScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIC8vIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZXRpbWUnXSk7XG4gICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGV0aW1lJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gMCkgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ29yZGVyX2lkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgIG9yZGVyID0gdHJhZGVbJ29yZGVyX2lkJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIGlmICgnY3VycmVuY3lfcGFpcicgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGlmICh0cmFkZVsnY3VycmVuY3lfcGFpciddIGluIHRoaXMubWFya2V0c19ieV9pZClcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdHJhZGVbJ2N1cnJlbmN5X3BhaXInXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiBvcmRlcixcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnNQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAndGltZSc6ICdtaW51dGUnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gbG93ZXJjYXNlICsgJ19iYWxhbmNlJztcbiAgICAgICAgICAgIGxldCBmcmVlID0gbG93ZXJjYXNlICsgJ19hdmFpbGFibGUnO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBsb3dlcmNhc2UgKyAnX3Jlc2VydmVkJztcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGZyZWUgaW4gYmFsYW5jZSlcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW2ZyZWVdKTtcbiAgICAgICAgICAgIGlmICh1c2VkIGluIGJhbGFuY2UpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVt1c2VkXSk7XG4gICAgICAgICAgICBpZiAodG90YWwgaW4gYmFsYW5jZSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVt0b3RhbF0pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIG1ldGhvZCArPSAnTWFya2V0JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbWV0aG9kICs9ICdQYWlyJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgcGFyc2VPcmRlclN0YXR1cyAob3JkZXIpIHtcbiAgICAgICAgaWYgKChvcmRlclsnc3RhdHVzJ10gPT0gJ1F1ZXVlJykgfHwgKG9yZGVyWydzdGF0dXMnXSA9PSAnT3BlbicpKVxuICAgICAgICAgICAgcmV0dXJuICdvcGVuJztcbiAgICAgICAgaWYgKG9yZGVyWydzdGF0dXMnXSA9PSAnRmluaXNoZWQnKVxuICAgICAgICAgICAgcmV0dXJuICdjbG9zZWQnO1xuICAgICAgICByZXR1cm4gb3JkZXJbJ3N0YXR1cyddO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyU3RhdHVzIChpZCwgc3ltYm9sID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlclN0YXR1cyAoeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlclN0YXR1cyAocmVzcG9uc2UpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE15VHJhZGVzIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiAnYWxsJztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoeyAncGFpcic6IHBhaXIgfSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9wZW5PcmRlcnNQYWlyIChyZXF1ZXN0KTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkICh0aGlzLmlkICsgJyBmZXRjaE9yZGVyIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLnVpZGAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5lbmNvZGUgKHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpKSk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBxdWVyeSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3RhdHVzJ10gPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJpdHRyZXggPSB7XG5cbiAgICAnaWQnOiAnYml0dHJleCcsXG4gICAgJ25hbWUnOiAnQml0dHJleCcsXG4gICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgJ3ZlcnNpb24nOiAndjEuMScsXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ2hhc0ZldGNoT3JkZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPcGVuT3JkZXJzJzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFtJzogJ29uZU1pbicsXG4gICAgICAgICc1bSc6ICdmaXZlTWluJyxcbiAgICAgICAgJzMwbSc6ICd0aGlydHlNaW4nLFxuICAgICAgICAnMWgnOiAnaG91cicsXG4gICAgICAgICcxZCc6ICdkYXknLFxuICAgIH0sXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjYzNTItY2YwYjNjMjYtNWVkNS0xMWU3LTgyYjctZjM4MjZiN2E5N2Q4LmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYml0dHJleC5jb20vYXBpJyxcbiAgICAgICAgICAgICdhY2NvdW50JzogJ2h0dHBzOi8vYml0dHJleC5jb20vYXBpJyxcbiAgICAgICAgICAgICdtYXJrZXQnOiAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9hcGknLFxuICAgICAgICAgICAgJ3YyJzogJ2h0dHBzOi8vYml0dHJleC5jb20vYXBpL3YyLjAvcHViJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JpdHRyZXguY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL2JpdHRyZXguY29tL0hvbWUvQXBpJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5vcmcvcGFja2FnZS9ub2RlLmJpdHRyZXguYXBpJyxcbiAgICAgICAgXSxcbiAgICAgICAgJ2ZlZXMnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9iaXR0cmV4LmNvbS9GZWVzJyxcbiAgICAgICAgICAgICdodHRwczovL3N1cHBvcnQuYml0dHJleC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMTE1MDAwMTk5NjUxLVdoYXQtZmVlcy1kb2VzLUJpdHRyZXgtY2hhcmdlLScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAndjInOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdjdXJyZW5jaWVzL0dldEJUQ1ByaWNlJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L0dldFRpY2tzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L0dldExhdGVzdFRpY2snLFxuICAgICAgICAgICAgICAgICdNYXJrZXRzL0dldE1hcmtldFN1bW1hcmllcycsXG4gICAgICAgICAgICAgICAgJ21hcmtldC9HZXRMYXRlc3RUaWNrJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdjdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0aGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ21hcmtldHMnLFxuICAgICAgICAgICAgICAgICdtYXJrZXRzdW1tYXJpZXMnLFxuICAgICAgICAgICAgICAgICdtYXJrZXRzdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdhY2NvdW50Jzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdGFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0aGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbGhpc3RvcnknLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAnbWFya2V0Jzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYnV5bGltaXQnLFxuICAgICAgICAgICAgICAgICdidXltYXJrZXQnLFxuICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcGVub3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnc2VsbGxpbWl0JyxcbiAgICAgICAgICAgICAgICAnc2VsbG1hcmtldCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ2ZlZXMnOiB7XG4gICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgJ21ha2VyJzogMC4wMDI1LFxuICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ3Jlc3VsdCddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzdWx0J11bcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ01hcmtldE5hbWUnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydNYXJrZXRDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0WydCYXNlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hY2NvdW50R2V0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgaW5kZXhlZCA9IHRoaXMuaW5kZXhCeSAoYmFsYW5jZXMsICdDdXJyZW5jeScpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGxldCBiYWxhbmNlID0gaW5kZXhlZFtjdXJyZW5jeV07XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYmFsYW5jZVsnQXZhaWxhYmxlJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYmFsYW5jZVsnQmFsYW5jZSddIC0gYmFsYW5jZVsnQXZhaWxhYmxlJ107XG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IGJhbGFuY2VbJ0JhbGFuY2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDUwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnLCAnUmF0ZScsICdRdWFudGl0eScpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnSGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnTGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Jhc2VWb2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ1ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHN1bW1hcmllcyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aWNrZXJzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1t0XTtcbiAgICAgICAgICAgIGxldCBpZCA9IHRpY2tlclsnTWFya2V0TmFtZSddO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBbIHF1b3RlLCBiYXNlIF0gPSBpZC5zcGxpdCAoJy0nKTtcbiAgICAgICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzdW1tYXJ5ICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWydUaW1lU3RhbXAnXSk7XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhZGVbJ09yZGVyVHlwZSddID09ICdCVVknKSB7XG4gICAgICAgICAgICBzaWRlID0gJ2J1eSc7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhZGVbJ09yZGVyVHlwZSddID09ICdTRUxMJykge1xuICAgICAgICAgICAgc2lkZSA9ICdzZWxsJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ0lkJyBpbiB0cmFkZSlcbiAgICAgICAgICAgIGlkID0gdHJhZGVbJ0lkJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydRdWFudGl0eSddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0aGlzdG9yeSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMWQnLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvaGxjdlsnVCddKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRpbWVzdGFtcCxcbiAgICAgICAgICAgIG9obGN2WydPJ10sXG4gICAgICAgICAgICBvaGxjdlsnSCddLFxuICAgICAgICAgICAgb2hsY3ZbJ0wnXSxcbiAgICAgICAgICAgIG9obGN2WydDJ10sXG4gICAgICAgICAgICBvaGxjdlsnViddLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICd0aWNrSW50ZXJ2YWwnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdtYXJrZXROYW1lJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnYyR2V0TWFya2V0R2V0VGlja3MgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlWydyZXN1bHQnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3Blbk9yZGVycyAoc3ltYm9sID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgbWFya2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ21hcmtldCddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFya2V0R2V0T3Blbm9yZGVycyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ21hcmtldEdldCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgdHlwZTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncmF0ZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J11bJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1hcmtldEdldENhbmNlbCAoeyAndXVpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzaWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ09yZGVyVHlwZScgaW4gb3JkZXIpXG4gICAgICAgICAgICBzaWRlID0gKG9yZGVyWydPcmRlclR5cGUnXSA9PSAnTElNSVRfQlVZJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgaWYgKCdUeXBlJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHNpZGUgPSAob3JkZXJbJ1R5cGUnXSA9PSAnTElNSVRfQlVZJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgbGV0IHN0YXR1cyA9ICdvcGVuJztcbiAgICAgICAgaWYgKG9yZGVyWydDbG9zZWQnXSkge1xuICAgICAgICAgICAgc3RhdHVzID0gJ2Nsb3NlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAob3JkZXJbJ0NhbmNlbEluaXRpYXRlZCddKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2FuY2VsZWQnO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXhjaGFuZ2UgPSBvcmRlclsnRXhjaGFuZ2UnXTtcbiAgICAgICAgICAgIGlmIChleGNoYW5nZSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbZXhjaGFuZ2VdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdPcGVuZWQnIGluIG9yZGVyKVxuICAgICAgICAgICAgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKG9yZGVyWydPcGVuZWQnXSk7XG4gICAgICAgIGlmICgnVGltZVN0YW1wJyBpbiBvcmRlcilcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnVGltZVN0YW1wJ10pO1xuICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbJ1F1YW50aXR5J107XG4gICAgICAgIGxldCByZW1haW5pbmcgPSBvcmRlclsnUXVhbnRpdHlSZW1haW5pbmcnXTtcbiAgICAgICAgbGV0IGZpbGxlZCA9IGFtb3VudCAtIHJlbWFpbmluZztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICdpbmZvJzogb3JkZXIsXG4gICAgICAgICAgICAnaWQnOiBvcmRlclsnT3JkZXJVdWlkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IG9yZGVyWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hY2NvdW50R2V0T3JkZXIgKHsgJ3V1aWQnOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlciAocmVzcG9uc2VbJ3Jlc3VsdCddKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlcnMgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWNjb3VudEdldE9yZGVyaGlzdG9yeSAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXN1bHQnXSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFjY291bnRHZXRXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J11bJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nO1xuICAgICAgICBpZiAoYXBpICE9ICd2MicpXG4gICAgICAgICAgICB1cmwgKz0gdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gYXBpICsgJy8nICsgbWV0aG9kLnRvTG93ZXJDYXNlICgpICsgcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGFwaSA9PSAndjInKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHVybCArPSBhcGkgKyAnLyc7XG4gICAgICAgICAgICBpZiAoKChhcGkgPT0gJ2FjY291bnQnKSAmJiAocGF0aCAhPSAnd2l0aGRyYXcnKSkgfHwgKHBhdGggPT0gJ29wZW5vcmRlcnMnKSlcbiAgICAgICAgICAgICAgICB1cmwgKz0gbWV0aG9kLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgdXJsICs9IHBhdGggKyAnPycgKyB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlICh1cmwpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnYXBpc2lnbic6IHNpZ25hdHVyZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnbWVzc2FnZSddID09IFwiSU5TVUZGSUNJRU5UX0ZVTkRTXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBibGlua3RyYWRlID0ge1xuXG4gICAgJ2lkJzogJ2JsaW5rdHJhZGUnLFxuICAgICduYW1lJzogJ0JsaW5rVHJhZGUnLFxuICAgICdjb3VudHJpZXMnOiBbICdVUycsICdWRScsICdWTicsICdCUicsICdQSycsICdDTCcgXSxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTA5NjgtNzVkOWM4ODQtNjQ3MC0xMWU3LTkwNzMtNDY3NTZjOGU3ZThjLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3tjdXJyZW5jeX0vdGlja2VyJywgICAgLy8gP2NyeXB0b19jdXJyZW5jeT1CVENcbiAgICAgICAgICAgICAgICAne2N1cnJlbmN5fS9vcmRlcmJvb2snLCAvLyA/Y3J5cHRvX2N1cnJlbmN5PUJUQ1xuICAgICAgICAgICAgICAgICd7Y3VycmVuY3l9L3RyYWRlcycsICAgIC8vID9jcnlwdG9fY3VycmVuY3k9QlRDJnNpbmNlPTxUSU1FU1RBTVA+JmxpbWl0PTxOVU1CRVI+XG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdEJywgICAvLyBvcmRlclxuICAgICAgICAgICAgICAgICdGJywgICAvLyBjYW5jZWwgb3JkZXJcbiAgICAgICAgICAgICAgICAnVTInLCAgLy8gYmFsYW5jZVxuICAgICAgICAgICAgICAgICdVNCcsICAvLyBteSBvcmRlcnNcbiAgICAgICAgICAgICAgICAnVTYnLCAgLy8gd2l0aGRyYXdcbiAgICAgICAgICAgICAgICAnVTE4JywgLy8gZGVwb3NpdFxuICAgICAgICAgICAgICAgICdVMjQnLCAvLyBjb25maXJtIHdpdGhkcmF3YWxcbiAgICAgICAgICAgICAgICAnVTI2JywgLy8gbGlzdCB3aXRoZHJhd2Fsc1xuICAgICAgICAgICAgICAgICdVMzAnLCAvLyBsaXN0IGRlcG9zaXRzXG4gICAgICAgICAgICAgICAgJ1UzNCcsIC8vIGxlZGdlclxuICAgICAgICAgICAgICAgICdVNzAnLCAvLyBjYW5jZWwgd2l0aGRyYXdhbFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1ZFRic6IHsgJ2lkJzogJ0JUQ1ZFRicsICdzeW1ib2wnOiAnQlRDL1ZFRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdWRUYnLCAnYnJva2VySWQnOiAxLCAnYnJva2VyJzogJ1N1ckJpdGNvaW4nIH0sXG4gICAgICAgICdCVEMvVk5EJzogeyAnaWQnOiAnQlRDVk5EJywgJ3N5bWJvbCc6ICdCVEMvVk5EJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1ZORCcsICdicm9rZXJJZCc6IDMsICdicm9rZXInOiAnVkJUQycgfSxcbiAgICAgICAgJ0JUQy9CUkwnOiB7ICdpZCc6ICdCVENCUkwnLCAnc3ltYm9sJzogJ0JUQy9CUkwnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQlJMJywgJ2Jyb2tlcklkJzogNCwgJ2Jyb2tlcic6ICdGb3hCaXQnIH0sXG4gICAgICAgICdCVEMvUEtSJzogeyAnaWQnOiAnQlRDUEtSJywgJ3N5bWJvbCc6ICdCVEMvUEtSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BLUicsICdicm9rZXJJZCc6IDgsICdicm9rZXInOiAnVXJkdUJpdCcgfSxcbiAgICAgICAgJ0JUQy9DTFAnOiB7ICdpZCc6ICdCVENDTFAnLCAnc3ltYm9sJzogJ0JUQy9DTFAnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ0xQJywgJ2Jyb2tlcklkJzogOSwgJ2Jyb2tlcic6ICdDaGlsZUJpdCcgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdFUyICh7XG4gICAgICAgICAgICAnQmFsYW5jZVJlcUlEJzogdGhpcy5ub25jZSAoKSxcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAnY3J5cHRvX2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5VGlja2VyICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAnY3J5cHRvX2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBsb3dlcmNhc2VRdW90ZSA9IG1hcmtldFsncXVvdGUnXS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgbGV0IHF1b3RlVm9sdW1lID0gJ3ZvbF8nICsgbG93ZXJjYXNlUXVvdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyW3F1b3RlVm9sdW1lXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydzaWRlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDdXJyZW5jeVRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdjcnlwdG9fY3VycmVuY3knOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ0NsT3JkSUQnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICAgICAgJ1N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdTaWRlJzogdGhpcy5jYXBpdGFsaXplIChzaWRlKSxcbiAgICAgICAgICAgICdPcmRUeXBlJzogJzInLFxuICAgICAgICAgICAgJ1ByaWNlJzogcHJpY2UsXG4gICAgICAgICAgICAnT3JkZXJRdHknOiBhbW91bnQsXG4gICAgICAgICAgICAnQnJva2VySUQnOiBtYXJrZXRbJ2Jyb2tlcklkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3REICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2VbJ1Jlc3BvbnNlcyddLCAnTXNnVHlwZScpO1xuICAgICAgICBsZXQgZXhlY3V0aW9uID0gaW5kZXhlZFsnOCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IGV4ZWN1dGlvblsnT3JkZXJJRCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0RiAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDbE9yZElEJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHsgJ01zZ1R5cGUnOiBwYXRoIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHJlcXVlc3QpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ05vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKG5vbmNlKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ1N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ1N0YXR1cyddICE9IDIwMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJsM3AgPSB7XG5cbiAgICAnaWQnOiAnYmwzcCcsXG4gICAgJ25hbWUnOiAnQkwzUCcsXG4gICAgJ2NvdW50cmllcyc6IFsgJ05MJywgJ0VVJyBdLCAvLyBOZXRoZXJsYW5kcywgRVVcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAndmVyc2lvbic6ICcxJyxcbiAgICAnY29tbWVudCc6ICdBbiBleGNoYW5nZSBtYXJrZXQgYnkgQml0b25pY05MJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4NTAxNzUyLTYwYzIxYjgyLTZmZWItMTFlNy04MThiLTA1NWVlNmQwZTc1NC5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJsM3AuZXUnLFxuICAgICAgICAnd3d3JzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYmwzcC5ldScsXG4gICAgICAgICAgICAnaHR0cHM6Ly9iaXRvbmljLm5sJyxcbiAgICAgICAgXSxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vQml0b25pY05ML2JsM3AtYXBpL3RyZWUvbWFzdGVyL2RvY3MnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vYmwzcC5ldS9hcGknLFxuICAgICAgICAgICAgJ2h0dHBzOi8vYml0b25pYy5ubC9lbi9hcGknLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3ttYXJrZXR9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3ttYXJrZXR9L29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgJ3ttYXJrZXR9L3RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICd7bWFya2V0fS9tb25leS9kZXB0aC9mdWxsJyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXIvYWRkJyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXIvcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0vbW9uZXkvb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICd7bWFya2V0fS9tb25leS90cmFkZXMvZmV0Y2gnLFxuICAgICAgICAgICAgICAgICdHRU5NS1QvbW9uZXkvaW5mbycsXG4gICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdHRU5NS1QvbW9uZXkvbmV3X2RlcG9zaXRfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS93YWxsZXQvaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ0dFTk1LVC9tb25leS93aXRoZHJhdycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAnQlRDRVVSJywgJ3N5bWJvbCc6ICdCVEMvRVVSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0VVUicgfSxcbiAgICAgICAgJ0xUQy9FVVInOiB7ICdpZCc6ICdMVENFVVInLCAnc3ltYm9sJzogJ0xUQy9FVVInLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHRU5NS1RNb25leUluZm8gKCk7XG4gICAgICAgIGxldCBkYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBkYXRhWyd3YWxsZXRzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogZGF0YSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmICgnYXZhaWxhYmxlJyBpbiBiYWxhbmNlW2N1cnJlbmN5XSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW2N1cnJlbmN5XVsnYXZhaWxhYmxlJ11bJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdiYWxhbmNlJyBpbiBiYWxhbmNlW2N1cnJlbmN5XSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVtjdXJyZW5jeV1bJ2JhbGFuY2UnXVsndmFsdWUnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY291bnRbJ3RvdGFsJ10pIHtcbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudFsnZnJlZSddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcGFyc2VCaWRBc2sgKGJpZGFzaywgcHJpY2VLZXkgPSAwLCBhbW91bnRLZXkgPSAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiaWRhc2tbJ3ByaWNlX2ludCddIC8gMTAwMDAwLjAsXG4gICAgICAgICAgICBiaWRhc2tbJ2Ftb3VudF9pbnQnXSAvIDEwMDAwMDAwMC4wLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRUaWNrZXIgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ11bJzI0aCddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJhZGVfaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbJ2RhdGUnXSxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodHJhZGVbJ2RhdGUnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2VfaW50J10gLyAxMDAwMDAuMCxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50X2ludCddIC8gMTAwMDAwMDAwLjAsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ11bJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnYW1vdW50X2ludCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmZWVfY3VycmVuY3knOiBtYXJrZXRbJ3F1b3RlJ10sXG4gICAgICAgICAgICAndHlwZSc6IChzaWRlID09ICdidXknKSA/ICdiaWQnIDogJ2FzaycsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2VfaW50J10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE1hcmtldE1vbmV5T3JkZXJBZGQgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE1hcmtldE1vbmV5T3JkZXJDYW5jZWwgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcmVxdWVzdDtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gcmVxdWVzdCArIFwiXFwwXCIgKyBib2R5O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCBzZWNyZXQsICdzaGE1MTInLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnUmVzdC1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnUmVzdC1TaWduJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJsZXV0cmFkZSA9IGV4dGVuZCAoYml0dHJleCwge1xuXG4gICAgJ2lkJzogJ2JsZXV0cmFkZScsXG4gICAgJ25hbWUnOiAnQmxldXRyYWRlJyxcbiAgICAnY291bnRyaWVzJzogJ0JSJywgLy8gQnJhemlsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjInLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMzAzMDAwLWI2MDJkYmU2LTk3NmQtMTFlNy05NTZkLTM2YzUwNDljMDFlNy5qcGcnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2JsZXV0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICdhY2NvdW50JzogJ2h0dHBzOi8vYmxldXRyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgJ21hcmtldCc6ICdodHRwczovL2JsZXV0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2JsZXV0cmFkZS5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxldXRyYWRlLmNvbS9oZWxwL0FQSScsXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAndHlwZSc6ICdBTEwnLFxuICAgICAgICAgICAgJ2RlcHRoJzogNTAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdidXknLCAnc2VsbCcsICdSYXRlJywgJ1F1YW50aXR5Jyk7XG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJ0Y2NoaW5hID0ge1xuXG4gICAgJ2lkJzogJ2J0Y2NoaW5hJyxcbiAgICAnbmFtZSc6ICdCVENDaGluYScsXG4gICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjM2OC00NjViMzI4Ni01ZWQ2LTExZTctOWExMS0wZjY0NjdlMWQ4MmIuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwbHVzJzogJ2h0dHBzOi8vcGx1cy1hcGkuYnRjY2hpbmEuY29tL21hcmtldCcsXG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vZGF0YS5idGNjaGluYS5jb20vZGF0YScsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5idGNjaGluYS5jb20vYXBpX3RyYWRlX3YxLnBocCcsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjY2hpbmEuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5idGNjaGluYS5jb20vYXBpZG9jcydcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwbHVzJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2hpc3RvcnlkYXRhJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ0J1eUljZWJlcmdPcmRlcicsXG4gICAgICAgICAgICAgICAgJ0J1eU9yZGVyJyxcbiAgICAgICAgICAgICAgICAnQnV5T3JkZXIyJyxcbiAgICAgICAgICAgICAgICAnQnV5U3RvcE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnQ2FuY2VsSWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdDYW5jZWxTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICdHZXRBY2NvdW50SW5mbycsXG4gICAgICAgICAgICAgICAgJ2dldEFyY2hpdmVkT3JkZXInLFxuICAgICAgICAgICAgICAgICdnZXRBcmNoaXZlZE9yZGVycycsXG4gICAgICAgICAgICAgICAgJ0dldERlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAnR2V0SWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAnR2V0SWNlYmVyZ09yZGVycycsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldERlcHRoJyxcbiAgICAgICAgICAgICAgICAnR2V0TWFya2V0RGVwdGgyJyxcbiAgICAgICAgICAgICAgICAnR2V0T3JkZXInLFxuICAgICAgICAgICAgICAgICdHZXRPcmRlcnMnLFxuICAgICAgICAgICAgICAgICdHZXRTdG9wT3JkZXInLFxuICAgICAgICAgICAgICAgICdHZXRTdG9wT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnR2V0VHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAnR2V0V2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ0dldFdpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAnUmVxdWVzdFdpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdTZWxsSWNlYmVyZ09yZGVyJyxcbiAgICAgICAgICAgICAgICAnU2VsbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnU2VsbE9yZGVyMicsXG4gICAgICAgICAgICAgICAgJ1NlbGxTdG9wT3JkZXInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0Y2NueScsICdzeW1ib2wnOiAnQlRDL0NOWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTlknLCAnYXBpJzogJ3B1YmxpYycsICdwbHVzJzogZmFsc2UgfSxcbiAgICAgICAgJ0xUQy9DTlknOiB7ICdpZCc6ICdsdGNjbnknLCAnc3ltYm9sJzogJ0xUQy9DTlknLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwdWJsaWMnLCAncGx1cyc6IGZhbHNlIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnbHRjYnRjJywgJ3N5bWJvbCc6ICdMVEMvQlRDJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0JUQycsICdhcGknOiAncHVibGljJywgJ3BsdXMnOiBmYWxzZSB9LFxuICAgICAgICAnQkNIL0NOWSc6IHsgJ2lkJzogJ2JjY2NueScsICdzeW1ib2wnOiAnQkNIL0NOWScsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdDTlknLCAnYXBpJzogJ3BsdXMnLCAncGx1cyc6IHRydWUgfSxcbiAgICAgICAgJ0VUSC9DTlknOiB7ICdpZCc6ICdldGhjbnknLCAnc3ltYm9sJzogJ0VUSC9DTlknLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQ05ZJywgJ2FwaSc6ICdwbHVzJywgJ3BsdXMnOiB0cnVlIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiAnYWxsJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IGtleSA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1trZXldO1xuICAgICAgICAgICAgbGV0IHBhcnRzID0ga2V5LnNwbGl0ICgnXycpO1xuICAgICAgICAgICAgbGV0IGlkID0gcGFydHNbMV07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChsb3dlcmNhc2UgaW4gYmFsYW5jZXNbJ2JhbGFuY2UnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbJ2JhbGFuY2UnXVtsb3dlcmNhc2VdWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzWydmcm96ZW4nXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1snZnJvemVuJ11bbG93ZXJjYXNlXVsnYW1vdW50J10pO1xuICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ3VzZWQnXTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNyZWF0ZU1hcmtldFJlcXVlc3QgKG1hcmtldCkge1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBsZXQgZmllbGQgPSAobWFya2V0WydwbHVzJ10pID8gJ3N5bWJvbCcgOiAnbWFya2V0JztcbiAgICAgICAgcmVxdWVzdFtmaWVsZF0gPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSBtYXJrZXRbJ2FwaSddICsgJ0dldE9yZGVyYm9vayc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncHJldl9jbG9zZSddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyUGx1cyAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsnVGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydMb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydCaWRQcmljZSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Fza1ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnT3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnUHJldkNscyddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydMYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnVm9sdW1lMjRIJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0WydhcGknXSArICdHZXRUaWNrZXInO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuY3JlYXRlTWFya2V0UmVxdWVzdCAobWFya2V0KTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHJlcXVlc3QpO1xuICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1sndGlja2VyJ107XG4gICAgICAgIGlmIChtYXJrZXRbJ3BsdXMnXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyUGx1cyAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGVQbHVzICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydzaXplJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGVzUGx1cyAodHJhZGVzLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMucGFyc2VUcmFkZVBsdXMgKHRyYWRlc1tpXSwgbWFya2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0WydhcGknXSArICdHZXRUcmFkZSc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVNYXJrZXRSZXF1ZXN0IChtYXJrZXQpO1xuICAgICAgICBpZiAobWFya2V0WydwbHVzJ10pIHtcbiAgICAgICAgICAgIGxldCBub3cgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ3N0YXJ0X3RpbWUnXSA9IG5vdyAtIDg2NDAwICogMTAwMDtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2VuZF90aW1lJ10gPSBub3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgKz0gJ3MnOyAvLyB0cmFkZXMgdnMgdHJhZGVcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgaWYgKG1hcmtldFsncGx1cyddKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlc1BsdXMgKHJlc3BvbnNlWyd0cmFkZXMnXSwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ09yZGVyMic7XG4gICAgICAgIGxldCBvcmRlciA9IHt9O1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBvcmRlclsncGFyYW1zJ10gPSBbIHVuZGVmaW5lZCwgYW1vdW50LCBpZCBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ3BhcmFtcyddID0gWyBwcmljZSwgYW1vdW50LCBpZCBdO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gcGFyYW1zWydtYXJrZXQnXTsgLy8gVE9ETyBmaXhtZVxuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhcmFtcyc6IFsgaWQsIG1hcmtldCBdLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWNyb3NlY29uZHMgKCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXBpS2V5KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLmFwaUtleWAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VjcmV0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLnNlY3JldGAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBsZXQgcCA9IFtdO1xuICAgICAgICAgICAgaWYgKCdwYXJhbXMnIGluIHBhcmFtcylcbiAgICAgICAgICAgICAgICBwID0gcGFyYW1zWydwYXJhbXMnXTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnaWQnOiBub25jZSxcbiAgICAgICAgICAgICAgICAncGFyYW1zJzogcCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwID0gcC5qb2luICgnLCcpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocmVxdWVzdCk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSAoXG4gICAgICAgICAgICAgICAgJ3RvbmNlPScgKyBub25jZSArXG4gICAgICAgICAgICAgICAgJyZhY2Nlc3NrZXk9JyArIHRoaXMuYXBpS2V5ICtcbiAgICAgICAgICAgICAgICAnJnJlcXVlc3RtZXRob2Q9JyArIG1ldGhvZC50b0xvd2VyQ2FzZSAoKSArXG4gICAgICAgICAgICAgICAgJyZpZD0nICsgbm9uY2UgK1xuICAgICAgICAgICAgICAgICcmbWV0aG9kPScgKyBwYXRoICtcbiAgICAgICAgICAgICAgICAnJnBhcmFtcz0nICsgcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChxdWVyeSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGExJyk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuYXBpS2V5ICsgJzonICsgc2lnbmF0dXJlO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgdGhpcy5zdHJpbmdUb0Jhc2U2NCAoYXV0aCksXG4gICAgICAgICAgICAgICAgJ0pzb24tUnBjLVRvbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBidGNtYXJrZXRzID0ge1xuXG4gICAgJ2lkJzogJ2J0Y21hcmtldHMnLFxuICAgICduYW1lJzogJ0JUQyBNYXJrZXRzJyxcbiAgICAnY291bnRyaWVzJzogJ0FVJywgLy8gQXVzdHJhbGlhXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsIC8vIG1hcmtldCBkYXRhIGNhY2hlZCBmb3IgMSBzZWNvbmQgKHRyYWRlcyBjYWNoZWQgZm9yIDIgc2Vjb25kcylcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI5MTQyOTExLTBlMWFjZmMyLTdkNWMtMTFlNy05OGM0LTA3ZDk1MzJiMjlkNy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmJ0Y21hcmtldHMubmV0JyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0Y21hcmtldHMubmV0LycsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ01hcmtldHMvQVBJJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdtYXJrZXQve2lkfS90aWNrJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L3tpZH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYWNjb3VudC9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAnYWNjb3VudC97aWR9L3RyYWRpbmdmZWUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdmdW5kdHJhbnNmZXIvd2l0aGRyYXdDcnlwdG8nLFxuICAgICAgICAgICAgICAgICdmdW5kdHJhbnNmZXIvd2l0aGRyYXdFRlQnLFxuICAgICAgICAgICAgICAgICdvcmRlci9jcmVhdGUnLFxuICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcmRlci9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvb3BlbicsXG4gICAgICAgICAgICAgICAgJ29yZGVyL3RyYWRlL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdvcmRlci9jcmVhdGVCYXRjaCcsIC8vIHRoZXkgcHJvbWlzZSBpdCdzIGNvbWluZyBzb29uLi4uXG4gICAgICAgICAgICAgICAgJ29yZGVyL2RldGFpbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvQVVEJzogeyAnaWQnOiAnQlRDL0FVRCcsICdzeW1ib2wnOiAnQlRDL0FVRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdMVEMvQVVEJzogeyAnaWQnOiAnTFRDL0FVRCcsICdzeW1ib2wnOiAnTFRDL0FVRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdFVEgvQVVEJzogeyAnaWQnOiAnRVRIL0FVRCcsICdzeW1ib2wnOiAnRVRIL0FVRCcsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdFVEMvQVVEJzogeyAnaWQnOiAnRVRDL0FVRCcsICdzeW1ib2wnOiAnRVRDL0FVRCcsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdYUlAvQVVEJzogeyAnaWQnOiAnWFJQL0FVRCcsICdzeW1ib2wnOiAnWFJQL0FVRCcsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdCQ0gvQVVEJzogeyAnaWQnOiAnQkNIL0FVRCcsICdzeW1ib2wnOiAnQkNIL0FVRCcsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnTFRDL0JUQycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdFVEgvQlRDJzogeyAnaWQnOiAnRVRIL0JUQycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdFVEMvQlRDJzogeyAnaWQnOiAnRVRDL0JUQycsICdzeW1ib2wnOiAnRVRDL0JUQycsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdYUlAvQlRDJzogeyAnaWQnOiAnWFJQL0JUQycsICdzeW1ib2wnOiAnWFJQL0JUQycsICdiYXNlJzogJ1hSUCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAnQkNIL0JUQycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbXVsdGlwbGllciA9IDEwMDAwMDAwMDtcbiAgICAgICAgICAgIGxldCBmcmVlID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddIC8gbXVsdGlwbGllcik7XG4gICAgICAgICAgICBsZXQgdXNlZCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3BlbmRpbmdGdW5kcyddIC8gbXVsdGlwbGllcik7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRoaXMuc3VtIChmcmVlLCB1c2VkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldElkT3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2Jlc3RCaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydiZXN0QXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0UHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUyNGgnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldElkVGljayAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldElkVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgLy8gJ3NpbmNlJzogNTk4NjgzNDUyMzEsXG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAxMDAwMDAwMDA7IC8vIGZvciBwcmljZSBhbmQgdm9sdW1lXG4gICAgICAgIC8vIGRvZXMgQlRDIE1hcmtldHMgc3VwcG9ydCBtYXJrZXQgb3JkZXJzIGF0IGFsbD9cbiAgICAgICAgbGV0IG9yZGVyU2lkZSA9IChzaWRlID09ICdidXknKSA/ICdCaWQnIDogJ0Fzayc7XG4gICAgICAgIGxldCBvcmRlciA9IHRoaXMub3JkZXJlZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBtYXJrZXRbJ2Jhc2UnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlICogbXVsdGlwbGllcixcbiAgICAgICAgICAgICd2b2x1bWUnOiBhbW91bnQgKiBtdWx0aXBsaWVyLFxuICAgICAgICAgICAgJ29yZGVyU2lkZSc6IG9yZGVyU2lkZSxcbiAgICAgICAgICAgICdvcmRlcnR5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpLFxuICAgICAgICAgICAgJ2NsaWVudFJlcXVlc3RJZCc6IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJDcmVhdGUgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVycyAoaWRzKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0T3JkZXJDYW5jZWwgKHsgJ29yZGVyX2lkcyc6IGlkcyB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbE9yZGVycyAoWyBpZCBdKTtcbiAgICB9LFxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVyaSA9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB1cmkgKyBcIlxcblwiICsgbm9uY2UgKyBcIlxcblwiO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdhcGlrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAndGltZXN0YW1wJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnUE9TVCcpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBhdXRoICs9IGJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCBzZWNyZXQsICdzaGE1MTInLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzWydzaWduYXR1cmUnXSA9IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYnRjdHJhZGVyID0ge1xuXG4gICAgJ2lkJzogJ2J0Y3RyYWRlcicsXG4gICAgJ25hbWUnOiAnQlRDVHJhZGVyJyxcbiAgICAnY291bnRyaWVzJzogWyAnVFInLCAnR1InLCAnUEgnIF0sIC8vIFR1cmtleSwgR3JlZWNlLCBQaGlsaXBwaW5lc1xuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFkJzogJzFkJyxcbiAgICB9LFxuICAgICdjb21tZW50JzogJ2Jhc2UgQVBJIGZvciBCVENFeGNoYW5nZSwgQlRDVHVyaycsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTI0MDQtY2RhMWUzODYtNjQ5Yy0xMWU3LThkYzEtNDBiYmQyODk3NzY4LmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuYnRjdHJhZGVyLmNvbS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmJ0Y3RyYWRlci5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZ2l0aHViLmNvbS9CVENUcmFkZXIvYnJva2VyLWFwaS1kb2NzJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdvaGxjZGF0YScsIC8vID9sYXN0PUNPVU5UXG4gICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcycsICAgLy8gP2xhc3Q9Q09VTlQgKG1heCA1MClcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ29wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICd1c2VyVHJhbnNhY3Rpb25zJywgLy8gP29mZnNldD0wJmxpbWl0PTI1JnNvcnQ9YXNjXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2J1eScsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IGJhc2UgPSB7XG4gICAgICAgICAgICAnZnJlZSc6IHJlc3BvbnNlWydiaXRjb2luX2F2YWlsYWJsZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiByZXNwb25zZVsnYml0Y29pbl9yZXNlcnZlZCddLFxuICAgICAgICAgICAgJ3RvdGFsJzogcmVzcG9uc2VbJ2JpdGNvaW5fYmFsYW5jZSddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcXVvdGUgPSB7XG4gICAgICAgICAgICAnZnJlZSc6IHJlc3BvbnNlWydtb25leV9hdmFpbGFibGUnXSxcbiAgICAgICAgICAgICd1c2VkJzogcmVzcG9uc2VbJ21vbmV5X3Jlc2VydmVkJ10sXG4gICAgICAgICAgICAndG90YWwnOiByZXNwb25zZVsnbW9uZXlfYmFsYW5jZSddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgc3ltYm9sID0gdGhpcy5zeW1ib2xzWzBdO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgIHJlc3VsdFttYXJrZXRbJ2Jhc2UnXV0gPSBiYXNlO1xuICAgICAgICByZXN1bHRbbWFya2V0WydxdW90ZSddXSA9IHF1b3RlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHBhcmFtcyk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJib29rWyd0aW1lc3RhbXAnXSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddICogMTAwMCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZlcmFnZSddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWF4Q291bnQgPSA1MDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFkJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob2hsY3ZbJ0RhdGUnXSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICBvaGxjdlsnT3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ0hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2WydMb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydDbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ1ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxZCcsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAobGltaXQpXG4gICAgICAgICAgICByZXF1ZXN0WydsYXN0J10gPSBsaW1pdDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPaGxjZGF0YSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdUeXBlJzogKHNpZGUgPT0gJ2J1eScpID8gJ0J1eUJ0YycgOiAnU2VsQnRjJyxcbiAgICAgICAgICAgICdJc01hcmtldE9yZGVyJzogKHR5cGUgPT0gJ21hcmtldCcpID8gMSA6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsnVG90YWwnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnQW1vdW50J10gPSBhbW91bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcmRlclsnUHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ0Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgPT0gJ2J0Y3RyYWRlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgaXMgYW4gYWJzdHJhY3QgYmFzZSBBUEkgZm9yIEJUQ0V4Y2hhbmdlLCBCVENUdXJrJyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9TdHJpbmcgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5hcGlLZXkgKyBub25jZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtUENLJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1gtU3RhbXAnOiBub25jZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICAgICAnWC1TaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgc2VjcmV0LCAnc2hhMjU2JywgJ2Jhc2U2NCcpLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBidGNleGNoYW5nZSA9IGV4dGVuZCAoYnRjdHJhZGVyLCB7XG5cbiAgICAnaWQnOiAnYnRjZXhjaGFuZ2UnLFxuICAgICduYW1lJzogJ0JUQ0V4Y2hhbmdlJyxcbiAgICAnY291bnRyaWVzJzogJ1BIJywgLy8gUGhpbGlwcGluZXNcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkzMDUyLTRjOTI5MTFhLTY0YWEtMTFlNy05NmQ4LWVjNmFjMzQzNTc1Ny5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmJ0Y2V4Y2hhbmdlLnBoL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuYnRjZXhjaGFuZ2UucGgnLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZ2l0aHViLmNvbS9CVENUcmFkZXIvYnJva2VyLWFwaS1kb2NzJyxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1BIUCc6IHsgJ2lkJzogJ0JUQy9QSFAnLCAnc3ltYm9sJzogJ0JUQy9QSFAnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnUEhQJyB9LFxuICAgIH0sXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBidGN0cmFkZXVhID0ge1xuXG4gICAgJ2lkJzogJ2J0Y3RyYWRldWEnLFxuICAgICduYW1lJzogJ0JUQyBUcmFkZSBVQScsXG4gICAgJ2NvdW50cmllcyc6ICdVQScsIC8vIFVrcmFpbmUsXG4gICAgJ3JhdGVMaW1pdCc6IDMwMDAsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTQxNDgzLTc5ZmM3MzUwLTYyZDktMTFlNy05ZjYxLWFjNDdmMjhmY2Q5Ni5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYnRjLXRyYWRlLmNvbS51YS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYnRjLXRyYWRlLmNvbS51YScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xb2NZQTB5TXlfUlhkNTYxc2ZHM3FFUFo4MGt5bGwzNkhVeHZDUmU1R2JoRS9lZGl0JyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdkZWFscy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy9zZWxsL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAndHJhZGVzL2J1eS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ2phcGFuX3N0YXQvaGlnaC97c3ltYm9sfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdhdXRoJyxcbiAgICAgICAgICAgICAgICAnYXNrL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2JpZC97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ2J1eS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ215X29yZGVycy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ29yZGVyL3N0YXR1cy97aWR9JyxcbiAgICAgICAgICAgICAgICAncmVtb3ZlL29yZGVyL3tpZH0nLFxuICAgICAgICAgICAgICAgICdzZWxsL3tzeW1ib2x9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9VQUgnOiB7ICdpZCc6ICdidGNfdWFoJywgJ3N5bWJvbCc6ICdCVEMvVUFIJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgJ0VUSC9VQUgnOiB7ICdpZCc6ICdldGhfdWFoJywgJ3N5bWJvbCc6ICdFVEgvVUFIJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgJ0xUQy9VQUgnOiB7ICdpZCc6ICdsdGNfdWFoJywgJ3N5bWJvbCc6ICdMVEMvVUFIJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VBSCcgfSxcbiAgICAgICAgJ0RPR0UvVUFIJzogeyAnaWQnOiAnZG9nZV91YWgnLCAnc3ltYm9sJzogJ0RPR0UvVUFIJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdVQUgnIH0sXG4gICAgICAgICdEQVNIL1VBSCc6IHsgJ2lkJzogJ2Rhc2hfdWFoJywgJ3N5bWJvbCc6ICdEQVNIL1VBSCcsICdiYXNlJzogJ0RBU0gnLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAnU0lCL1VBSCc6IHsgJ2lkJzogJ3NpYl91YWgnLCAnc3ltYm9sJzogJ1NJQi9VQUgnLCAnYmFzZSc6ICdTSUInLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAnS1JCL1VBSCc6IHsgJ2lkJzogJ2tyYl91YWgnLCAnc3ltYm9sJzogJ0tSQi9VQUgnLCAnYmFzZSc6ICdLUkInLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAnTlZDL1VBSCc6IHsgJ2lkJzogJ252Y191YWgnLCAnc3ltYm9sJzogJ05WQy9VQUgnLCAnYmFzZSc6ICdOVkMnLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAnTFRDL0JUQyc6IHsgJ2lkJzogJ2x0Y19idGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTlZDL0JUQyc6IHsgJ2lkJzogJ252Y19idGMnLCAnc3ltYm9sJzogJ05WQy9CVEMnLCAnYmFzZSc6ICdOVkMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnSVRJL1VBSCc6IHsgJ2lkJzogJ2l0aV91YWgnLCAnc3ltYm9sJzogJ0lUSS9VQUgnLCAnYmFzZSc6ICdJVEknLCAncXVvdGUnOiAnVUFIJyB9LFxuICAgICAgICAnRE9HRS9CVEMnOiB7ICdpZCc6ICdkb2dlX2J0YycsICdzeW1ib2wnOiAnRE9HRS9CVEMnLCAnYmFzZSc6ICdET0dFJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0RBU0gvQlRDJzogeyAnaWQnOiAnZGFzaF9idGMnLCAnc3ltYm9sJzogJ0RBU0gvQlRDJywgJ2Jhc2UnOiAnREFTSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgfSxcblxuICAgIHNpZ25JbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0QXV0aCAoKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBpZiAoJ2FjY291bnRzJyBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIGxldCBhY2NvdW50cyA9IHJlc3BvbnNlWydhY2NvdW50cyddO1xuICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBhY2NvdW50cy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0gYWNjb3VudHNbYl07XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYWNjb3VudFsnY3VycmVuY3knXTtcbiAgICAgICAgICAgICAgICBsZXQgYmFsYW5jZSA9IHBhcnNlRmxvYXQgKGFjY291bnRbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlLFxuICAgICAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGJpZHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc0J1eVN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgYXNrcyA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzU2VsbFN5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiBbXSxcbiAgICAgICAgICAgICdhc2tzJzogW10sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChiaWRzKSB7XG4gICAgICAgICAgICBpZiAoJ2xpc3QnIGluIGJpZHMpXG4gICAgICAgICAgICAgICAgb3JkZXJib29rWydiaWRzJ10gPSBiaWRzWydsaXN0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFza3MpIHtcbiAgICAgICAgICAgIGlmICgnbGlzdCcgaW4gYXNrcylcbiAgICAgICAgICAgICAgICBvcmRlcmJvb2tbJ2Fza3MnXSA9IGFza3NbJ2xpc3QnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnY3VycmVuY3lfdHJhZGUnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEphcGFuU3RhdEhpZ2hTeW1ib2wgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0cmFkZXMnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xvdyc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXNrJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdGlja2VyTGVuZ3RoID0gdGlja2VyLmxlbmd0aDtcbiAgICAgICAgaWYgKHRpY2tlckxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4ICh0aWNrZXJMZW5ndGggLSA0OCwgMCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gc3RhcnQ7IHQgPCB0aWNrZXIubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FuZGxlID0gdGlja2VyW3RdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0WydvcGVuJ10gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnb3BlbiddID0gY2FuZGxlWzFdO1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHJlc3VsdFsnaGlnaCddID09ICd1bmRlZmluZWQnKSB8fCAocmVzdWx0WydoaWdoJ10gPCBjYW5kbGVbMl0pKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ2hpZ2gnXSA9IGNhbmRsZVsyXTtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiByZXN1bHRbJ2xvdyddID09ICd1bmRlZmluZWQnKSB8fCAocmVzdWx0Wydsb3cnXSA+IGNhbmRsZVszXSkpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsnbG93J10gPSBjYW5kbGVbM107XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbJ3F1b3RlVm9sdW1lJ10gPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFsncXVvdGVWb2x1bWUnXSA9IC1jYW5kbGVbNV07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3F1b3RlVm9sdW1lJ10gLT0gY2FuZGxlWzVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aWNrZXJMZW5ndGggLSAxO1xuICAgICAgICAgICAgcmVzdWx0WydjbG9zZSddID0gdGlja2VyW2xhc3RdWzRdO1xuICAgICAgICAgICAgcmVzdWx0WydxdW90ZVZvbHVtZSddID0gLTEgKiByZXN1bHRbJ3F1b3RlVm9sdW1lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7IC8vIHVudGlsIHdlIGhhdmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIHB5dGhvblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2FtbnRfYmFzZSddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlYWxzU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ0lkJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NvdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2N1cnJlbmN5MSc6IG1hcmtldFsncXVvdGUnXSxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdFJlbW92ZU9yZGVySWQgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ291dF9vcmRlcl9pZCc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gYm9keSArIHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAncHVibGljLWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdhcGktc2lnbic6IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGF1dGgpLCAnc2hhMjU2JyksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJ0Y3R1cmsgPSBleHRlbmQgKGJ0Y3RyYWRlciwge1xuXG4gICAgJ2lkJzogJ2J0Y3R1cmsnLFxuICAgICduYW1lJzogJ0JUQ1R1cmsnLFxuICAgICdjb3VudHJpZXMnOiAnVFInLCAvLyBUdXJrZXlcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTI3MDktMThlMTU2NDYtNjRhMy0xMWU3LTlmYTItYjA5NTBlYzc3MTJmLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuYnRjdHVyay5jb20vYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5idGN0dXJrLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JUQ1RyYWRlci9icm9rZXItYXBpLWRvY3MnLFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvVFJZJzogeyAnaWQnOiAnQlRDL1RSWScsICdzeW1ib2wnOiAnQlRDL1RSWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdUUlknIH0sXG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJ0Y3ggPSB7XG5cbiAgICAnaWQnOiAnYnRjeCcsXG4gICAgJ25hbWUnOiAnQlRDWCcsXG4gICAgJ2NvdW50cmllcyc6IFsgJ0lTJywgJ1VTJywgJ0VVJyBdLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLCAvLyBzdXBwb3J0IGluIGVuZ2xpc2ggaXMgdmVyeSBwb29yLCB1bmFibGUgdG8gdGVsbCByYXRlIGxpbWl0c1xuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2Mzg1LTlmZGNjOThjLTVlZDYtMTFlNy04ZjE0LTY2ZDVlNWNkNDdlNi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYnRjLXguaXMvYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0Yy14LmlzJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2J0Yy14LmlzL2N1c3RvbS9hcGktZG9jdW1lbnQuaHRtbCcsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnZGVwdGgve2lkfS97bGltaXR9JyxcbiAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0nLFxuICAgICAgICAgICAgICAgICd0cmFkZS97aWR9L3tsaW1pdH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ3JlZGVlbScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Yy91c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ2J0Yy9ldXInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlc1tjdXJyZW5jeV0sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbY3VycmVuY3ldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aElkTGltaXQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2xpbWl0JzogMTAwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJJZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3RpbWUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0eXBlJ10gPT0gJ2FzaycpID8gJ3NlbGwnIDogJ2J1eSc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlSWRMaW1pdCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdsaW1pdCc6IDEwMDAsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0eXBlJzogc2lkZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICdtYXJrZXQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnb3JkZXInXVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdvcmRlcic6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHVybCArPSBhcGk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ01ldGhvZCc6IHBhdGgudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICAgICAgJ05vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbmF0dXJlJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZVsnZXJyb3InXSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgYnRlciA9IHtcbiAgICAnaWQnOiAnYnRlcicsXG4gICAgJ25hbWUnOiAnQnRlcicsXG4gICAgJ2NvdW50cmllcyc6IFsgJ1ZHJywgJ0NOJyBdLCAvLyBCcml0aXNoIFZpcmdpbiBJc2xhbmRzLCBDaGluYVxuICAgICd2ZXJzaW9uJzogJzInLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5ODA0NzktY2ZhMzE4OGMtNjM4Ny0xMWU3LTgxOTEtOTNmYzQxODRiYTVjLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vZGF0YS5idGVyLmNvbS9hcGknLFxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYnRlci5jb20vYXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2J0ZXIuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2J0ZXIuY29tL2FwaTInLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3BhaXJzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0aW5mbycsXG4gICAgICAgICAgICAgICAgJ21hcmtldGxpc3QnLFxuICAgICAgICAgICAgICAgICd0aWNrZXJzJyxcbiAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0nLFxuICAgICAgICAgICAgICAgICdvcmRlckJvb2sve2lkfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlL3tpZH0nLFxuICAgICAgICAgICAgICAgICd0cmFkZUhpc3Rvcnkve2lkfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlSGlzdG9yeS97aWR9L3t0aWR9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICduZXdBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdHNXaXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgJ2J1eScsXG4gICAgICAgICAgICAgICAgJ3NlbGwnLFxuICAgICAgICAgICAgICAgICdjYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbEFsbE9yZGVycycsXG4gICAgICAgICAgICAgICAgJ2dldE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0bGlzdCAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ3BhaXInXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydjdXJyX2EnXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnY3Vycl9iJ107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2UgfTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0aGlzLmN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBjb2RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKCdhdmFpbGFibGUnIGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZVsnYXZhaWxhYmxlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYXZhaWxhYmxlJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ2xvY2tlZCcgaW4gYmFsYW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlWydsb2NrZWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWydsb2NrZWQnXVtjdXJyZW5jeV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2tJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoMjRociddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdzI0aHInXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoZXN0QmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93ZXN0QXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncGVyY2VudENoYW5nZSddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmFzZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncXVvdGVWb2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBbIGJhc2VJZCwgcXVvdGVJZCBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGJhc2VJZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IHF1b3RlSWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3ltYm9sIGluIHRoaXMubWFya2V0cylcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpXG4gICAgICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJJZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYWRlSUQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydyYXRlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVIaXN0b3J5SWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ2RhdGEnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlck51bWJlciddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJOdW1iZXInOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcHJlZml4ID0gKGFwaSA9PSAncHJpdmF0ZScpID8gKGFwaSArICcvJykgOiAnJztcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ11bYXBpXSArIHRoaXMudmVyc2lvbiArICcvMS8nICsgcHJlZml4ICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdCA9IHsgJ25vbmNlJzogbm9uY2UgfTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddICE9ICd0cnVlJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGJ4aW50aCA9IHtcblxuICAgICdpZCc6ICdieGludGgnLFxuICAgICduYW1lJzogJ0JYLmluLnRoJyxcbiAgICAnY291bnRyaWVzJzogJ1RIJywgLy8gVGhhaWxhbmRcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NDEyLTU2N2IxZWI0LTVlZDctMTFlNy05NGE4LWZmNmEzODg0ZjZjNS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYnguaW4udGgvYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2J4LmluLnRoJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2J4LmluLnRoL2luZm8vYXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICcnLCAvLyB0aWNrZXJcbiAgICAgICAgICAgICAgICAnb3B0aW9ucycsXG4gICAgICAgICAgICAgICAgJ29wdGlvbmJvb2snLFxuICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICdwYWlyaW5nJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2JpbGxlcicsXG4gICAgICAgICAgICAgICAgJ2JpbGxncm91cCcsXG4gICAgICAgICAgICAgICAgJ2JpbGxwYXknLFxuICAgICAgICAgICAgICAgICdjYW5jZWwnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAnZ2V0b3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ29wdGlvbi1pc3N1ZScsXG4gICAgICAgICAgICAgICAgJ29wdGlvbi1iaWQnLFxuICAgICAgICAgICAgICAgICdvcHRpb24tc2VsbCcsXG4gICAgICAgICAgICAgICAgJ29wdGlvbi1teWlzc3VlJyxcbiAgICAgICAgICAgICAgICAnb3B0aW9uLW15YmlkJyxcbiAgICAgICAgICAgICAgICAnb3B0aW9uLW15b3B0aW9ucycsXG4gICAgICAgICAgICAgICAgJ29wdGlvbi1leGVyY2lzZScsXG4gICAgICAgICAgICAgICAgJ29wdGlvbi1jYW5jZWwnLFxuICAgICAgICAgICAgICAgICdvcHRpb24taGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWwtaGlzdG9yeScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UGFpcmluZyAoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1trZXlzW3BdXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsncGFpcmluZ19pZCddLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ3ByaW1hcnlfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnc2Vjb25kYXJ5X2N1cnJlbmN5J107XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBjb21tb25DdXJyZW5jeUNvZGUgKGN1cnJlbmN5KSB7XG4gICAgICAgIC8vIHdoeSB3b3VsZCB0aGV5IHVzZSB0aHJlZSBsZXR0ZXJzIGluc3RlYWQgb2YgZm91ciBmb3IgY3VycmVuY3kgY29kZXNcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdEQVMnKVxuICAgICAgICAgICAgcmV0dXJuICdEQVNIJztcbiAgICAgICAgaWYgKGN1cnJlbmN5ID09ICdET0cnKVxuICAgICAgICAgICAgcmV0dXJuICdET0dFJztcbiAgICAgICAgcmV0dXJuIGN1cnJlbmN5O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY3VycmVuY3kpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlW2N1cnJlbmN5XVsnYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbY3VycmVuY3ldWyd0b3RhbCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2NvZGVdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydvcmRlcmJvb2snXVsnYmlkcyddWydoaWdoYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3JkZXJib29rJ11bJ2Fza3MnXVsnaGlnaGJpZCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdF9wcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2NoYW5nZSddKSxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lXzI0aG91cnMnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0ICh7ICdwYWlyaW5nJzogbWFya2V0WydpZCddIH0pO1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0cmFkZV9kYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYWRlX2lkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ29yZGVyJzogdHJhZGVbJ29yZGVyX2lkJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3RyYWRlX3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydyYXRlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJpbmcnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcmluZyc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFpcmluZyA9IHVuZGVmaW5lZDsgLy8gVE9ETyBmaXhtZVxuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbCAoe1xuICAgICAgICAgICAgJ29yZGVyX2lkJzogaWQsXG4gICAgICAgICAgICAncGFpcmluZyc6IHBhaXJpbmcsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nO1xuICAgICAgICBpZiAocGF0aClcbiAgICAgICAgICAgIHVybCArPSBwYXRoICsgJy8nO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5hcGlLZXkgKyBub25jZS50b1N0cmluZyAoKSArIHRoaXMuc2VjcmV0O1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGF1dGgpLCAnc2hhMjU2Jyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgLy8gdHdvZmE6IHRoaXMudHdvZmEsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNjZXggPSB7XG5cbiAgICAnaWQnOiAnY2NleCcsXG4gICAgJ25hbWUnOiAnQy1DRVgnLFxuICAgICdjb3VudHJpZXMnOiBbICdERScsICdFVScgXSxcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NDMzLTE2ODgxZjkwLTVlZDgtMTFlNy05MmY4LTNkOTJjYzc0N2E2Yy5qcGcnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3RpY2tlcnMnOiAnaHR0cHM6Ly9jLWNleC5jb20vdCcsXG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYy1jZXguY29tL3QvYXBpX3B1Yi5odG1sJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYy1jZXguY29tL3QvYXBpLmh0bWwnLFxuICAgICAgICB9LFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vYy1jZXguY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2MtY2V4LmNvbS8/aWQ9YXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICd0aWNrZXJzJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnY29pbm5hbWVzJyxcbiAgICAgICAgICAgICAgICAne21hcmtldH0nLFxuICAgICAgICAgICAgICAgICdwYWlycycsXG4gICAgICAgICAgICAgICAgJ3ByaWNlcycsXG4gICAgICAgICAgICAgICAgJ3ZvbHVtZV97Y29pbn0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VkaXN0cmlidXRpb24nLFxuICAgICAgICAgICAgICAgICdtYXJrZXRoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgJ21hcmtldHN1bW1hcmllcycsXG4gICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2J1eWxpbWl0JyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnZ2V0YmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2dldGJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAnZ2V0b3Blbm9yZGVycycsXG4gICAgICAgICAgICAgICAgJ2dldG9yZGVyJyxcbiAgICAgICAgICAgICAgICAnZ2V0b3JkZXJoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICdzZWxsbGltaXQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzWydyZXN1bHQnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnTWFya2V0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsnQmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnQXZhaWxhYmxlJ10sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBiYWxhbmNlWydQZW5kaW5nJ10sXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsnQmFsYW5jZSddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ21hcmtldCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6ICdib3RoJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eScsICdzZWxsJywgJ1JhdGUnLCAnUXVhbnRpdHknKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0cHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXZnJ10pLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYnV5c3VwcG9ydCcpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy50aWNrZXJzR2V0UHJpY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHRpY2tlcnMgfTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBpZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbdXBwZXJjYXNlXTtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gdXBwZXJjYXNlLnNwbGl0ICgnLScpO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRpY2tlcnNHZXRNYXJrZXQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ1RpbWVTdGFtcCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydJZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnT3JkZXJUeXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsnUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnUXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldGhpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgICAgICd0eXBlJzogJ2JvdGgnLFxuICAgICAgICAgICAgJ2RlcHRoJzogMTAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydyZXN1bHQnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlR2V0JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSkgKyB0eXBlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXVsndXVpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZUdldENhbmNlbCAoeyAndXVpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhJzogcGF0aCxcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ2FwaXNpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlICh1cmwpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJykgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYSc6ICdnZXQnICsgcGF0aCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICcuanNvbic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoYXBpID09ICd0aWNrZXJzJylcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2V4ID0ge1xuXG4gICAgJ2lkJzogJ2NleCcsXG4gICAgJ25hbWUnOiAnQ0VYLklPJyxcbiAgICAnY291bnRyaWVzJzogWyAnR0InLCAnRVUnLCAnQ1knLCAnUlUnIF0sXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQ0Mi04ZGRjMzNiMC01ZWQ4LTExZTctOGI5OC1mNzg2YWVmMGYzYzkuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2NleC5pby9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY2V4LmlvJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2NleC5pby9jZXgtYXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdjdXJyZW5jeV9saW1pdHMnLFxuICAgICAgICAgICAgICAgICdsYXN0X3ByaWNlL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2xhc3RfcHJpY2VzL3tjdXJyZW5jaWVzfScsXG4gICAgICAgICAgICAgICAgJ29obGN2L2hkL3t5eXl5bW1kZH0ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfYm9vay97cGFpcn0nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAndGlja2Vycy97Y3VycmVuY2llc30nLFxuICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5L3twYWlyfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2NvbnZlcnQve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAncHJpY2Vfc3RhdHMve3BhaXJ9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2FjdGl2ZV9vcmRlcnNfc3RhdHVzLycsXG4gICAgICAgICAgICAgICAgJ2FyY2hpdmVkX29yZGVycy97cGFpcn0nLFxuICAgICAgICAgICAgICAgICdiYWxhbmNlLycsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlci8nLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXJzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9yZXBsYWNlX29yZGVyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2Nsb3NlX3Bvc2l0aW9uL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2dldF9hZGRyZXNzLycsXG4gICAgICAgICAgICAgICAgJ2dldF9teWZlZS8nLFxuICAgICAgICAgICAgICAgICdnZXRfb3JkZXIvJyxcbiAgICAgICAgICAgICAgICAnZ2V0X29yZGVyX3R4LycsXG4gICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ29wZW5fb3JkZXJzLycsXG4gICAgICAgICAgICAgICAgJ29wZW5fcG9zaXRpb24ve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAnb3Blbl9wb3NpdGlvbnMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAncGxhY2Vfb3JkZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAncGxhY2Vfb3JkZXIve3BhaXJ9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEN1cnJlbmN5TGltaXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1snZGF0YSddWydwYWlycyddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1snZGF0YSddWydwYWlycyddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wxJ10gKyAnLycgKyBtYXJrZXRbJ3N5bWJvbDInXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlc1tjdXJyZW5jeV1bJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2N1cnJlbmN5XVsnb3JkZXJzJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCAgdGhpcy5wdWJsaWNHZXRPcmRlckJvb2tQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IG9yZGVyYm9va1sndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGlzbzg2MDEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgndGltZXN0YW1wJyBpbiB0aWNrZXIpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0aWNrZXJbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgICAgICBpc284NjAxID0gdGhpcy5pc284NjAxICh0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2b2x1bWUgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sdW1lJyk7XG4gICAgICAgIGxldCBoaWdoID0gdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKTtcbiAgICAgICAgbGV0IGxvdyA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsb3cnKTtcbiAgICAgICAgbGV0IGJpZCA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdiaWQnKTtcbiAgICAgICAgbGV0IGFzayA9IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IGlzbzg2MDEsXG4gICAgICAgICAgICAnaGlnaCc6IGhpZ2gsXG4gICAgICAgICAgICAnbG93JzogbG93LFxuICAgICAgICAgICAgJ2JpZCc6IGJpZCxcbiAgICAgICAgICAgICdhc2snOiBhc2ssXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IHRoaXMuY3VycmVuY2llcy5qb2luICgnLycpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnNDdXJyZW5jaWVzICh7XG4gICAgICAgICAgICAnY3VycmVuY2llcyc6IGN1cnJlbmNpZXMsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aWNrZXJzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1t0XTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aWNrZXJbJ3BhaXInXS5yZXBsYWNlICgnOicsICcvJyk7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyUGFpciAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZUhpc3RvcnlQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gdHlwZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlT3JkZXJQYWlyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLnVpZGAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZScgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICgnb2snIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnb2snXSA9PSAnb2snKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY2hidGMgPSB7XG4gICAgJ2lkJzogJ2NoYnRjJyxcbiAgICAnbmFtZSc6ICdDSEJUQycsXG4gICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjg1NTU2NTktZjAwNDBkYzItNzEwOS0xMWU3LTlkOTktNjg4YTQzOGJmOWY0LmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHA6Ly9hcGkuY2hidGMuY29tL2RhdGEnLCAvLyBubyBodHRwcyBmb3IgcHVibGljIEFQSVxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly90cmFkZS5jaGJ0Yy5jb20vYXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3RyYWRlLmNoYnRjLmNvbS9hcGknLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LmNoYnRjLmNvbS9pL2RldmVsb3BlcicsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICdrbGluZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnZ2V0T3JkZXInLFxuICAgICAgICAgICAgICAgICdnZXRPcmRlcnMnLFxuICAgICAgICAgICAgICAgICdnZXRPcmRlcnNOZXcnLFxuICAgICAgICAgICAgICAgICdnZXRPcmRlcnNJZ25vcmVUcmFkZVR5cGUnLFxuICAgICAgICAgICAgICAgICdnZXRVbmZpbmlzaGVkT3JkZXJzSWdub3JlVHJhZGVUeXBlJyxcbiAgICAgICAgICAgICAgICAnZ2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICdnZXRVc2VyQWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ2dldFdpdGhkcmF3QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ2dldFdpdGhkcmF3UmVjb3JkJyxcbiAgICAgICAgICAgICAgICAnZ2V0Q2hhcmdlUmVjb3JkJyxcbiAgICAgICAgICAgICAgICAnZ2V0Q255V2l0aGRyYXdSZWNvcmQnLFxuICAgICAgICAgICAgICAgICdnZXRDbnlDaGFyZ2VSZWNvcmQnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvQ05ZJzogeyAnaWQnOiAnYnRjX2NueScsICdzeW1ib2wnOiAnQlRDL0NOWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdMVEMvQ05ZJzogeyAnaWQnOiAnbHRjX2NueScsICdzeW1ib2wnOiAnTFRDL0NOWScsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdFVEgvQ05ZJzogeyAnaWQnOiAnZXRoX2NueScsICdzeW1ib2wnOiAnRVRIL0NOWScsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdFVEMvQ05ZJzogeyAnaWQnOiAnZXRjX2NueScsICdzeW1ib2wnOiAnRVRDL0NOWScsICdiYXNlJzogJ0VUQycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdCVFMvQ05ZJzogeyAnaWQnOiAnYnRzX2NueScsICdzeW1ib2wnOiAnQlRTL0NOWScsICdiYXNlJzogJ0JUUycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgIC8vICdFT1MvQ05ZJzogeyAnaWQnOiAnZW9zX2NueScsICdzeW1ib2wnOiAnRU9TL0NOWScsICdiYXNlJzogJ0VPUycsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdCQ0gvQ05ZJzogeyAnaWQnOiAnYmNjX2NueScsICdzeW1ib2wnOiAnQkNIL0NOWScsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdIU1IvQ05ZJzogeyAnaWQnOiAnaHNyX2NueScsICdzeW1ib2wnOiAnSFNSL0NOWScsICdiYXNlJzogJ0hTUicsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgICAgICdRVFVNL0NOWSc6IHsgJ2lkJzogJ3F0dW1fY255JywgJ3N5bWJvbCc6ICdRVFVNL0NOWScsICdiYXNlJzogJ1FUVU0nLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snYmFsYW5jZSddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydiYWxhbmNlJ11bY3VycmVuY3ldWydhbW91bnQnXSk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZXNbJ2Zyb3plbiddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzWydmcm96ZW4nXVtjdXJyZW5jeV1bJ2Ftb3VudCddKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGJpZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBhc2tzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2JpZHMnIGluIG9yZGVyYm9vaylcbiAgICAgICAgICAgIGJpZHMgPSBvcmRlcmJvb2tbJ2JpZHMnXTtcbiAgICAgICAgaWYgKCdhc2tzJyBpbiBvcmRlcmJvb2spXG4gICAgICAgICAgICBhc2tzID0gb3JkZXJib29rWydhc2tzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IGJpZHMsXG4gICAgICAgICAgICAnYXNrcyc6IGFza3MsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0WydiaWRzJ10pXG4gICAgICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXN1bHRbJ2Fza3MnXSlcbiAgICAgICAgICAgIHJlc3VsdFsnYXNrcyddID0gdGhpcy5zb3J0QnkgKHJlc3VsdFsnYXNrcyddLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsndGlja2VyJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWyd0cmFkZV90eXBlJ10gPT0gJ2JpZCcpID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBwYXJhbVN0cmluZyA9ICcmcHJpY2U9JyArIHByaWNlLnRvU3RyaW5nICgpO1xuICAgICAgICBwYXJhbVN0cmluZyArPSAnJmFtb3VudD0nICsgYW1vdW50LnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgdHJhZGVUeXBlID0gKHNpZGUgPT0gJ2J1eScpID8gJzEnIDogJzAnO1xuICAgICAgICBwYXJhbVN0cmluZyArPSAnJnRyYWRlVHlwZT0nICsgdHJhZGVUeXBlO1xuICAgICAgICBwYXJhbVN0cmluZyArPSAnJmN1cnJlbmN5PScgKyB0aGlzLm1hcmtldElkIChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXIgKHBhcmFtU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSAnJmlkPScgKyBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeScgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZjdXJyZW5jeT0nICsgcGFyYW1zWydjdXJyZW5jeSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyIChwYXJhbVN0cmluZyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcGFyYW1TdHJpbmcgPSAnJmlkPScgKyBpZC50b1N0cmluZyAoKTtcbiAgICAgICAgaWYgKCdjdXJyZW5jeScgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFyYW1TdHJpbmcgKz0gJyZjdXJyZW5jeT0nICsgcGFyYW1zWydjdXJyZW5jeSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdEdldE9yZGVyIChwYXJhbVN0cmluZyk7XG4gICAgfSxcblxuICAgIG5vbmNlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBwYXRoO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zTGVuZ3RoID0gcGFyYW1zLmxlbmd0aDsgLy8gcGFyYW1zIHNob3VsZCBiZSBhIHN0cmluZyBoZXJlXG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnbWV0aG9kPScgKyBwYXRoO1xuICAgICAgICAgICAgYXV0aCArPSAnJmFjY2Vzc2tleT0nICsgdGhpcy5hcGlLZXk7XG4gICAgICAgICAgICBhdXRoICs9IHBhcmFtc0xlbmd0aCA/IHBhcmFtcyA6ICcnO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTEnKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHNlY3JldCksICdtZDUnKTtcbiAgICAgICAgICAgIGxldCBzdWZmaXggPSAnc2lnbj0nICsgc2lnbmF0dXJlICsgJyZyZXFUaW1lPScgKyBub25jZS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyBwYXRoICsgJz8nICsgYXV0aCArICcmJyArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKVxuICAgICAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNoaWxlYml0ID0gZXh0ZW5kIChibGlua3RyYWRlLCB7XG4gICAgJ2lkJzogJ2NoaWxlYml0JyxcbiAgICAnbmFtZSc6ICdDaGlsZUJpdCcsXG4gICAgJ2NvdW50cmllcyc6ICdDTCcsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MTQxNC0xMjk4ZjBkOC02NDdmLTExZTctOWM0MC1kNTY0MDkyNjYzMzYuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL3RhcGknLFxuICAgICAgICB9LFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY2hpbGViaXQubmV0JyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAnQmxpbmt0cmFkZSBBUEknLFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0NMUCc6IHsgJ2lkJzogJ0JUQ0NMUCcsICdzeW1ib2wnOiAnQlRDL0NMUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTFAnLCAnYnJva2VySWQnOiA5LCAnYnJva2VyJzogJ0NoaWxlQml0JyB9LFxuICAgIH0sXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjb2luY2hlY2sgPSB7XG5cbiAgICAnaWQnOiAnY29pbmNoZWNrJyxcbiAgICAnbmFtZSc6ICdjb2luY2hlY2snLFxuICAgICdjb3VudHJpZXMnOiBbICdKUCcsICdJRCcgXSxcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NDY0LTNiNWMzYzc0LTVlZDktMTFlNy04NDBlLTMxYjMyOTY4ZTFkYS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY29pbmNoZWNrLmNvbS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vY29pbmNoZWNrLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9jb2luY2hlY2suY29tL2RvY3VtZW50cy9leGNoYW5nZS9hcGknLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy9yYXRlJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfYm9va3MnLFxuICAgICAgICAgICAgICAgICdyYXRlL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAnYWNjb3VudHMvYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzL2xldmVyYWdlX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdiYW5rX2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdF9tb25leScsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy9vcGVucycsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL29yZGVycy90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9vcmRlcnMvdHJhbnNhY3Rpb25zX3BhZ2luYXRpb24nLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9sZXZlcmFnZS9wb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICdsZW5kaW5nL2JvcnJvd3MvbWF0Y2hlcycsXG4gICAgICAgICAgICAgICAgJ3NlbmRfbW9uZXknLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd3MnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdiYW5rX2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdF9tb25leS97aWR9L2Zhc3QnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFuc2ZlcnMvdG9fbGV2ZXJhZ2UnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFuc2ZlcnMvZnJvbV9sZXZlcmFnZScsXG4gICAgICAgICAgICAgICAgJ2xlbmRpbmcvYm9ycm93cycsXG4gICAgICAgICAgICAgICAgJ2xlbmRpbmcvYm9ycm93cy97aWR9L3JlcGF5JyxcbiAgICAgICAgICAgICAgICAnc2VuZF9tb25leScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3cycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAnYmFua19hY2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd3Mve2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvSlBZJzogIHsgJ2lkJzogJ2J0Y19qcHknLCAgJ3N5bWJvbCc6ICdCVEMvSlBZJywgICdiYXNlJzogJ0JUQycsICAncXVvdGUnOiAnSlBZJyB9LCAvLyB0aGUgb25seSByZWFsIHBhaXJcbiAgICAgICAgJ0VUSC9KUFknOiAgeyAnaWQnOiAnZXRoX2pweScsICAnc3ltYm9sJzogJ0VUSC9KUFknLCAgJ2Jhc2UnOiAnRVRIJywgICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICdFVEMvSlBZJzogIHsgJ2lkJzogJ2V0Y19qcHknLCAgJ3N5bWJvbCc6ICdFVEMvSlBZJywgICdiYXNlJzogJ0VUQycsICAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAnREFPL0pQWSc6ICB7ICdpZCc6ICdkYW9fanB5JywgICdzeW1ib2wnOiAnREFPL0pQWScsICAnYmFzZSc6ICdEQU8nLCAgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgJ0xTSy9KUFknOiAgeyAnaWQnOiAnbHNrX2pweScsICAnc3ltYm9sJzogJ0xTSy9KUFknLCAgJ2Jhc2UnOiAnTFNLJywgICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICdGQ1QvSlBZJzogIHsgJ2lkJzogJ2ZjdF9qcHknLCAgJ3N5bWJvbCc6ICdGQ1QvSlBZJywgICdiYXNlJzogJ0ZDVCcsICAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAnWE1SL0pQWSc6ICB7ICdpZCc6ICd4bXJfanB5JywgICdzeW1ib2wnOiAnWE1SL0pQWScsICAnYmFzZSc6ICdYTVInLCAgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgJ1JFUC9KUFknOiAgeyAnaWQnOiAncmVwX2pweScsICAnc3ltYm9sJzogJ1JFUC9KUFknLCAgJ2Jhc2UnOiAnUkVQJywgICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICdYUlAvSlBZJzogIHsgJ2lkJzogJ3hycF9qcHknLCAgJ3N5bWJvbCc6ICdYUlAvSlBZJywgICdiYXNlJzogJ1hSUCcsICAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAnWkVDL0pQWSc6ICB7ICdpZCc6ICd6ZWNfanB5JywgICdzeW1ib2wnOiAnWkVDL0pQWScsICAnYmFzZSc6ICdaRUMnLCAgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgJ1hFTS9KUFknOiAgeyAnaWQnOiAneGVtX2pweScsICAnc3ltYm9sJzogJ1hFTS9KUFknLCAgJ2Jhc2UnOiAnWEVNJywgICdxdW90ZSc6ICdKUFknIH0sXG4gICAgICAgICdMVEMvSlBZJzogIHsgJ2lkJzogJ2x0Y19qcHknLCAgJ3N5bWJvbCc6ICdMVEMvSlBZJywgICdiYXNlJzogJ0xUQycsICAncXVvdGUnOiAnSlBZJyB9LFxuICAgICAgICAnREFTSC9KUFknOiB7ICdpZCc6ICdkYXNoX2pweScsICdzeW1ib2wnOiAnREFTSC9KUFknLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0pQWScgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiAgeyAnaWQnOiAnZXRoX2J0YycsICAnc3ltYm9sJzogJ0VUSC9CVEMnLCAgJ2Jhc2UnOiAnRVRIJywgICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdFVEMvQlRDJzogIHsgJ2lkJzogJ2V0Y19idGMnLCAgJ3N5bWJvbCc6ICdFVEMvQlRDJywgICdiYXNlJzogJ0VUQycsICAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTFNLL0JUQyc6ICB7ICdpZCc6ICdsc2tfYnRjJywgICdzeW1ib2wnOiAnTFNLL0JUQycsICAnYmFzZSc6ICdMU0snLCAgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0ZDVC9CVEMnOiAgeyAnaWQnOiAnZmN0X2J0YycsICAnc3ltYm9sJzogJ0ZDVC9CVEMnLCAgJ2Jhc2UnOiAnRkNUJywgICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdYTVIvQlRDJzogIHsgJ2lkJzogJ3htcl9idGMnLCAgJ3N5bWJvbCc6ICdYTVIvQlRDJywgICdiYXNlJzogJ1hNUicsICAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnUkVQL0JUQyc6ICB7ICdpZCc6ICdyZXBfYnRjJywgICdzeW1ib2wnOiAnUkVQL0JUQycsICAnYmFzZSc6ICdSRVAnLCAgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ1hSUC9CVEMnOiAgeyAnaWQnOiAneHJwX2J0YycsICAnc3ltYm9sJzogJ1hSUC9CVEMnLCAgJ2Jhc2UnOiAnWFJQJywgICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdaRUMvQlRDJzogIHsgJ2lkJzogJ3plY19idGMnLCAgJ3N5bWJvbCc6ICdaRUMvQlRDJywgICdiYXNlJzogJ1pFQycsICAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnWEVNL0JUQyc6ICB7ICdpZCc6ICd4ZW1fYnRjJywgICdzeW1ib2wnOiAnWEVNL0JUQycsICAnYmFzZSc6ICdYRU0nLCAgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAgICAgJ0xUQy9CVEMnOiAgeyAnaWQnOiAnbHRjX2J0YycsICAnc3ltYm9sJzogJ0xUQy9CVEMnLCAgJ2Jhc2UnOiAnTFRDJywgICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdEQVNIL0JUQyc6IHsgJ2lkJzogJ2Rhc2hfYnRjJywgJ3N5bWJvbCc6ICdEQVNIL0JUQycsICdiYXNlJzogJ0RBU0gnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRzQmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZV0pO1xuICAgICAgICAgICAgbGV0IHJlc2VydmVkID0gbG93ZXJjYXNlICsgJ19yZXNlcnZlZCc7XG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWQgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbcmVzZXJ2ZWRdKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0ICB0aGlzLnB1YmxpY0dldE9yZGVyQm9va3MgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnY3JlYXRlZF9hdCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnb3JkZXJfdHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3JhdGUnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIGxldCBvcmRlcl90eXBlID0gdHlwZSArICdfJyArIHNpZGU7XG4gICAgICAgICAgICBvcmRlclsnb3JkZXJfdHlwZSddID0gb3JkZXJfdHlwZTtcbiAgICAgICAgICAgIGxldCBwcmVmaXggPSAoc2lkZSA9PSAnYnV5JykgPyAob3JkZXJfdHlwZSArICdfJykgOiAnJztcbiAgICAgICAgICAgIG9yZGVyW3ByZWZpeCArICdhbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyWydvcmRlcl90eXBlJ10gPSBzaWRlO1xuICAgICAgICAgICAgb3JkZXJbJ3JhdGUnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RFeGNoYW5nZU9yZGVycyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVEZWxldGVFeGNoYW5nZU9yZGVyc0lkICh7ICdpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5rZXlzb3J0IChxdWVyeSkpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybCArIChib2R5IHx8ICcnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FDQ0VTUy1OT05DRSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdBQ0NFU1MtU0lHTkFUVVJFJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNvaW5mbG9vciA9IHtcblxuICAgICdpZCc6ICdjb2luZmxvb3InLFxuICAgICduYW1lJzogJ2NvaW5mbG9vcicsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ2NvdW50cmllcyc6ICdVSycsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODI0NjA4MS02MjNmYzE2NC02YTFjLTExZTctOTEzZi1iYWMwZDU1NzZjOTAuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3dlYmFwaS5jb2luZmxvb3IuY28udWs6ODA5MC9iaXN0JyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5jb2luZmxvb3IuY28udWsnLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jb2luZmxvb3IvYXBpJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5jb2luZmxvb3IuY28udWsvYXBpJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICd7aWR9L3RpY2tlci8nLFxuICAgICAgICAgICAgICAgICd7aWR9L29yZGVyX2Jvb2svJyxcbiAgICAgICAgICAgICAgICAne2lkfS90cmFuc2FjdGlvbnMvJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ3tpZH0vYmFsYW5jZS8nLFxuICAgICAgICAgICAgICAgICd7aWR9L3VzZXJfdHJhbnNhY3Rpb25zLycsXG4gICAgICAgICAgICAgICAgJ3tpZH0vb3Blbl9vcmRlcnMvJyxcbiAgICAgICAgICAgICAgICAne2lkfS9jYW5jZWxfb3JkZXIvJyxcbiAgICAgICAgICAgICAgICAne2lkfS9idXkvJyxcbiAgICAgICAgICAgICAgICAne2lkfS9zZWxsLycsXG4gICAgICAgICAgICAgICAgJ3tpZH0vYnV5X21hcmtldC8nLFxuICAgICAgICAgICAgICAgICd7aWR9L3NlbGxfbWFya2V0LycsXG4gICAgICAgICAgICAgICAgJ3tpZH0vZXN0aW1hdGVfc2VsbF9tYXJrZXQvJyxcbiAgICAgICAgICAgICAgICAne2lkfS9lc3RpbWF0ZV9idXlfbWFya2V0LycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvR0JQJzogeyAnaWQnOiAnWEJUL0dCUCcsICdzeW1ib2wnOiAnQlRDL0dCUCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdHQlAnIH0sXG4gICAgICAgICdCVEMvRVVSJzogeyAnaWQnOiAnWEJUL0VVUicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgICAgICdCVEMvVVNEJzogeyAnaWQnOiAnWEJUL1VTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdCVEMvUExOJzogeyAnaWQnOiAnWEJUL1BMTicsICdzeW1ib2wnOiAnQlRDL1BMTicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdQTE4nIH0sXG4gICAgICAgICdCQ0gvR0JQJzogeyAnaWQnOiAnQkNIL0dCUCcsICdzeW1ib2wnOiAnQkNIL0dCUCcsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdHQlAnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdzeW1ib2wnIGluIHBhcmFtcylcbiAgICAgICAgICAgIHN5bWJvbCA9IHBhcmFtc1snc3ltYm9sJ107XG4gICAgICAgIGlmICgnaWQnIGluIHBhcmFtcylcbiAgICAgICAgICAgIHN5bWJvbCA9IHBhcmFtc1snaWQnXTtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hCYWxhbmNlIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0SWRCYWxhbmNlICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZE9yZGVyQm9vayAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgLy8gcmV3cml0ZSB0byBnZXQgdGhlIHRpbWVzdGFtcCBmcm9tIEhUVFAgaGVhZGVyc1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2d2FwJyksXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJZFRpY2tlciAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0SWRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHsgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSB9O1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0SWQnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG9yZGVyWydxdWFudGl0eSddID0gYW1vdW50O1xuICAgICAgICAgICAgbWV0aG9kICs9ICdNYXJrZXQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RJZENhbmNlbE9yZGVyICh7ICdpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICByZXF1ZXN0IChwYXRoLCB0eXBlID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBjdXJsIC1rIC11ICdbVXNlciBJRF0vW0FQSSBrZXldOltQYXNzcGhyYXNlXScgaHR0cHM6Ly93ZWJhcGkuY29pbmZsb29yLmNvLnVrOjgwOTAvYmlzdC9YQlQvR0JQL2JhbGFuY2UvXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmICh0eXBlID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBxdWVyeSkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSB0aGlzLnVpZCArICcvJyArIHRoaXMuYXBpS2V5ICsgJzonICsgdGhpcy5wYXNzd29yZDtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLnN0cmluZ1RvQmFzZTY0IChhdXRoKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyBzaWduYXR1cmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY29pbmdpID0ge1xuXG4gICAgJ2lkJzogJ2NvaW5naScsXG4gICAgJ25hbWUnOiAnQ29pbmdpJyxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAnY291bnRyaWVzJzogWyAnUEEnLCAnQkcnLCAnQ04nLCAnVVMnIF0sIC8vIFBhbmFtYSwgQnVsZ2FyaWEsIENoaW5hLCBVU1xuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjg2MTk3MDctNWM5MjMyYTgtNzIxMi0xMWU3LTg2ZDYtOThmZTVkMTVjYzZlLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuY29pbmdpLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2luZ2kuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwOi8vZG9jcy5jb2luZ2kuYXBpYXJ5LmlvLycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAnY3VycmVudCc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ29yZGVyLWJvb2sve3BhaXJ9L3thc2tDb3VudH0ve2JpZENvdW50fS97ZGVwdGh9JyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL3twYWlyfS97bWF4Q291bnR9JyxcbiAgICAgICAgICAgICAgICAnMjRob3VyLXJvbGxpbmctYWdncmVnYXRpb24nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3VzZXInOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2FkZC1vcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbC1vcmRlcicsXG4gICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZS1jcnlwdG8td2l0aGRyYXdhbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnbHRjLWJ0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdQUEMvQlRDJzogeyAnaWQnOiAncHBjLWJ0YycsICdzeW1ib2wnOiAnUFBDL0JUQycsICdiYXNlJzogJ1BQQycsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgICAgICdET0dFL0JUQyc6IHsgJ2lkJzogJ2RvZ2UtYnRjJywgJ3N5bWJvbCc6ICdET0dFL0JUQycsICdiYXNlJzogJ0RPR0UnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnVlRDL0JUQyc6IHsgJ2lkJzogJ3Z0Yy1idGMnLCAnc3ltYm9sJzogJ1ZUQy9CVEMnLCAnYmFzZSc6ICdWVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnRlRDL0JUQyc6IHsgJ2lkJzogJ2Z0Yy1idGMnLCAnc3ltYm9sJzogJ0ZUQy9CVEMnLCAnYmFzZSc6ICdGVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTk1DL0JUQyc6IHsgJ2lkJzogJ25tYy1idGMnLCAnc3ltYm9sJzogJ05NQy9CVEMnLCAnYmFzZSc6ICdOTUMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnREFTSC9CVEMnOiB7ICdpZCc6ICdkYXNoLWJ0YycsICdzeW1ib2wnOiAnREFTSC9CVEMnLCAnYmFzZSc6ICdEQVNIJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgY3VycmVuY2llcy5wdXNoIChjdXJyZW5jeSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy51c2VyUG9zdEJhbGFuY2UgKHtcbiAgICAgICAgICAgICdjdXJyZW5jaWVzJzogY3VycmVuY2llcy5qb2luICgnLCcpXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddWyduYW1lJ107XG4gICAgICAgICAgICBjdXJyZW5jeSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGUnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ2Jsb2NrZWQnXSArIGJhbGFuY2VbJ2luT3JkZXJzJ10gKyBiYWxhbmNlWyd3aXRoZHJhd2luZyddLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMuY3VycmVudEdldE9yZGVyQm9va1BhaXJBc2tDb3VudEJpZENvdW50RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdhc2tDb3VudCc6IDUxMiwgLy8gbWF4aW11bSByZXR1cm5lZCBudW1iZXIgb2YgYXNrcyAxLTUxMlxuICAgICAgICAgICAgJ2JpZENvdW50JzogNTEyLCAvLyBtYXhpbXVtIHJldHVybmVkIG51bWJlciBvZiBiaWRzIDEtNTEyXG4gICAgICAgICAgICAnZGVwdGgnOiAzMiwgLy8gbWF4aW11bSBudW1iZXIgb2YgZGVwdGggcmFuZ2Ugc3RlcHMgMS0zMlxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ2Jhc2VBbW91bnQnKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRpY2tlclsnaGlnaCddLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlclsnbG93J10sXG4gICAgICAgICAgICAnYmlkJzogdGlja2VyWydoaWdoZXN0QmlkJ10sXG4gICAgICAgICAgICAnYXNrJzogdGlja2VyWydsb3dlc3RBc2snXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB0aWNrZXJbJ2Jhc2VWb2x1bWUnXSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRpY2tlclsnY291bnRlclZvbHVtZSddLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aWNrZXI7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoc3ltYm9scyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmN1cnJlbnRHZXQyNGhvdXJSb2xsaW5nQWdncmVnYXRpb24gKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCByZXNwb25zZS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlW3RdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aWNrZXJbJ2N1cnJlbmN5UGFpciddWydiYXNlJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB0aWNrZXJbJ2N1cnJlbmN5UGFpciddWydjb3VudGVyJ10udG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMuZmV0Y2hUaWNrZXJzIChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gdGlja2Vyc1tzeW1ib2xdO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbJ3RpbWVzdGFtcCddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsndGltZXN0YW1wJ10pLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLCAvLyB0eXBlXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jdXJyZW50R2V0VHJhbnNhY3Rpb25zUGFpck1heENvdW50ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnbWF4Q291bnQnOiAxMjgsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3ZvbHVtZSc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ29yZGVyVHlwZSc6IChzaWRlID09ICdidXknKSA/IDAgOiAxLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnVzZXJQb3N0QWRkT3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3Jlc3VsdCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlclBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJJZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ2N1cnJlbnQnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICd0b2tlbic6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZS50b1N0cmluZyAoKSArICckJyArIHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgcmVxdWVzdFsnc2lnbmF0dXJlJ10gPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNvaW5tYXJrZXRjYXAgPSB7XG5cbiAgICAnaWQnOiAnY29pbm1hcmtldGNhcCcsXG4gICAgJ25hbWUnOiAnQ29pbk1hcmtldENhcCcsXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ2hhc1ByaXZhdGVBUEknOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODI0NDI0NC05YmU2MzEyYS02OWVkLTExZTctOTljMS03YzE3OTcyNzUyNjUuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2lubWFya2V0Y2FwLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9jb2lubWFya2V0Y2FwLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9jb2lubWFya2V0Y2FwLmNvbS9hcGknLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3RpY2tlci8nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve2lkfS8nLFxuICAgICAgICAgICAgICAgICdnbG9iYWwvJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnY3VycmVuY2llcyc6IFtcbiAgICAgICAgJ0FVRCcsXG4gICAgICAgICdCUkwnLFxuICAgICAgICAnQ0FEJyxcbiAgICAgICAgJ0NIRicsXG4gICAgICAgICdDTlknLFxuICAgICAgICAnRVVSJyxcbiAgICAgICAgJ0dCUCcsXG4gICAgICAgICdIS0QnLFxuICAgICAgICAnSURSJyxcbiAgICAgICAgJ0lOUicsXG4gICAgICAgICdKUFknLFxuICAgICAgICAnS1JXJyxcbiAgICAgICAgJ01YTicsXG4gICAgICAgICdSVUInLFxuICAgICAgICAnVVNEJyxcbiAgICBdLFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKCdGZXRjaGluZyBvcmRlciBib29rcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBBUEkgb2YgJyArIHRoaXMuaWQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZUlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IHRoaXMuY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgICAgICBsZXQgcXVvdGVJZCA9IHF1b3RlLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gYmFzZUlkICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZUlkJzogcXVvdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hHbG9iYWwgKGN1cnJlbmN5ID0gJ1VTRCcpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7fTtcbiAgICAgICAgaWYgKGN1cnJlbmN5KVxuICAgICAgICAgICAgcmVxdWVzdFsnY29udmVydCddID0gY3VycmVuY3k7XG4gICAgICAgIHJldHVybiB0aGlzLnB1YmxpY0dldEdsb2JhbCAocmVxdWVzdCk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGlmICgnbGFzdF91cGRhdGVkJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBpZiAodGlja2VyWydsYXN0X3VwZGF0ZWQnXSlcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBwYXJzZUludCAodGlja2VyWydsYXN0X3VwZGF0ZWQnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgdm9sdW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdm9sdW1lS2V5ID0gJzI0aF92b2x1bWVfJyArIG1hcmtldFsncXVvdGVJZCddO1xuICAgICAgICBpZiAodGlja2VyW3ZvbHVtZUtleV0pXG4gICAgICAgICAgICB2b2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbdm9sdW1lS2V5XSk7XG4gICAgICAgIGxldCBwcmljZSA9ICdwcmljZV8nICsgbWFya2V0WydxdW90ZUlkJ107XG4gICAgICAgIGxldCBjaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGFuZ2VLZXkgPSAncGVyY2VudF9jaGFuZ2VfMjRoJztcbiAgICAgICAgaWYgKHRpY2tlcltjaGFuZ2VLZXldKVxuICAgICAgICAgICAgY2hhbmdlID0gcGFyc2VGbG9hdCAodGlja2VyW2NoYW5nZUtleV0pO1xuICAgICAgICBsZXQgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByaWNlIGluIHRpY2tlcilcbiAgICAgICAgICAgIGlmICh0aWNrZXJbcHJpY2VdKVxuICAgICAgICAgICAgICAgIGxhc3QgPSBwYXJzZUZsb2F0ICh0aWNrZXJbcHJpY2VdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Fzayc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IGxhc3QsXG4gICAgICAgICAgICAnY2hhbmdlJzogY2hhbmdlLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdm9sdW1lLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoY3VycmVuY3kgPSAnVVNEJykge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAoY3VycmVuY3kpXG4gICAgICAgICAgICByZXF1ZXN0Wydjb252ZXJ0J10gPSBjdXJyZW5jeTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHJlcXVlc3QpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHJlc3BvbnNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbdF07XG4gICAgICAgICAgICBsZXQgaWQgPSB0aWNrZXJbJ2lkJ10gKyAnLycgKyBjdXJyZW5jeTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB0aWNrZXJzW3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpY2tlcnM7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdjb252ZXJ0JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJJZCAocmVxdWVzdCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjb2lubWF0ZSA9IHtcblxuICAgICdpZCc6ICdjb2lubWF0ZScsXG4gICAgJ25hbWUnOiAnQ29pbk1hdGUnLFxuICAgICdjb3VudHJpZXMnOiBbICdHQicsICdDWicgXSwgLy8gVUssIEN6ZWNoIFJlcHVibGljXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3ODExMjI5LWMxZWZiNTEwLTYwNmMtMTFlNy05YTM2LTg0YmEyY2U0MTJkOC5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY29pbm1hdGUuaW8vYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2NvaW5tYXRlLmlvJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwOi8vZG9jcy5jb2lubWF0ZS5hcGlhcnkuaW8nLFxuICAgICAgICAgICAgJ2h0dHBzOi8vY29pbm1hdGUuaW8vZGV2ZWxvcGVycycsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXJCb29rJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAnYml0Y29pbldpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdiaXRjb2luRGVwb3NpdEFkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgJ2J1eUluc3RhbnQnLFxuICAgICAgICAgICAgICAgICdidXlMaW1pdCcsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXJXaXRoSW5mbycsXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZVZvdWNoZXInLFxuICAgICAgICAgICAgICAgICdvcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAncmVkZWVtVm91Y2hlcicsXG4gICAgICAgICAgICAgICAgJ3NlbGxJbnN0YW50JyxcbiAgICAgICAgICAgICAgICAnc2VsbExpbWl0JyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25IaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAndW5jb25maXJtZWRCaXRjb2luRGVwb3NpdHMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ0JUQ19FVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgICAgICAnQlRDL0NaSyc6IHsgJ2lkJzogJ0JUQ19DWksnLCAnc3ltYm9sJzogJ0JUQy9DWksnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ1pLJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gYmFsYW5jZXMpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBiYWxhbmNlc1tjdXJyZW5jeV1bJ2F2YWlsYWJsZSddO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGJhbGFuY2VzW2N1cnJlbmN5XVsncmVzZXJ2ZWQnXTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZXNbY3VycmVuY3ldWydiYWxhbmNlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ2dyb3VwQnlQcmljZUxpbWl0JzogJ0ZhbHNlJyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYW1vdW50J10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJhbnNhY3Rpb25JZCddLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsndGltZXN0YW1wJ10sXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ21pbnV0ZXNJbnRvSGlzdG9yeSc6IDEwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKSB7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsndG90YWwnXSA9IGFtb3VudDsgLy8gYW1vdW50IGluIGZpYXRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnYW1vdW50J10gPSBhbW91bnQ7IC8vIGFtb3VudCBpbiBmaWF0XG4gICAgICAgICAgICBtZXRob2QgKz0gJ0luc3RhbnQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50OyAvLyBhbW91bnQgaW4gY3J5cHRvXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgbWV0aG9kICs9IHRoaXMuY2FwaXRhbGl6ZSAodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdIChzZWxmLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydkYXRhJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdvcmRlcklkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51aWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGAnICsgdGhpcy5pZCArICcudWlkYCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2NsaWVudElkJzogdGhpcy51aWQsXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ3B1YmxpY0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdzaWduYXR1cmUnOiBzaWduYXR1cmUudG9VcHBlckNhc2UgKCksXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNvaW5zZWN1cmUgPSB7XG5cbiAgICAnaWQnOiAnY29pbnNlY3VyZScsXG4gICAgJ25hbWUnOiAnQ29pbnNlY3VyZScsXG4gICAgJ2NvdW50cmllcyc6ICdJTicsIC8vIEluZGlhXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjQ3Mi05Y2JkMjAwYS01ZWQ5LTExZTctOTU1MS0yMjY3YWQ3YmFjMDguanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5jb2luc2VjdXJlLmluJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2NvaW5zZWN1cmUuaW4nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmNvaW5zZWN1cmUuaW4nLFxuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9jb2luc2VjdXJlL3BsdWdpbnMnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2JpdGNvaW4vc2VhcmNoL2NvbmZpcm1hdGlvbi97dHhpZH0nLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9hc2svbG93JyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvYXNrL29yZGVycycsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2JpZC9oaWdoJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvYmlkL29yZGVycycsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2xhc3RUcmFkZScsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL21heDI0SHInLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9taW4yNEhyJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdGlja2VyJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvdHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnbWZhL2F1dGh5L2NhbGwnLFxuICAgICAgICAgICAgICAgICdtZmEvYXV0aHkvc21zJyxcbiAgICAgICAgICAgICAgICAnbmV0a2kvc2VhcmNoL3tuZXRraU5hbWV9JyxcbiAgICAgICAgICAgICAgICAndXNlci9iYW5rL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIva3ljL290cC97bnVtYmVyfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvcHJvZmlsZS9waG9uZS9vdHAve251bWJlcn0nLFxuICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL2FkZHJlc3Mve2lkfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC9jb25maXJtZWQvYWxsJyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi9kZXBvc2l0L2NvbmZpcm1lZC97aWR9JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi9kZXBvc2l0L3VuY29uZmlybWVkL2FsbCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vZGVwb3NpdC91bmNvbmZpcm1lZC97aWR9JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93YWxsZXRzJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9iYWxhbmNlL2F2YWlsYWJsZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2JhbGFuY2UvcGVuZGluZycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2JhbGFuY2UvdG90YWwnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2RlcG9zaXQvdW52ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L2RlcG9zaXQvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9jb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9jb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iaWQvY2FuY2VsbGVkJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iaWQvY29tcGxldGVkJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iaWQvcGVuZGluZycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL2FkZHJlc3NlcycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL2JhbGFuY2UvYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYmFsYW5jZS9wZW5kaW5nJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vYmFsYW5jZS90b3RhbCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL2RlcG9zaXQvY2FuY2VsbGVkJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vZGVwb3NpdC91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vZGVwb3NpdC92ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2NhbmNlbGxlZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L2NvbXBsZXRlZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9jb2luL3dpdGhkcmF3L3VudmVyaWZpZWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy92ZXJpZmllZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9zdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9jb2luL2ZlZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvZmlhdC9mZWUnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2t5Y3MnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3JlZmVycmFsL2NvaW4vcGFpZCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvcmVmZXJyYWwvY29pbi9zdWNjZXNzZnVsJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9yZWZlcnJhbC9maWF0L3BhaWQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL3JlZmVycmFscycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvdHJhZGUvc3VtbWFyeScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvbG9naW4vdG9rZW4ve3Rva2VufScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvc3VtbWFyeScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L3N1bW1hcnknLFxuICAgICAgICAgICAgICAgICd3YWxsZXQvY29pbi93aXRoZHJhdy9jYW5jZWxsZWQnLFxuICAgICAgICAgICAgICAgICd3YWxsZXQvY29pbi93aXRoZHJhdy9jb21wbGV0ZWQnLFxuICAgICAgICAgICAgICAgICd3YWxsZXQvY29pbi93aXRoZHJhdy91bnZlcmlmaWVkJyxcbiAgICAgICAgICAgICAgICAnd2FsbGV0L2NvaW4vd2l0aGRyYXcvdmVyaWZpZWQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdsb2dpbicsXG4gICAgICAgICAgICAgICAgJ2xvZ2luL2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAnbG9naW4vcGFzc3dvcmQvZm9yZ290JyxcbiAgICAgICAgICAgICAgICAnbWZhL2F1dGh5L2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAnbWZhL2dhL2luaXRpYXRlJyxcbiAgICAgICAgICAgICAgICAnc2lnbnVwJyxcbiAgICAgICAgICAgICAgICAndXNlci9uZXRraS91cGRhdGUnLFxuICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvaW1hZ2UvdXBkYXRlJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2NvaW4vd2l0aGRyYXcvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy9uZXdWZXJpZnljb2RlJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvaW5pdGlhdGUnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC93aXRoZHJhdy9uZXdWZXJpZnljb2RlJyxcbiAgICAgICAgICAgICAgICAndXNlci9wYXNzd29yZC9jaGFuZ2UnLFxuICAgICAgICAgICAgICAgICd1c2VyL3Bhc3N3b3JkL3Jlc2V0JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy9pbml0aWF0ZScsXG4gICAgICAgICAgICAgICAgJ3dhbGxldC9jb2luL3dpdGhkcmF3L25ld1ZlcmlmeWNvZGUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwdXQnOiBbXG4gICAgICAgICAgICAgICAgJ3NpZ251cC92ZXJpZnkve3Rva2VufScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2Uva3ljJyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvZGVwb3NpdC9uZXcnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2Fzay9uZXcnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JpZC9uZXcnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2luc3RhbnQvYnV5JyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9pbnN0YW50L3NlbGwnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy92ZXJpZnknLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9hY2NvdW50L25ldycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYmFuay9maWF0L3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvbWZhL2F1dGh5L2luaXRpYXRlL2VuYWJsZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvbWZhL2dhL2luaXRpYXRlL2VuYWJsZScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvbmV0a2kvY3JlYXRlJyxcbiAgICAgICAgICAgICAgICAndXNlci9wcm9maWxlL3Bob25lL25ldycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vYWRkcmVzcy9uZXcnLFxuICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL25ldycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvd2FsbGV0L2NvaW4vd2l0aGRyYXcvc2VuZFRvRXhjaGFuZ2UnLFxuICAgICAgICAgICAgICAgICd1c2VyL3dhbGxldC9jb2luL3dpdGhkcmF3L3ZlcmlmeScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAndXNlci9nY20ve2NvZGV9JyxcbiAgICAgICAgICAgICAgICAndXNlci9sb2dvdXQnLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvY29pbi93aXRoZHJhdy91bnZlcmlmaWVkL2NhbmNlbC97d2l0aGRyYXdJRH0nLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JhbmsvZmlhdC9kZXBvc2l0L2NhbmNlbC97ZGVwb3NpdElEfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvZXhjaGFuZ2UvYXNrL2NhbmNlbC97b3JkZXJJRH0nLFxuICAgICAgICAgICAgICAgICd1c2VyL2V4Y2hhbmdlL2JpZC9jYW5jZWwve29yZGVySUR9JyxcbiAgICAgICAgICAgICAgICAndXNlci9leGNoYW5nZS9iYW5rL2ZpYXQvd2l0aGRyYXcvdW52ZXJpZmllZC9jYW5jZWwve3dpdGhkcmF3SUR9JyxcbiAgICAgICAgICAgICAgICAndXNlci9tZmEvYXV0aHkvZGlzYWJsZS97Y29kZX0nLFxuICAgICAgICAgICAgICAgICd1c2VyL21mYS9nYS9kaXNhYmxlL3tjb2RlfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvcHJvZmlsZS9waG9uZS9kZWxldGUnLFxuICAgICAgICAgICAgICAgICd1c2VyL3Byb2ZpbGUvaW1hZ2UvZGVsZXRlL3tuZXRraU5hbWV9JyxcbiAgICAgICAgICAgICAgICAndXNlci93YWxsZXQvY29pbi93aXRoZHJhdy91bnZlcmlmaWVkL2NhbmNlbC97d2l0aGRyYXdJRH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0lOUic6IHsgJ2lkJzogJ0JUQy9JTlInLCAnc3ltYm9sJzogJ0JUQy9JTlInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnSU5SJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFVzZXJFeGNoYW5nZUJhbmtTdW1tYXJ5ICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydtZXNzYWdlJ107XG4gICAgICAgIGxldCBjb2luID0ge1xuICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlWydhdmFpbGFibGVDb2luQmFsYW5jZSddLFxuICAgICAgICAgICAgJ3VzZWQnOiBiYWxhbmNlWydwZW5kaW5nQ29pbkJhbGFuY2UnXSxcbiAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ3RvdGFsQ29pbkJhbGFuY2UnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZpYXQgPSB7XG4gICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2VbJ2F2YWlsYWJsZUZpYXRCYWxhbmNlJ10sXG4gICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ3BlbmRpbmdGaWF0QmFsYW5jZSddLFxuICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZVsndG90YWxGaWF0QmFsYW5jZSddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBiYWxhbmNlLFxuICAgICAgICAgICAgJ0JUQyc6IGNvaW4sXG4gICAgICAgICAgICAnSU5SJzogZmlhdCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJpZHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlQmlkT3JkZXJzIChwYXJhbXMpO1xuICAgICAgICBsZXQgYXNrcyA9IGF3YWl0IHRoaXMucHVibGljR2V0RXhjaGFuZ2VBc2tPcmRlcnMgKHBhcmFtcyk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSB7XG4gICAgICAgICAgICAnYmlkcyc6IGJpZHNbJ21lc3NhZ2UnXSxcbiAgICAgICAgICAgICdhc2tzJzogYXNrc1snbWVzc2FnZSddLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncmF0ZScsICd2b2wnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKG1hcmtldCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlVGlja2VyICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ21lc3NhZ2UnXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2NvaW52b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2ZpYXR2b2x1bWUnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZmV0Y2hUcmFkZXMgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljR2V0RXhjaGFuZ2VUcmFkZXMgKHBhcmFtcyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVB1dFVzZXJFeGNoYW5nZSc7XG4gICAgICAgIGxldCBvcmRlciA9IHt9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdJbnN0YW50JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsnbWF4RmlhdCddID0gYW1vdW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9yZGVyWydtYXhWb2wnXSA9IGFtb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSAoc2lkZSA9PSAnYnV5JykgPyAnQmlkJyA6ICdBc2snO1xuICAgICAgICAgICAgbWV0aG9kICs9IGRpcmVjdGlvbiArICdOZXcnO1xuICAgICAgICAgICAgb3JkZXJbJ3JhdGUnXSA9IHByaWNlO1xuICAgICAgICAgICAgb3JkZXJbJ3ZvbCddID0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAoc2VsZi5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnbWVzc2FnZSddWydvcmRlcklEJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgKCkgaXMgbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVEZWxldGVVc2VyRXhjaGFuZ2VBc2tDYW5jZWxPcmRlcklkJzsgLy8gVE9ETyBmaXhtZSwgaGF2ZSB0byBzcGVjaWZ5IG9yZGVyIHNpZGUgaGVyZVxuICAgICAgICByZXR1cm4gdGhpc1ttZXRob2RdICh7ICdvcmRlcklEJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogdGhpcy5hcGlLZXkgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnc3VjY2VzcycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNvaW5zcG90ID0ge1xuXG4gICAgJ2lkJzogJ2NvaW5zcG90JyxcbiAgICAnbmFtZSc6ICdDb2luU3BvdCcsXG4gICAgJ2NvdW50cmllcyc6ICdBVScsIC8vIEF1c3RyYWxpYVxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjgyMDg0MjktM2NhY2RmOWEtNjg5Ni0xMWU3LTg1NGUtNGM3OWE3NzJhMzBmLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3LmNvaW5zcG90LmNvbS5hdS9wdWJhcGknLFxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cuY29pbnNwb3QuY29tLmF1L2FwaScsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuY29pbnNwb3QuY29tLmF1JyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5jb2luc3BvdC5jb20uYXUvYXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdsYXRlc3QnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzL2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdteS9jb2luL2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICdteS9jb2luL3NlbmQnLFxuICAgICAgICAgICAgICAgICdxdW90ZS9idXknLFxuICAgICAgICAgICAgICAgICdxdW90ZS9zZWxsJyxcbiAgICAgICAgICAgICAgICAnbXkvYmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICdteS9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdteS9idXknLFxuICAgICAgICAgICAgICAgICdteS9zZWxsJyxcbiAgICAgICAgICAgICAgICAnbXkvYnV5L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ215L3NlbGwvY2FuY2VsJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9BVUQnOiB7ICdpZCc6ICdCVEMnLCAnc3ltYm9sJzogJ0JUQy9BVUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQVVEJyB9LFxuICAgICAgICAnTFRDL0FVRCc6IHsgJ2lkJzogJ0xUQycsICdzeW1ib2wnOiAnTFRDL0FVRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgICAgICdET0dFL0FVRCc6IHsgJ2lkJzogJ0RPR0UnLCAnc3ltYm9sJzogJ0RPR0UvQVVEJywgJ2Jhc2UnOiAnRE9HRScsICdxdW90ZSc6ICdBVUQnIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE15QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgaWYgKCdiYWxhbmNlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2VzW2N1cnJlbmN5XSxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VzW2N1cnJlbmN5XSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh1cHBlcmNhc2UgPT0gJ0RSSycpXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyY2FzZSA9ICdEQVNIJztcbiAgICAgICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjb2ludHlwZSc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5b3JkZXJzJywgJ3NlbGxvcmRlcnMnLCAncmF0ZScsICdhbW91bnQnKTtcbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChtYXJrZXQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRMYXRlc3QgKCk7XG4gICAgICAgIGxldCBpZCA9IHRoaXMubWFya2V0SWQgKG1hcmtldCk7XG4gICAgICAgIGlkID0gaWQudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsncHJpY2VzJ11baWRdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBmZXRjaFRyYWRlcyAobWFya2V0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdE9yZGVyc0hpc3RvcnkgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbnR5cGUnOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdE15JyArIHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY29pbnR5cGUnOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdyYXRlJzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGNhbmNlbE9yZGVyICgpIGlzIG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdE15QnV5JztcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kXSAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuYXBpS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGFwaUtleSBmb3IgYWxsIHJlcXVlc3RzJyk7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHRoaXMuZXh0ZW5kICh7ICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgY3J5cHRvcGlhID0ge1xuXG4gICAgJ2lkJzogJ2NyeXB0b3BpYScsXG4gICAgJ25hbWUnOiAnQ3J5cHRvcGlhJyxcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnY291bnRyaWVzJzogJ05aJywgLy8gTmV3IFplYWxhbmRcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI5NDg0Mzk0LTdiNGVhNmUyLTg0YzYtMTFlNy04M2U1LTFmY2NmNGIyZGM4MS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmNyeXB0b3BpYS5jby5uei9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmNyeXB0b3BpYS5jby5ueicsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cuY3J5cHRvcGlhLmNvLm56L0ZvcnVtL1RocmVhZC8yNTUnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3LmNyeXB0b3BpYS5jby5uei9Gb3J1bS9UaHJlYWQvMjU2JyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdHZXRDdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAnR2V0VHJhZGVQYWlycycsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldHMnLFxuICAgICAgICAgICAgICAgICdHZXRNYXJrZXRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICdHZXRNYXJrZXRzL3tob3Vyc30nLFxuICAgICAgICAgICAgICAgICdHZXRNYXJrZXRzL3tpZH0ve2hvdXJzfScsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldC97aWR9JyxcbiAgICAgICAgICAgICAgICAnR2V0TWFya2V0L3tpZH0ve2hvdXJzfScsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldEhpc3Rvcnkve2lkfScsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldEhpc3Rvcnkve2lkfS97aG91cnN9JyxcbiAgICAgICAgICAgICAgICAnR2V0TWFya2V0T3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICdHZXRNYXJrZXRPcmRlcnMve2lkfS97Y291bnR9JyxcbiAgICAgICAgICAgICAgICAnR2V0TWFya2V0T3JkZXJHcm91cHMve2lkc30ve2NvdW50fScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdDYW5jZWxUcmFkZScsXG4gICAgICAgICAgICAgICAgJ0dldEJhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdHZXREZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ0dldE9wZW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICdHZXRUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICdHZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICdTdWJtaXRUaXAnLFxuICAgICAgICAgICAgICAgICdTdWJtaXRUcmFkZScsXG4gICAgICAgICAgICAgICAgJ1N1Ym1pdFRyYW5zZmVyJyxcbiAgICAgICAgICAgICAgICAnU3VibWl0V2l0aGRyYXcnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZVBhaXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnSWQnXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ0xhYmVsJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgICAgICAnbWFrZXInOiBtYXJrZXRbJ1RyYWRlRmVlJ10gLyAxMDAsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogbWFya2V0WydUcmFkZUZlZSddIC8gMTAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRPcmRlcnNJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnQnV5JywgJ1NlbGwnLCAnUHJpY2UnLCAnVm9sdW1lJyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnSGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0JpZFByaWNlJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnQXNrUHJpY2UnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydPcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogcGFyc2VGbG9hdCAodGlja2VyWydDbG9zZSddKSxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydMYXN0UHJpY2UnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydDaGFuZ2UnXSksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ0Jhc2VWb2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ1ZvbHVtZSddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0SWQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSByZXNwb25zZVsnRGF0YSddO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydUcmFkZVBhaXJJZCddO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydUaW1lc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydUeXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsnUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnQW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRIaXN0b3J5SWRIb3VycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdob3Vycyc6IDI0LCAvLyBkZWZhdWx0XG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHRyYWRlcywgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ0RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnU3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2VbJ0F2YWlsYWJsZSddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ1RvdGFsJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChtYXJrZXQsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdUcmFkZVBhaXJJZCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnVHlwZSc6IHRoaXMuY2FwaXRhbGl6ZSAoc2lkZSksXG4gICAgICAgICAgICAnUmF0ZSc6IHByaWNlLFxuICAgICAgICAgICAgJ0Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFN1Ym1pdFRyYWRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydEYXRhJ11bJ09yZGVySWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsVHJhZGUgKHtcbiAgICAgICAgICAgICdUeXBlJzogJ1RyYWRlJyxcbiAgICAgICAgICAgICdPcmRlcklkJzogaWQsXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBwYXJzZU9yZGVyIChvcmRlciwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIH0gZWxzZSBpZiAoJ01hcmtldCcgaW4gb3JkZXIpIHtcbiAgICAgICAgICAgIGxldCBpZCA9IG9yZGVyWydNYXJrZXQnXTtcbiAgICAgICAgICAgIGlmIChpZCBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlclsnVGltZVN0YW1wJ10pO1xuICAgICAgICBsZXQgYW1vdW50ID0gb3JkZXJbJ0Ftb3VudCddO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gb3JkZXJbJ1JlbWFpbmluZyddO1xuICAgICAgICBsZXQgZmlsbGVkID0gYW1vdW50IC0gcmVtYWluaW5nO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ09yZGVySWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3RhdHVzJzogb3JkZXJbJ3N0YXR1cyddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ1R5cGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IG9yZGVyWydSYXRlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2ZpbGxlZCc6IGZpbGxlZCxcbiAgICAgICAgICAgICdyZW1haW5pbmcnOiByZW1haW5pbmcsXG4gICAgICAgICAgICAvLyAndHJhZGVzJzogdGhpcy5wYXJzZVRyYWRlcyAob3JkZXJbJ3RyYWRlcyddLCBtYXJrZXQpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hPcGVuT3JkZXJzIHJlcXVpcmVzIGEgc3ltYm9sIHBhcmFtJyk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldE9wZW5PcmRlcnMgKHtcbiAgICAgICAgICAgIC8vICdNYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnVHJhZGVQYWlySWQnOiBtYXJrZXRbJ2lkJ10sIC8vIENyeXB0b3BpYSBpZGVudGlmaWVyIChub3QgcmVxdWlyZWQgaWYgJ01hcmtldCcgc3VwcGxpZWQpXG4gICAgICAgICAgICAvLyAnQ291bnQnOiAxMDAsIC8vIGRlZmF1bHQgPSAxMDBcbiAgICAgICAgfSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHJlc3BvbnNlWydEYXRhJ107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvcmRlciA9IG9yZGVyc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLmV4dGVuZCAob3JkZXIsIHsgJ3N0YXR1cyc6ICdvcGVuJyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3VsdCwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RTdWJtaXRXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ0Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdBZGRyZXNzJzogYWRkcmVzcywgLy8gQWRkcmVzcyBtdXN0IGV4aXN0IGluIHlvdSBBZGRyZXNzQm9vayBpbiBzZWN1cml0eSBzZXR0aW5nc1xuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnRGF0YSddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKGJvZHkpLCAnbWQ1JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCB1cmkgPSB0aGlzLmVuY29kZVVSSUNvbXBvbmVudCAodXJsKTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSB1cmkudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcGF5bG9hZCA9IHRoaXMuYXBpS2V5ICsgbWV0aG9kICsgbG93ZXJjYXNlICsgbm9uY2UgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChoYXNoKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChwYXlsb2FkKSwgc2VjcmV0LCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnYW14ICcgKyB0aGlzLmFwaUtleSArICc6JyArIHRoaXMuYmluYXJ5VG9TdHJpbmcgKHNpZ25hdHVyZSkgKyAnOicgKyBub25jZTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGF1dGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCdTdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VbJ1N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBkc3ggPSB7XG5cbiAgICAnaWQnOiAnZHN4JyxcbiAgICAnbmFtZSc6ICdEU1gnLFxuICAgICdjb3VudHJpZXMnOiAnVUsnLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTAyNzUtMTQxMzE1OGEtNjQ1YS0xMWU3LTkzMWMtOTQ3MTdmNzUxMGUzLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAnbWFwaSc6ICdodHRwczovL2RzeC51ay9tYXBpJywgLy8gbWFya2V0IGRhdGFcbiAgICAgICAgICAgICd0YXBpJzogJ2h0dHBzOi8vZHN4LnVrL3RhcGknLCAvLyB0cmFkaW5nXG4gICAgICAgICAgICAnZHdhcGknOiAnaHR0cHM6Ly9kc3gudWsvZHdhcGknLCAvLyBkZXBvc2l0L3dpdGhkcmF3XG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9kc3gudWsnLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLmRzeC51aycsXG4gICAgICAgICAgICAnaHR0cHM6Ly9kc3gudWsvYXBpX2RvY3MvcHVibGljJyxcbiAgICAgICAgICAgICdodHRwczovL2RzeC51ay9hcGlfZG9jcy9wcml2YXRlJyxcbiAgICAgICAgICAgICcnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgLy8gbWFya2V0IGRhdGEgKHB1YmxpYylcbiAgICAgICAgJ21hcGknOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdiYXJzRnJvbU1vbWVudC97aWR9L3twZXJpb2R9L3tzdGFydH0nLCAvLyBlbXB0eSByZXBseSA6XFxcbiAgICAgICAgICAgICAgICAnZGVwdGgve2lkfScsXG4gICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICdsYXN0QmFycy97aWR9L3twZXJpb2R9L3thbW91bnR9JywgLy8gcGVyaW9kIGlzIChtLCBoIG9yIGQpXG4gICAgICAgICAgICAgICAgJ3BlcmlvZEJhcnMve2lkfS97cGVyaW9kfS97c3RhcnR9L3tlbmR9JyxcbiAgICAgICAgICAgICAgICAndGlja2VyL3tpZH0nLFxuICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAvLyB0cmFkaW5nIChwcml2YXRlKVxuICAgICAgICAndGFwaSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAnVHJhbnNIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnT3JkZXJIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnVHJhZGUnLFxuICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAvLyBkZXBvc2l0IC8gd2l0aGRyYXcgKHByaXZhdGUpXG4gICAgICAgICdkd2FwaSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdnZXRDcnlwdG9EZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ2NyeXB0b1dpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAnZmlhdFdpdGhkcmF3JyxcbiAgICAgICAgICAgICAgICAnZ2V0VHJhbnNhY3Rpb25TdGF0dXMnLFxuICAgICAgICAgICAgICAgICdnZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXBpR2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAocmVzcG9uc2VbJ3BhaXJzJ10pO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1twXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSByZXNwb25zZVsncGFpcnMnXVtpZF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRhcGlQb3N0R2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3JldHVybiddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzWyd0b3RhbCddKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlc1snZnVuZHMnXVtjdXJyZW5jeV0sXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZXNbJ3RvdGFsJ11bY3VycmVuY3ldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFwaUdldERlcHRoSWQgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1hcGlHZXRUaWNrZXJJZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlW21hcmtldFsnaWQnXV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2ZyddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbF9jdXInXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubWFwaUdldFRyYWRlc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50YXBpUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXR1cm4nXVsnb3JkZXJJZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudGFwaVBvc3RDYW5jZWxPcmRlciAoeyAnb3JkZXJJZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAnbWFwaScsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBpZiAoKGFwaSA9PSAnbWFwaScpIHx8IChhcGkgPT0gJ2R3YXBpJykpXG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ21hcGknKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHRoaXMuZGVjb2RlIChzaWduYXR1cmUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ21hcGknKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydzdWNjZXNzJ10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBleG1vID0ge1xuXG4gICAgJ2lkJzogJ2V4bW8nLFxuICAgICduYW1lJzogJ0VYTU8nLFxuICAgICdjb3VudHJpZXMnOiBbICdFUycsICdSVScgXSwgLy8gU3BhaW4sIFJ1c3NpYVxuICAgICdyYXRlTGltaXQnOiAxMDAwLCAvLyBvbmNlIGV2ZXJ5IDM1MCBtcyDiiYggMTgwIHJlcXVlc3RzIHBlciBtaW51dGUg4omIIDMgcmVxdWVzdHMgcGVyIHNlY29uZFxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NDkxLTFiMGVhOTU2LTVlZGEtMTFlNy05MjI1LTQwZDY3YjQ4MWI4ZC5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmV4bW8uY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2V4bW8ubWUnLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vZXhtby5tZS9ydS9hcGlfZG9jJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vZXhtby1kZXYvZXhtb19hcGlfbGliL3RyZWUvbWFzdGVyL25vZGVqcycsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knLFxuICAgICAgICAgICAgICAgICdvcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAncGFpcl9zZXR0aW5ncycsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICd1c2VyX2luZm8nLFxuICAgICAgICAgICAgICAgICdvcmRlcl9jcmVhdGUnLFxuICAgICAgICAgICAgICAgICdvcmRlcl9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICd1c2VyX29wZW5fb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAndXNlcl90cmFkZXMnLFxuICAgICAgICAgICAgICAgICd1c2VyX2NhbmNlbGxlZF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdvcmRlcl90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdyZXF1aXJlZF9hbW91bnQnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd19jcnlwdCcsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2dldF90eGlkJyxcbiAgICAgICAgICAgICAgICAnZXhjb2RlX2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgJ2V4Y29kZV9sb2FkJyxcbiAgICAgICAgICAgICAgICAnd2FsbGV0X2hpc3RvcnknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFBhaXJTZXR0aW5ncyAoKTtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAobWFya2V0cyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGlkLnJlcGxhY2UgKCdfJywgJy8nKTtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VXNlckluZm8gKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0aGlzLmN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbmN5IGluIHJlc3BvbnNlWydiYWxhbmNlcyddKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKHJlc3BvbnNlWydiYWxhbmNlcyddW2N1cnJlbmN5XSk7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzcG9uc2VbJ3Jlc2VydmVkJ10pXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gcGFyc2VGbG9hdCAocmVzcG9uc2VbJ3Jlc2VydmVkJ11bY3VycmVuY3ldKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZCcsICdhc2snKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXlfcHJpY2UnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsX3ByaWNlJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3RyYWRlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2ZyddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbF9jdXJyJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoY3VycmVuY3kgPSAnVVNEJykge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHJlc3BvbnNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2VbbWFya2V0WydpZCddXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndHJhZGVfaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbbWFya2V0WydpZCddXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHByZWZpeCA9ICcnO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHByZWZpeCA9ICdtYXJrZXRfJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ3F1YW50aXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UgfHwgMCxcbiAgICAgICAgICAgICd0eXBlJzogcHJlZml4ICsgc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyQ3JlYXRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcmRlckNhbmNlbCAoeyAnb3JkZXJfaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHBhdGg7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgncmVzdWx0JyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZmxvd2J0YyA9IHtcblxuICAgICdpZCc6ICdmbG93YnRjJyxcbiAgICAnbmFtZSc6ICdmbG93QlRDJyxcbiAgICAnY291bnRyaWVzJzogJ0JSJywgLy8gQnJhemlsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODE2MjQ2NS1jZDgxNWQ0Yy02N2NmLTExZTctOGU1Ny00MzhiZWEwNTIzYTIuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5mbG93YnRjLmNvbTo4NDAwL2FqYXgnLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdHJhZGVyLmZsb3didGMuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwOi8vd3d3LmZsb3didGMuY29tLmJyL2FwaS8nLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdHZXRUaWNrZXInLFxuICAgICAgICAgICAgICAgICdHZXRUcmFkZXMnLFxuICAgICAgICAgICAgICAgICdHZXRUcmFkZXNCeURhdGUnLFxuICAgICAgICAgICAgICAgICdHZXRPcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICdHZXRQcm9kdWN0UGFpcnMnLFxuICAgICAgICAgICAgICAgICdHZXRQcm9kdWN0cycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdDcmVhdGVBY2NvdW50JyxcbiAgICAgICAgICAgICAgICAnR2V0VXNlckluZm8nLFxuICAgICAgICAgICAgICAgICdTZXRVc2VySW5mbycsXG4gICAgICAgICAgICAgICAgJ0dldEFjY291bnRJbmZvJyxcbiAgICAgICAgICAgICAgICAnR2V0QWNjb3VudFRyYWRlcycsXG4gICAgICAgICAgICAgICAgJ0dldERlcG9zaXRBZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICdXaXRoZHJhdycsXG4gICAgICAgICAgICAgICAgJ0NyZWF0ZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAnTW9kaWZ5T3JkZXInLFxuICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgJ0NhbmNlbEFsbE9yZGVycycsXG4gICAgICAgICAgICAgICAgJ0dldEFjY291bnRPcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnR2V0T3JkZXJGZWUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0UHJvZHVjdFBhaXJzICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydwcm9kdWN0UGFpcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsncHJvZHVjdDFMYWJlbCddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0Wydwcm9kdWN0MkxhYmVsJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEFjY291bnRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnY3VycmVuY2llcyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWyduYW1lJ107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2VbJ2JhbGFuY2UnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ2hvbGQnXSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY1Bvc3RHZXRPcmRlckJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJvZHVjdFBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHgnLCAncXR5Jyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0VGlja2VyICh7XG4gICAgICAgICAgICAncHJvZHVjdFBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUyNGhyJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUyNGhyUHJvZHVjdDInXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3VuaXh0aW1lJ10gKiAxMDAwO1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsnaW5jb21pbmdPcmRlclNpZGUnXSA9PSAwKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3B4J10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ3F0eSddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljUG9zdEdldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpbnMnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc3RhcnRJbmRleCc6IC0xLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWyd0cmFkZXMnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyVHlwZSA9ICh0eXBlID09ICdtYXJrZXQnKSA/IDEgOiAwO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnaW5zJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdvcmRlclR5cGUnOiBvcmRlclR5cGUsXG4gICAgICAgICAgICAncXR5JzogYW1vdW50LFxuICAgICAgICAgICAgJ3B4JzogcHJpY2UsXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RDcmVhdGVPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnc2VydmVyT3JkZXJJZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICgnaW5zJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ3NlcnZlck9yZGVySWQnOiBpZCxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgaW5zYCBzeW1ib2wgcGFyYW1ldGVyIGZvciBjYW5jZWxsaW5nIGFuIG9yZGVyJyk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51aWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIGAnICsgdGhpcy5pZCArICcudWlkYCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24nKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IG5vbmNlLnRvU3RyaW5nICgpICsgdGhpcy51aWQgKyB0aGlzLmFwaUtleTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnYXBpTm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnYXBpU2lnJzogc2lnbmF0dXJlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdpc0FjY2VwdGVkJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnaXNBY2NlcHRlZCddKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZm94Yml0ID0gZXh0ZW5kIChibGlua3RyYWRlLCB7XG4gICAgJ2lkJzogJ2ZveGJpdCcsXG4gICAgJ25hbWUnOiAnRm94Qml0JyxcbiAgICAnY291bnRyaWVzJzogJ0JSJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkxNDEzLTExYjQwZDQyLTY0N2YtMTFlNy05MWVlLTc4Y2VkODc0ZGQwOS5qcGcnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vdGFwaScsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9mb3hiaXQuZXhjaGFuZ2UnLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgfSxcbiAgICAnY29tbWVudCc6ICdCbGlua3RyYWRlIEFQSScsXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvQlJMJzogeyAnaWQnOiAnQlRDQlJMJywgJ3N5bWJvbCc6ICdCVEMvQlJMJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ0JSTCcsICdicm9rZXJJZCc6IDQsICdicm9rZXInOiAnRm94Qml0JyB9LFxuICAgIH0sXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBmeWIgPSB7XG5cbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndGlja2VyZGV0YWlsZWQnLFxuICAgICAgICAgICAgICAgICdvcmRlcmJvb2snLFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAndGVzdCcsXG4gICAgICAgICAgICAgICAgJ2dldGFjY2luZm8nLFxuICAgICAgICAgICAgICAgICdnZXRwZW5kaW5nb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnZ2V0b3JkZXJoaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnY2FuY2VscGVuZGluZ29yZGVyJyxcbiAgICAgICAgICAgICAgICAncGxhY2VvcmRlcicsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0YWNjaW5mbyAoKTtcbiAgICAgICAgbGV0IGJ0YyA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2J0Y0JhbCddKTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHRoaXMuc3ltYm9sc1swXTtcbiAgICAgICAgbGV0IHF1b3RlID0gdGhpcy5tYXJrZXRzW3N5bWJvbF1bJ3F1b3RlJ107XG4gICAgICAgIGxldCBsb3dlcmNhc2UgPSBxdW90ZS50b0xvd2VyQ2FzZSAoKSArICdCYWwnO1xuICAgICAgICBsZXQgZmlhdCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbbG93ZXJjYXNlXSk7XG4gICAgICAgIGxldCBjcnlwdG8gPSB7XG4gICAgICAgICAgICAnZnJlZSc6IGJ0YyxcbiAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgJ3RvdGFsJzogYnRjLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgYWNjb3VudHMgPSB7ICdCVEMnOiBjcnlwdG8gfTtcbiAgICAgICAgYWNjb3VudHNbcXVvdGVdID0ge1xuICAgICAgICAgICAgJ2ZyZWUnOiBmaWF0LFxuICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAndG90YWwnOiBmaWF0LFxuICAgICAgICB9O1xuICAgICAgICBhY2NvdW50c1snaW5mbyddID0gYmFsYW5jZTtcbiAgICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcmRldGFpbGVkICgpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdm9sdW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ2xhc3QnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGxhc3QgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSk7XG4gICAgICAgIGlmICgndm9sJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICB2b2x1bWUgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHZvbHVtZSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UGxhY2VvcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdxdHknOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZVswXS50b1VwcGVyQ2FzZSAoKVxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncGVuZGluZ19vaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VscGVuZGluZ29yZGVyICh7ICdvcmRlck5vJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy5qc29uJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7ICd0aW1lc3RhbXAnOiBub25jZSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGExJylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJylcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBmeWJzZSA9IGV4dGVuZCAoZnliLCB7XG4gICAgJ2lkJzogJ2Z5YnNlJyxcbiAgICAnbmFtZSc6ICdGWUItU0UnLFxuICAgICdjb3VudHJpZXMnOiAnU0UnLCAvLyBTd2VkZW5cbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTEyLTMxMDE5NzcyLTVlZGItMTFlNy04MjQxLTJlNjc1ZTY3OTdmMS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vd3d3LmZ5YnNlLnNlL2FwaS9TRUsnLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmZ5YnNlLnNlJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwOi8vZG9jcy5meWIuYXBpYXJ5LmlvJyxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1NFSyc6IHsgJ2lkJzogJ1NFSycsICdzeW1ib2wnOiAnQlRDL1NFSycsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdTRUsnIH0sXG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGZ5YnNnID0gZXh0ZW5kIChmeWIsIHtcbiAgICAnaWQnOiAnZnlic2cnLFxuICAgICduYW1lJzogJ0ZZQi1TRycsXG4gICAgJ2NvdW50cmllcyc6ICdTRycsIC8vIFNpbmdhcG9yZVxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1MTMtMzM2NGQ1NmEtNWVkYi0xMWU3LTllNmItZDU4OThiYjg5YzgxLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuZnlic2cuY29tL2FwaS9TR0QnLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LmZ5YnNnLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cDovL2RvY3MuZnliLmFwaWFyeS5pbycsXG4gICAgfSxcbiAgICAnbWFya2V0cyc6IHtcbiAgICAgICAgJ0JUQy9TR0QnOiB7ICdpZCc6ICdTR0QnLCAnc3ltYm9sJzogJ0JUQy9TR0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnU0dEJyB9LFxuICAgIH0sXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBnYXRlY29pbiA9IHtcblxuICAgICdpZCc6ICdnYXRlY29pbicsXG4gICAgJ25hbWUnOiAnR2F0ZWNvaW4nLFxuICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAnY29tbWVudCc6ICdhIHJlZ3VsYXRlZC9saWNlbnNlZCBleGNoYW5nZScsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IHRydWUsXG4gICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICcxbSc6ICcxbScsXG4gICAgICAgICcxNW0nOiAnMTVtJyxcbiAgICAgICAgJzFoJzogJzFoJyxcbiAgICAgICAgJzZoJzogJzZoJyxcbiAgICAgICAgJzFkJzogJzI0aCcsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yODY0NjgxNy01MDg0NTdmMi03MjZjLTExZTctOWVlYi0zNTI4ZDI0MTNhNTguanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5nYXRlY29pbi5jb20nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vZ2F0ZWNvaW4uY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL2dhdGVjb2luLmNvbS9hcGknLFxuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9HYXRlY29pbi9SRVNUZnVsLUFQSS1JbXBsZW1lbnRhdGlvbicsXG4gICAgICAgICAgICAnaHR0cHM6Ly9hcGkuZ2F0ZWNvaW4uY29tL3N3YWdnZXItdWkvaW5kZXguaHRtbCcsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnUHVibGljL0V4Y2hhbmdlUmF0ZScsIC8vIEdldCB0aGUgZXhjaGFuZ2UgcmF0ZXNcbiAgICAgICAgICAgICAgICAnUHVibGljL0xpdmVUaWNrZXInLCAvLyBHZXQgbGl2ZSB0aWNrZXIgZm9yIGFsbCBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICdQdWJsaWMvTGl2ZVRpY2tlci97Q3VycmVuY3lQYWlyfScsIC8vIEdldCBsaXZlIHRpY2tlciBieSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICdQdWJsaWMvTGl2ZVRpY2tlcnMnLCAvLyBHZXQgbGl2ZSB0aWNrZXIgZm9yIGFsbCBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICdQdWJsaWMvTWFya2V0RGVwdGgve0N1cnJlbmN5UGFpcn0nLCAvLyBHZXRzIHByaWNlcyBhbmQgbWFya2V0IGRlcHRoIGZvciB0aGUgY3VycmVuY3kgcGFpci5cbiAgICAgICAgICAgICAgICAnUHVibGljL05ldHdvcmtTdGF0aXN0aWNzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IHRoZSBuZXR3b3JrIHN0YXR1cyBvZiBhIHNwZWNpZmljIGRpZ2l0YWwgY3VycmVuY3lcbiAgICAgICAgICAgICAgICAnUHVibGljL1N0YXRpc3RpY0hpc3Rvcnkve0RpZ2lDdXJyZW5jeX0ve1R5cGVvZmRhdGF9JywgLy8gR2V0IHRoZSBoaXN0b3JpY2FsIGRhdGEgb2YgYSBzcGVjaWZpYyBkaWdpdGFsIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgJ1B1YmxpYy9UaWNrZXJIaXN0b3J5L3tDdXJyZW5jeVBhaXJ9L3tUaW1lZnJhbWV9JywgLy8gR2V0IHRpY2tlciBoaXN0b3J5XG4gICAgICAgICAgICAgICAgJ1B1YmxpYy9UcmFuc2FjdGlvbnMve0N1cnJlbmN5UGFpcn0nLCAvLyBHZXRzIHJlY2VudCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAnUHVibGljL1RyYW5zYWN0aW9uc0hpc3Rvcnkve0N1cnJlbmN5UGFpcn0nLCAvLyBHZXRzIGFsbCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAnUmVmZXJlbmNlL0J1c2luZXNzTmF0dXJlTGlzdCcsIC8vIEdldCB0aGUgYnVzaW5lc3MgbmF0dXJlIGxpc3QuXG4gICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9Db3VudHJpZXMnLCAvLyBHZXQgdGhlIGNvdW50cnkgbGlzdC5cbiAgICAgICAgICAgICAgICAnUmVmZXJlbmNlL0N1cnJlbmNpZXMnLCAvLyBHZXQgdGhlIGN1cnJlbmN5IGxpc3QuXG4gICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9DdXJyZW5jeVBhaXJzJywgLy8gR2V0IHRoZSBjdXJyZW5jeSBwYWlyIGxpc3QuXG4gICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9DdXJyZW50U3RhdHVzTGlzdCcsIC8vIEdldCB0aGUgY3VycmVudCBzdGF0dXMgbGlzdC5cbiAgICAgICAgICAgICAgICAnUmVmZXJlbmNlL0lkZW50eWRvY3VtZW50VHlwZXMnLCAvLyBHZXQgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBpZGVudGl0eSBkb2N1bWVudHMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgJ1JlZmVyZW5jZS9JbmNvbWVSYW5nZUxpc3QnLCAvLyBHZXQgdGhlIGluY29tZSByYW5nZSBsaXN0LlxuICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvSW5jb21lU291cmNlTGlzdCcsIC8vIEdldCB0aGUgaW5jb21lIHNvdXJjZSBsaXN0LlxuICAgICAgICAgICAgICAgICdSZWZlcmVuY2UvVmVyaWZpY2F0aW9uTGV2ZWxMaXN0JywgLy8gR2V0IHRoZSB2ZXJpZiBsZXZlbCBsaXN0LlxuICAgICAgICAgICAgICAgICdTdHJlYW0vUHVibGljQ2hhbm5lbCcsIC8vIEdldCB0aGUgcHVibGljIHB1Ym51YiBjaGFubmVsIGxpc3RcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnRXhwb3J0L1RyYW5zYWN0aW9ucycsIC8vIFJlcXVlc3QgYSBleHBvcnQgb2YgYWxsIHRyYWRlcyBmcm9tIGJhc2VkIG9uIGN1cnJlbmN5cGFpciwgc3RhcnQgZGF0ZSBhbmQgZW5kIGRhdGVcbiAgICAgICAgICAgICAgICAnUGluZycsIC8vIFBvc3QgYSBzdHJpbmcsIHRoZW4gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgJ1B1YmxpYy9VbnN1YnNjcmliZS97RW1haWxDb2RlfScsIC8vIExldHMgdGhlIHVzZXIgdW5zdWJzY3JpYmUgZnJvbSBlbWFpbHNcbiAgICAgICAgICAgICAgICAnUmVnaXN0ZXJVc2VyJywgLy8gSW5pdGlhbCB0cmFkZXIgcmVnaXN0cmF0aW9uLlxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdBY2NvdW50L0NvcnBvcmF0ZURhdGEnLCAvLyBHZXQgY29ycG9yYXRlIGFjY291bnQgZGF0YVxuICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50QWRkcmVzcycsIC8vIENoZWNrIGlmIHJlc2lkZW5jZSBwcm9vZiB1cGxvYWRlZFxuICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50Q29ycG9yYXRpb24nLCAvLyBDaGVjayBpZiByZWdpc3RlcmVkIGRvY3VtZW50IHVwbG9hZGVkXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJRCcsIC8vIENoZWNrIGlmIElEIGRvY3VtZW50IGNvcHkgdXBsb2FkZWRcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudEluZm9ybWF0aW9uJywgLy8gR2V0IFN0ZXAzIERhdGFcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbCcsIC8vIEdldCB1c2VyIGVtYWlsXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRmVlUmF0ZScsIC8vIEdldCBmZWUgcmF0ZSBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdBY2NvdW50L0xldmVsJywgLy8gR2V0IHZlcmlmIGxldmVsIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUGVyc29uYWxJbmZvcm1hdGlvbicsIC8vIEdldCBTdGVwMSBEYXRhXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUGhvbmUnLCAvLyBHZXQgdXNlciBwaG9uZSBudW1iZXJcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9Qcm9maWxlJywgLy8gR2V0IHRyYWRlciBwcm9maWxlXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIEZpbGwgdGhlIHF1ZXN0aW9ubmFpcmVcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbCcsIC8vIEdldCByZWZlcnJhbCBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmFsQ29kZScsIC8vIEdldCB0aGUgcmVmZXJyYWwgY29kZSBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbE5hbWVzJywgLy8gR2V0IG5hbWVzIG9mIHJlZmVycmVkIHRyYWRlcnNcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJhbFJld2FyZCcsIC8vIEdldCByZWZlcnJhbCByZXdhcmQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAnQWNjb3VudC9SZWZlcnJlZENvZGUnLCAvLyBHZXQgcmVmZXJyYWwgY29kZVxuICAgICAgICAgICAgICAgICdBY2NvdW50L1Jlc2lkZW50SW5mb3JtYXRpb24nLCAvLyBHZXQgU3RlcDIgRGF0YVxuICAgICAgICAgICAgICAgICdBY2NvdW50L1NlY3VyaXR5U2V0dGluZ3MnLCAvLyBHZXQgdmVyaWYgZGV0YWlscyBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdBY2NvdW50L1VzZXInLCAvLyBHZXQgYWxsIHVzZXIgaW5mb1xuICAgICAgICAgICAgICAgICdBUElLZXkvQVBJS2V5JywgLy8gR2V0IEFQSSBLZXkgZm9yIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0F1dGgvQ29ubmVjdGlvbkhpc3RvcnknLCAvLyBHZXRzIGNvbm5lY3Rpb24gaGlzdG9yeSBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdCYWxhbmNlL0JhbGFuY2VzJywgLy8gR2V0cyB0aGUgYXZhaWxhYmxlIGJhbGFuY2UgZm9yIGVhY2ggY3VycmVuY3kgZm9yIHRoZSBsb2dnZWQgaW4gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAnQmFsYW5jZS9CYWxhbmNlcy97Q3VycmVuY3l9JywgLy8gR2V0cyB0aGUgYXZhaWxhYmxlIGJhbGFuY2UgZm9yIHMgY3VycmVuY3kgZm9yIHRoZSBsb2dnZWQgaW4gYWNjb3VudC5cbiAgICAgICAgICAgICAgICAnQmFsYW5jZS9EZXBvc2l0cycsIC8vIEdldCBhbGwgYWNjb3VudCBkZXBvc2l0cywgaW5jbHVkaW5nIHdpcmUgYW5kIGRpZ2l0YWwgY3VycmVuY3ksIG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdCYWxhbmNlL1dpdGhkcmF3YWxzJywgLy8gR2V0IGFsbCBhY2NvdW50IHdpdGhkcmF3YWxzLCBpbmNsdWRpbmcgd2lyZSBhbmQgZGlnaXRhbCBjdXJyZW5jeSwgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0JhbmsvQWNjb3VudHMve0N1cnJlbmN5fS97TG9jYXRpb259JywgLy8gR2V0IGludGVybmFsIGJhbmsgYWNjb3VudCBmb3IgZGVwb3NpdFxuICAgICAgICAgICAgICAgICdCYW5rL1RyYW5zYWN0aW9ucycsIC8vIEdldCBhbGwgYWNjb3VudCB0cmFuc2FjdGlvbnMgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzJywgLy8gR2V0cyBhbGwgdGhlIGJhbmsgYWNjb3VudHMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzL3tDdXJyZW5jeX0nLCAvLyBHZXRzIGFsbCB0aGUgYmFuayBhY2NvdW50cyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cycsIC8vIEdldHMgYWxsIGNyeXB0byBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCBkZXBvc2l0cyB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvRGVwb3NpdFdhbGxldHMve0RpZ2lDdXJyZW5jeX0nLCAvLyBHZXRzIGFsbCBjcnlwdG8gY3VycmVuY3kgYWRkcmVzc2VzIHJlbGF0ZWQgZGVwb3NpdHMgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyIGJ5IGN1cnJlbmN5LlxuICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1RyYW5zYWN0aW9ucycsIC8vIEdldCBhbGwgZGlnaXRhbCBjdXJyZW5jeSB0cmFuc2FjdGlvbnMgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVHJhbnNhY3Rpb25zL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IGFsbCBkaWdpdGFsIGN1cnJlbmN5IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9Vc2VyV2FsbGV0cycsIC8vIEdldHMgYWxsIGV4dGVybmFsIGRpZ2l0YWwgY3VycmVuY3kgYWRkcmVzc2VzIHJlbGF0ZWQgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1VzZXJXYWxsZXRzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0cyBhbGwgZXh0ZXJuYWwgZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIgYnkgY3VycmVuY3kuXG4gICAgICAgICAgICAgICAgJ0luZm8vUmVmZXJlbmNlQ3VycmVuY3knLCAvLyBHZXQgdXNlcidzIHJlZmVyZW5jZSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICdJbmZvL1JlZmVyZW5jZUxhbmd1YWdlJywgLy8gR2V0IHVzZXIncyByZWZlcmVuY2UgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAnTm90aWZpY2F0aW9uL01lc3NhZ2VzJywgLy8gR2V0IGZyb20gb2xkZXN0IHVucmVhZCArIDMgcmVhZCBtZXNzYWdlIHRvIG5ld2VzdCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICdUcmFkZS9PcmRlcnMnLCAvLyBHZXRzIG9wZW4gb3JkZXJzIGZvciB0aGUgbG9nZ2VkIGluIHRyYWRlci5cbiAgICAgICAgICAgICAgICAnVHJhZGUvT3JkZXJzL3tPcmRlcklEfScsIC8vIEdldHMgYW4gb3JkZXIgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLlxuICAgICAgICAgICAgICAgICdUcmFkZS9TdG9wT3JkZXJzJywgLy8gR2V0cyBhbGwgc3RvcCBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLiBNYXggMTAwMCByZWNvcmQuXG4gICAgICAgICAgICAgICAgJ1RyYWRlL1N0b3BPcmRlcnNIaXN0b3J5JywgLy8gR2V0cyBhbGwgc3RvcCBvcmRlcnMgZm9yIHRoZSBsb2dnZWQgaW4gdHJhZGVyLiBNYXggMTAwMCByZWNvcmQuXG4gICAgICAgICAgICAgICAgJ1RyYWRlL1RyYWRlcycsIC8vIEdldHMgYWxsIHRyYW5zYWN0aW9ucyBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdUcmFkZS9Vc2VyVHJhZGVzJywgLy8gR2V0cyBhbGwgdHJhbnNhY3Rpb25zIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRBZGRyZXNzJywgLy8gVXBsb2FkIGFkZHJlc3MgcHJvb2YgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudENvcnBvcmF0aW9uJywgLy8gVXBsb2FkIHJlZ2lzdGVyZWQgZG9jdW1lbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9Eb2N1bWVudElEJywgLy8gVXBsb2FkIElEIGRvY3VtZW50IGNvcHlcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9FbWFpbC9SZXF1ZXN0VmVyaWZ5JywgLy8gUmVxdWVzdCBmb3IgdmVyaWZpY2F0aW9uIGVtYWlsXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRW1haWwvVmVyaWZ5JywgLy8gVmVyaWZpY2F0aW9uIGVtYWlsXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvR29vZ2xlQXV0aCcsIC8vIEVuYWJsZSBnb29nbGUgYXV0aFxuICAgICAgICAgICAgICAgICdBY2NvdW50L0xldmVsJywgLy8gUmVxdWVzdCB2ZXJpZiBsZXZlbCBvZiBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdBY2NvdW50L1F1ZXN0aW9ubmFpcmUnLCAvLyBGaWxsIHRoZSBxdWVzdGlvbm5haXJlXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUmVmZXJyYWwnLCAvLyBQb3N0IGEgcmVmZXJyYWwgZW1haWxcbiAgICAgICAgICAgICAgICAnQVBJS2V5L0FQSUtleScsIC8vIENyZWF0ZSBhIG5ldyBBUEkga2V5IGZvciBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdBdXRoL0NoYW5nZVBhc3N3b3JkJywgLy8gQ2hhbmdlIHBhc3N3b3JkLlxuICAgICAgICAgICAgICAgICdBdXRoL0ZvcmdvdFBhc3N3b3JkJywgLy8gUmVxdWVzdCByZXNldCBwYXNzd29yZFxuICAgICAgICAgICAgICAgICdBdXRoL0ZvcmdvdFVzZXJJRCcsIC8vIFJlcXVlc3QgdXNlciBpZFxuICAgICAgICAgICAgICAgICdBdXRoL0xvZ2luJywgLy8gVHJhZGVyIHNlc3Npb24gbG9nIGluLlxuICAgICAgICAgICAgICAgICdBdXRoL0xvZ291dCcsIC8vIExvZ291dCBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gICAgICAgICAgICAgICAgJ0F1dGgvTG9nb3V0T3RoZXJTZXNzaW9ucycsIC8vIExvZ291dCBvdGhlciBzZXNzaW9ucy5cbiAgICAgICAgICAgICAgICAnQXV0aC9SZXNldFBhc3N3b3JkJywgLy8gUmVzZXQgcGFzc3dvcmRcbiAgICAgICAgICAgICAgICAnQmFuay9UcmFuc2FjdGlvbnMnLCAvLyBSZXF1ZXN0IGEgdHJhbnNmZXIgZnJvbSB0aGUgdHJhZGVycyBhY2NvdW50IG9mIHRoZSBsb2dnZWQgaW4gdXNlci4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSBmb3IgYmFuayBhY2NvdW50XG4gICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzJywgLy8gQWRkIGFuIGFjY291bnQgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvRGVwb3NpdFdhbGxldHMve0RpZ2lDdXJyZW5jeX0nLCAvLyBBZGQgYW4gZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgdG8gdGhlIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L1RyYW5zYWN0aW9ucy9EZXBvc2l0cy97RGlnaUN1cnJlbmN5fScsIC8vIEdldCBhbGwgaW50ZXJuYWwgZGlnaXRhbCBjdXJyZW5jeSB0cmFuc2FjdGlvbnMgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVHJhbnNhY3Rpb25zL1dpdGhkcmF3YWxzL3tEaWdpQ3VycmVuY3l9JywgLy8gR2V0IGFsbCBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IHRyYW5zYWN0aW9ucyBvZiB0aGUgbG9nZ2VkIGluIHVzZXJcbiAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9Vc2VyV2FsbGV0cy97RGlnaUN1cnJlbmN5fScsIC8vIEFkZCBhbiBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvV2l0aGRyYXdhbHMve0RpZ2lDdXJyZW5jeX0nLCAvLyBSZXF1ZXN0IGEgdHJhbnNmZXIgZnJvbSB0aGUgdHJhZGVycyBhY2NvdW50IHRvIGFuIGV4dGVybmFsIGFkZHJlc3MuIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIGNyeXB0byBjdXJyZW5jaWVzLlxuICAgICAgICAgICAgICAgICdOb3RpZmljYXRpb24vTWVzc2FnZXMnLCAvLyBNYXJrIGFsbCBhcyByZWFkXG4gICAgICAgICAgICAgICAgJ05vdGlmaWNhdGlvbi9NZXNzYWdlcy97SUR9JywgLy8gTWFyayBhcyByZWFkXG4gICAgICAgICAgICAgICAgJ1RyYWRlL09yZGVycycsIC8vIFBsYWNlIGFuIG9yZGVyIGF0IHRoZSBleGNoYW5nZS5cbiAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVycycsIC8vIFBsYWNlIGEgc3RvcCBvcmRlciBhdCB0aGUgZXhjaGFuZ2UuXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAnQWNjb3VudC9Db3Jwb3JhdGVEYXRhJywgLy8gVXBkYXRlIHVzZXIgY29tcGFueSBkYXRhIGZvciBjb3Jwb3JhdGUgYWNjb3VudFxuICAgICAgICAgICAgICAgICdBY2NvdW50L0RvY3VtZW50SUQnLCAvLyBVcGRhdGUgSUQgZG9jdW1lbnQgbWV0YSBkYXRhXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRG9jdW1lbnRJbmZvcm1hdGlvbicsIC8vIFVwZGF0ZSBTdGVwMyBEYXRhXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvRW1haWwnLCAvLyBVcGRhdGUgdXNlciBlbWFpbFxuICAgICAgICAgICAgICAgICdBY2NvdW50L1BlcnNvbmFsSW5mb3JtYXRpb24nLCAvLyBVcGRhdGUgU3RlcDEgRGF0YVxuICAgICAgICAgICAgICAgICdBY2NvdW50L1Bob25lJywgLy8gVXBkYXRlIHVzZXIgcGhvbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUXVlc3Rpb25uYWlyZScsIC8vIHVwZGF0ZSB0aGUgcXVlc3Rpb25uYWlyZVxuICAgICAgICAgICAgICAgICdBY2NvdW50L1JlZmVycmVkQ29kZScsIC8vIFVwZGF0ZSByZWZlcnJhbCBjb2RlXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvUmVzaWRlbnRJbmZvcm1hdGlvbicsIC8vIFVwZGF0ZSBTdGVwMiBEYXRhXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvU2VjdXJpdHlTZXR0aW5ncycsIC8vIFVwZGF0ZSB2ZXJpZiBkZXRhaWxzIG9mIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0FjY291bnQvVXNlcicsIC8vIFVwZGF0ZSBhbGwgdXNlciBpbmZvXG4gICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzJywgLy8gVXBkYXRlIHRoZSBsYWJlbCBvZiBleGlzdGluZyB1c2VyIGJhbmsgYWNjb3VubnRcbiAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9EZXBvc2l0V2FsbGV0cy97RGlnaUN1cnJlbmN5fS97QWRkcmVzc05hbWV9JywgLy8gVXBkYXRlIHRoZSBuYW1lIG9mIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAnRWxlY3Ryb25pY1dhbGxldC9Vc2VyV2FsbGV0cy97RGlnaUN1cnJlbmN5fScsIC8vIFVwZGF0ZSB0aGUgbmFtZSBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAgICAgICAgJ0luZm8vUmVmZXJlbmNlQ3VycmVuY3knLCAvLyBVc2VyJ3MgcmVmZXJlbmNlIGN1cnJlbmN5XG4gICAgICAgICAgICAgICAgJ0luZm8vUmVmZXJlbmNlTGFuZ3VhZ2UnLCAvLyBVcGRhdGUgdXNlcidzIHJlZmVyZW5jZSBsYW5ndWFnZVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgJ0FQSUtleS9BUElLZXkve1B1YmxpY0tleX0nLCAvLyBSZW1vdmUgYW4gQVBJIGtleVxuICAgICAgICAgICAgICAgICdCYW5rL1RyYW5zYWN0aW9ucy97UmVxdWVzdElEfScsIC8vIERlbGV0ZSBwZW5kaW5nIGFjY291bnQgd2l0aGRyYXcgb2YgdGhlIGxvZ2dlZCBpbiB1c2VyXG4gICAgICAgICAgICAgICAgJ0JhbmsvVXNlckFjY291bnRzL3tDdXJyZW5jeX0ve0xhYmVsfScsIC8vIERlbGV0ZSBhbiBhY2NvdW50IG9mIHRoZSBsb2dnZWQgaW4gdXNlclxuICAgICAgICAgICAgICAgICdFbGVjdHJvbmljV2FsbGV0L0RlcG9zaXRXYWxsZXRzL3tEaWdpQ3VycmVuY3l9L3tBZGRyZXNzTmFtZX0nLCAvLyBEZWxldGUgYW4gZGlnaXRhbCBjdXJyZW5jeSBhZGRyZXNzZXMgcmVsYXRlZCB0byB0aGUgbG9nZ2VkIGluIHVzZXIuXG4gICAgICAgICAgICAgICAgJ0VsZWN0cm9uaWNXYWxsZXQvVXNlcldhbGxldHMve0RpZ2lDdXJyZW5jeX0ve0FkZHJlc3NOYW1lfScsIC8vIERlbGV0ZSBhbiBleHRlcm5hbCBkaWdpdGFsIGN1cnJlbmN5IGFkZHJlc3NlcyByZWxhdGVkIHRvIHRoZSBsb2dnZWQgaW4gdXNlci5cbiAgICAgICAgICAgICAgICAnVHJhZGUvT3JkZXJzJywgLy8gQ2FuY2VscyBhbGwgZXhpc3Rpbmcgb3JkZXJcbiAgICAgICAgICAgICAgICAnVHJhZGUvT3JkZXJzL3tPcmRlcklEfScsIC8vIENhbmNlbHMgYW4gZXhpc3Rpbmcgb3JkZXJcbiAgICAgICAgICAgICAgICAnVHJhZGUvU3RvcE9yZGVycycsIC8vIENhbmNlbHMgYWxsIGV4aXN0aW5nIHN0b3Agb3JkZXJzXG4gICAgICAgICAgICAgICAgJ1RyYWRlL1N0b3BPcmRlcnMve0lEfScsIC8vIENhbmNlbHMgYW4gZXhpc3Rpbmcgc3RvcCBvcmRlclxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VycyAoKTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSByZXNwb25zZVsndGlja2VycyddO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2N1cnJlbmN5UGFpciddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZUJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnYmFsYW5jZXMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogYmFsYW5jZVsnYXZhaWxhYmxlQmFsYW5jZSddLFxuICAgICAgICAgICAgICAgICd1c2VkJzogdGhpcy5zdW0gKFxuICAgICAgICAgICAgICAgICAgICBiYWxhbmNlWydwZW5kaW5nSW5jb21pbmcnXSxcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVsncGVuZGluZ091dGdvaW5nJ10sXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbJ29wZW5PcmRlciddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBiYWxhbmNlWydiYWxhbmNlJ10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNNYXJrZXREZXB0aEN1cnJlbmN5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAndm9sdW1lJyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnY3JlYXRlRGF0ZVRpbWUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHVibGljTGl2ZVRpY2tlcnMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gcmVzcG9uc2VbJ3RpY2tlcnMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpY2tlcnMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW3RdO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydjdXJyZW5jeVBhaXInXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJsaWNMaXZlVGlja2VyQ3VycmVuY3lQYWlyICh7XG4gICAgICAgICAgICAnQ3VycmVuY3lQYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG9yZGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ3dheScgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIHNpZGUgPSAodHJhZGVbJ3dheSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICAgICAgbGV0IG9yZGVySWQgPSB0cmFkZVsnd2F5J10gKyAnT3JkZXJJZCc7XG4gICAgICAgICAgICBvcmRlciA9IHRyYWRlW29yZGVySWRdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ3RyYW5zYWN0aW9uVGltZSddKSAqIDEwMDA7XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeVBhaXInXV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RyYW5zYWN0aW9uSWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFB1YmxpY1RyYW5zYWN0aW9uc0N1cnJlbmN5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdDdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYW5zYWN0aW9ucyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBhcnNlSW50IChvaGxjdlsnY3JlYXRlRGF0ZVRpbWUnXSkgKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbJ29wZW4nXSxcbiAgICAgICAgICAgIG9obGN2WydoaWdoJ10sXG4gICAgICAgICAgICBvaGxjdlsnbG93J10sXG4gICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICBvaGxjdlsndm9sdW1lJ10sXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ0N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdUaW1lZnJhbWUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnQ291bnQnXSA9IGxpbWl0O1xuICAgICAgICByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHVibGljVGlja2VySGlzdG9yeUN1cnJlbmN5UGFpclRpbWVmcmFtZSAocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChyZXNwb25zZVsndGlja2VycyddLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ0NvZGUnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICAgICAgJ1dheSc6IChzaWRlID09ICdidXknKSA/ICdCaWQnIDogJ0FzaycsXG4gICAgICAgICAgICAnQW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ1ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgaWYgKHRoaXMudHdvZmEpIHtcbiAgICAgICAgICAgIGlmICgnVmFsaWRhdGlvbkNvZGUnIGluIHBhcmFtcylcbiAgICAgICAgICAgICAgICBvcmRlclsnVmFsaWRhdGlvbkNvZGUnXSA9IHBhcmFtc1snVmFsaWRhdGlvbkNvZGUnXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgdHdvLWZhY3RvciBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIG1pc3NpbmcgVmFsaWRhdGlvbkNvZGUgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlT3JkZXJzICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydjbE9yZGVySWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVEZWxldGVUcmFkZU9yZGVyc09yZGVySUQgKHsgJ09yZGVySUQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRUeXBlID0gKG1ldGhvZCA9PSAnR0VUJykgPyAnJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGxldCBhdXRoID0gbWV0aG9kICsgdXJsICsgY29udGVudFR5cGUgKyBub25jZS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGF1dGggPSBhdXRoLnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQVBJX1BVQkxJQ19LRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQVBJX1JFUVVFU1RfU0lHTkFUVVJFJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICdBUElfUkVRVUVTVF9EQVRFJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1ldGhvZCAhPSAnR0VUJykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAodGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3BvbnNlU3RhdHVzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2VbJ3Jlc3BvbnNlU3RhdHVzJ10pXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydyZXNwb25zZVN0YXR1cyddWydtZXNzYWdlJ10gPT0gJ09LJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBnZGF4ID0ge1xuICAgICdpZCc6ICdnZGF4JyxcbiAgICAnbmFtZSc6ICdHREFYJyxcbiAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAnMW0nOiA2MCxcbiAgICAgICAgJzVtJzogMzAwLFxuICAgICAgICAnMTVtJzogOTAwLFxuICAgICAgICAnMzBtJzogMTgwMCxcbiAgICAgICAgJzFoJzogMzYwMCxcbiAgICAgICAgJzJoJzogNzIwMCxcbiAgICAgICAgJzRoJzogMTQ0MDAsXG4gICAgICAgICcxMmgnOiA0MzIwMCxcbiAgICAgICAgJzFkJzogODY0MDAsXG4gICAgICAgICcxdyc6IDYwNDgwMCxcbiAgICAgICAgJzFNJzogMjU5MjAwMCxcbiAgICAgICAgJzF5JzogMzE1MzYwMDAsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ3Rlc3QnOiAnaHR0cHM6Ly9hcGktcHVibGljLnNhbmRib3guZ2RheC5jb20nLFxuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTI3LWIxYmU0MWM2LTVlZGItMTFlNy05NWY2LTViNDk2YzQ2OWUyYy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmdkYXguY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5nZGF4LmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kb2NzLmdkYXguY29tJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdjdXJyZW5jaWVzJyxcbiAgICAgICAgICAgICAgICAncHJvZHVjdHMnLFxuICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L2Jvb2snLFxuICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L2NhbmRsZXMnLFxuICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L3N0YXRzJyxcbiAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICdwcm9kdWN0cy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ3RpbWUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdhY2NvdW50cycsXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICdhY2NvdW50cy97aWR9L2hvbGRzJyxcbiAgICAgICAgICAgICAgICAnYWNjb3VudHMve2lkfS9sZWRnZXInLFxuICAgICAgICAgICAgICAgICdjb2luYmFzZS1hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgJ2ZpbGxzJyxcbiAgICAgICAgICAgICAgICAnZnVuZGluZycsXG4gICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgJ29yZGVycy97aWR9JyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC1tZXRob2RzJyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICdyZXBvcnRzL3tpZH0nLFxuICAgICAgICAgICAgICAgICd1c2Vycy9zZWxmL3RyYWlsaW5nLXZvbHVtZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2RlcG9zaXRzL2NvaW5iYXNlLWFjY291bnQnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0cy9wYXltZW50LW1ldGhvZCcsXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmcvcmVwYXknLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdwb3NpdGlvbi9jbG9zZScsXG4gICAgICAgICAgICAgICAgJ3Byb2ZpbGVzL21hcmdpbi10cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgJ3JlcG9ydHMnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy9jb2luYmFzZScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL2NyeXB0bycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzL3BheW1lbnQtbWV0aG9kJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBtYXJrZXRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydiYXNlX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudHMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2hvbGQnXSksXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAobWFya2V0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnbGV2ZWwnOiAyLCAvLyAxIGJlc3QgYmlkYXNrLCAyIGFnZ3JlZ2F0ZWQsIDMgZnVsbFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkVGlja2VyICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcXVvdGUgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzSWRTdGF0cyAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0aWNrZXJbJ3RpbWUnXSk7XG4gICAgICAgIGxldCBiaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBhc2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnYmlkJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBiaWQgPSBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKTtcbiAgICAgICAgaWYgKCdhc2snIGluIHRpY2tlcilcbiAgICAgICAgICAgIGFzayA9IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAocXVvdGVbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAocXVvdGVbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBiaWQsXG4gICAgICAgICAgICAnYXNrJzogYXNrLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHF1b3RlWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0IChxdW90ZVsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAoWyd0aW1lJ10pO1xuICAgICAgICBsZXQgdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0cmFkZV9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydzaXplJ10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAobWFya2V0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSwgLy8gZml4ZXMgaXNzdWUgIzJcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIHBhcnNlT0hMQ1YgKG9obGN2LCBtYXJrZXQgPSB1bmRlZmluZWQsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0gKiAxMDAwLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdlsyXSxcbiAgICAgICAgICAgIG9obGN2WzFdLFxuICAgICAgICAgICAgb2hsY3ZbNF0sXG4gICAgICAgICAgICBvaGxjdls1XSxcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGdyYW51bGFyaXR5ID0gdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV07XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ2dyYW51bGFyaXR5JzogZ3JhbnVsYXJpdHksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaW5jZSkge1xuICAgICAgICAgICAgcmVxdWVzdFsnc3RhcnQnXSA9IHRoaXMuaXNvODYwMSAoc2luY2UpO1xuICAgICAgICAgICAgaWYgKCFsaW1pdClcbiAgICAgICAgICAgICAgICBsaW1pdCA9IDIwMDsgLy8gbWF4ID0gMjAwXG4gICAgICAgICAgICByZXF1ZXN0WydlbmQnXSA9IHRoaXMuaXNvODYwMSAobGltaXQgKiBncmFudWxhcml0eSAqIDEwMDAgKyBzaW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0c0lkQ2FuZGxlcyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpbWUgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnB1YmxpY0dldFRpbWUgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlODYwMSAocmVzcG9uc2VbJ2lzbyddKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9pZCA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwcm9kdWN0X2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdzaXplJzogYW1vdW50LFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVycyAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVEZWxldGVPcmRlcnNJZCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZ2V0UGF5bWVudE1ldGhvZHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRQYXltZW50TWV0aG9kcyAoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCdwYXltZW50X21ldGhvZF9pZCcgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAgICAgLy8gJ2FkZHJlc3MnOiBhZGRyZXNzLCAvLyB0aGV5IGRvbid0IGFsbG93IHdpdGhkcmF3YWxzIHRvIGRpcmVjdCBhZGRyZXNzZXNcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyBcIiB3aXRoZHJhdyByZXF1aXJlcyBhICdwYXltZW50X21ldGhvZF9pZCcgcGFyYW1ldGVyXCIpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHJlcXVlc3Q7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFwaUtleSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYXBpS2V5IHByb3BlcnR5IGZvciBhdXRoZW50aWNhdGlvbiBhbmQgdHJhZGluZycpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNlY3JldClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgc2VjcmV0IHByb3BlcnR5IGZvciBhdXRoZW50aWNhdGlvbiBhbmQgdHJhZGluZycpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhc3N3b3JkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBwYXNzd29yZCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24gYW5kIHRyYWRpbmcnKTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHdoYXQgPSBub25jZSArIG1ldGhvZCArIHJlcXVlc3QgKyAoYm9keSB8fCAnJyk7XG4gICAgICAgICAgICBsZXQgc2VjcmV0ID0gdGhpcy5iYXNlNjRUb0JpbmFyeSAodGhpcy5zZWNyZXQpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHdoYXQpLCBzZWNyZXQsICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDQi1BQ0NFU1MtS0VZJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0NCLUFDQ0VTUy1TSUdOJzogdGhpcy5kZWNvZGUgKHNpZ25hdHVyZSksXG4gICAgICAgICAgICAgICAgJ0NCLUFDQ0VTUy1USU1FU1RBTVAnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQ0ItQUNDRVNTLVBBU1NQSFJBU0UnOiB0aGlzLnBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZ2VtaW5pID0ge1xuICAgICdpZCc6ICdnZW1pbmknLFxuICAgICduYW1lJzogJ0dlbWluaScsXG4gICAgJ2NvdW50cmllcyc6ICdVUycsXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsIC8vIDIwMCBmb3IgcHJpdmF0ZSBBUElcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzgxNjg1Ny1jZTdiZTY0NC02MDk2LTExZTctODJkNi0zYzI1NzI2MzIyOWMuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5nZW1pbmkuY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2dlbWluaS5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vZG9jcy5nZW1pbmkuY29tL3Jlc3QtYXBpJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdzeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAncHVidGlja2VyL3tzeW1ib2x9JyxcbiAgICAgICAgICAgICAgICAnYm9vay97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ2F1Y3Rpb24ve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICdhdWN0aW9uL3tzeW1ib2x9L2hpc3RvcnknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXIvbmV3JyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvY2FuY2VsL3Nlc3Npb24nLFxuICAgICAgICAgICAgICAgICdvcmRlci9jYW5jZWwvYWxsJyxcbiAgICAgICAgICAgICAgICAnb3JkZXIvc3RhdHVzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICd0cmFkZXZvbHVtZScsXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdC97Y3VycmVuY3l9L25ld0FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdy97Y3VycmVuY3l9JyxcbiAgICAgICAgICAgICAgICAnaGVhcnRiZWF0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0c1twXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBpZDtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBtYXJrZXQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHVwcGVyY2FzZS5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSB1cHBlcmNhc2Uuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAobWFya2V0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCb29rU3ltYm9sICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB1bmRlZmluZWQsICdiaWRzJywgJ2Fza3MnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQdWJ0aWNrZXJTeW1ib2wgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd2b2x1bWUnXVsndGltZXN0YW1wJ107XG4gICAgICAgIGxldCBiYXNlVm9sdW1lID0gbWFya2V0WydiYXNlJ107XG4gICAgICAgIGxldCBxdW90ZVZvbHVtZSA9IG1hcmtldFsncXVvdGUnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsb3cnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXVtiYXNlVm9sdW1lXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddW3F1b3RlVm9sdW1lXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcG1zJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydhdmFpbGFibGUnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsnYW1vdW50J10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NsaWVudF9vcmRlcl9pZCc6IHRoaXMubm9uY2UgKCksXG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICd0eXBlJzogJ2V4Y2hhbmdlIGxpbWl0JywgLy8gZ2VtaW5pIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seVxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJOZXcgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ29yZGVyX2lkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAncmVxdWVzdCc6IHVybCxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gdGhpcy5qc29uIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLnN0cmluZ1RvQmFzZTY0ICh0aGlzLmVuY29kZSAocGF5bG9hZCkpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAocGF5bG9hZCwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTM4NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgICAgICdYLUdFTUlOSS1BUElLRVknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnWC1HRU1JTkktUEFZTE9BRCc6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgJ1gtR0VNSU5JLVNJR05BVFVSRSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3Jlc3VsdCddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBoaXRidGMgPSB7XG5cbiAgICAnaWQnOiAnaGl0YnRjJyxcbiAgICAnbmFtZSc6ICdIaXRCVEMnLFxuICAgICdjb3VudHJpZXMnOiAnSEsnLCAvLyBIb25nIEtvbmdcbiAgICAncmF0ZUxpbWl0JzogMTUwMCxcbiAgICAndmVyc2lvbic6ICcxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTU1LThlYWVjMjBlLTVlZGMtMTFlNy05YzViLTZkYzY5ZmM0MmY1ZS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHA6Ly9hcGkuaGl0YnRjLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9oaXRidGMuY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL2hpdGJ0Yy5jb20vYXBpJyxcbiAgICAgICAgICAgICdodHRwOi8vaGl0YnRjLWNvbS5naXRodWIuaW8vaGl0YnRjLWFwaScsXG4gICAgICAgICAgICAnaHR0cDovL2pzZmlkZGxlLm5ldC9ibWtuaWdodC9ScWJZQicsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne3N5bWJvbH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAne3N5bWJvbH0vdGlja2VyJyxcbiAgICAgICAgICAgICAgICAne3N5bWJvbH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAne3N5bWJvbH0vdHJhZGVzL3JlY2VudCcsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbHMnLFxuICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICd0aW1lLCdcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICd0cmFkaW5nJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ29yZGVycy9hY3RpdmUnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvcmVjZW50JyxcbiAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICd0cmFkZXMvYnkvb3JkZXInLFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICduZXdfb3JkZXInLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXJzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwYXltZW50Jzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2FkZHJlc3Mve2N1cnJlbmN5fScsXG4gICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb259JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAndHJhbnNmZXJfdG9fdHJhZGluZycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVyX3RvX21haW4nLFxuICAgICAgICAgICAgICAgICdhZGRyZXNzL3tjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICdwYXlvdXQnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9scyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ3N5bWJvbHMnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3N5bWJvbHMnXVtwXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnY29tbW9kaXR5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbG90ID0gcGFyc2VGbG9hdCAobWFya2V0Wydsb3QnXSk7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IHBhcnNlRmxvYXQgKG1hcmtldFsnc3RlcCddKTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdzdGVwJzogc3RlcCxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy50cmFkaW5nR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBiYWxhbmNlWydjdXJyZW5jeV9jb2RlJ107XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY29kZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Nhc2gnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiBwYXJzZUZsb2F0IChiYWxhbmNlWydyZXNlcnZlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRTeW1ib2xPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydiaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogcGFyc2VGbG9hdCAodGlja2VyWydvcGVuJ10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV9xdW90ZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFN5bWJvbFRpY2tlciAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gdGlja2VyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aWNrZXJbJ21lc3NhZ2UnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVswXSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVszXSxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodHJhZGVbM10pLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbNF0sXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsxXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbMl0pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sVHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgIC8vICdmcm9tJzogMCxcbiAgICAgICAgICAgIC8vICd0aWxsJzogMTAwLFxuICAgICAgICAgICAgLy8gJ2J5JzogJ3RzJywgLy8gb3IgYnkgdHJhZGVfaWRcbiAgICAgICAgICAgIC8vICdzb3J0JzogJ2Rlc2MnLCAvLyBvciBhc2NcbiAgICAgICAgICAgIC8vICdzdGFydF9pbmRleCc6IDAsXG4gICAgICAgICAgICAvLyAnbWF4X3Jlc3VsdHMnOiAxMDAwLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF9pdGVtJzogJ29iamVjdCcsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X3ByaWNlJzogJ251bWJlcicsXG4gICAgICAgICAgICAvLyAnZm9ybWF0X2Ftb3VudCc6ICdudW1iZXInLFxuICAgICAgICAgICAgLy8gJ2Zvcm1hdF90aWQnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfdGltZXN0YW1wJzogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIC8vICdmb3JtYXRfd3JhcCc6IGZhbHNlLFxuICAgICAgICAgICAgJ3NpZGUnOiAndHJ1ZScsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIC8vIGNoZWNrIGlmIGFtb3VudCBjYW4gYmUgZXZlbmx5IGRpdmlkZWQgaW50byBsb3RzXG4gICAgICAgIC8vIHRoZXkgd2FudCBpbnRlZ2VyIHF1YW50aXR5IGluIGxvdCB1bml0c1xuICAgICAgICBsZXQgcXVhbnRpdHkgPSBwYXJzZUZsb2F0IChhbW91bnQpIC8gbWFya2V0Wydsb3QnXTtcbiAgICAgICAgbGV0IHdob2xlTG90cyA9IE1hdGgucm91bmQgKHF1YW50aXR5KTtcbiAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSBxdWFudGl0eSAtIHdob2xlTG90cztcbiAgICAgICAgaWYgKE1hdGguYWJzIChkaWZmZXJlbmNlKSA+IG1hcmtldFsnc3RlcCddKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIG9yZGVyIGFtb3VudCBzaG91bGQgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSBsb3QgdW5pdCBzaXplIG9mICcgKyBtYXJrZXRbJ2xvdCddLnRvU3RyaW5nICgpKTtcbiAgICAgICAgbGV0IGNsaWVudE9yZGVySWQgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NsaWVudE9yZGVySWQnOiBjbGllbnRPcmRlcklkLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdxdWFudGl0eSc6IHdob2xlTG90cy50b1N0cmluZyAoKSwgLy8gcXVhbnRpdHkgaW4gaW50ZWdlciBsb3QgdW5pdHNcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2UudG9GaXhlZCAoMTApO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYWRpbmdQb3N0TmV3T3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ0V4ZWN1dGlvblJlcG9ydCddWydjbGllbnRPcmRlcklkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhZGluZ1Bvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wYXltZW50UG9zdFBheW91dCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeV9jb2RlJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsndHJhbnNhY3Rpb24nXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgJ2FwaScgKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBhcGkgKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHsgJ25vbmNlJzogbm9uY2UsICdhcGlrZXknOiB0aGlzLmFwaUtleSB9LCBxdWVyeSk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJylcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHVybCArIChib2R5IHx8ICcnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdYLVNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJykudG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKCdFeGVjdXRpb25SZXBvcnQnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlWydFeGVjdXRpb25SZXBvcnQnXVsnb3JkZXJSZWplY3RSZWFzb24nXSA9PSAnb3JkZXJFeGNlZWRzTGltaXQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5zdWZmaWNpZW50RnVuZHMgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgaGl0YnRjMiA9IGV4dGVuZCAoaGl0YnRjLCB7XG5cbiAgICAnaWQnOiAnaGl0YnRjMicsXG4gICAgJ25hbWUnOiAnSGl0QlRDIHYyJyxcbiAgICAnY291bnRyaWVzJzogJ0hLJywgLy8gSG9uZyBLb25nXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ3ZlcnNpb24nOiAnMicsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2NTU1LThlYWVjMjBlLTVlZGMtMTFlNy05YzViLTZkYzY5ZmM0MmY1ZS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmhpdGJ0Yy5jb20nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vaGl0YnRjLmNvbScsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9hcGkuaGl0YnRjLmNvbS9hcGkvMi9leHBsb3JlJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vaGl0YnRjLWNvbS9oaXRidGMtYXBpL2Jsb2IvbWFzdGVyL0FQSXYyLm1kJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdzeW1ib2wnLCAvLyBBdmFpbGFibGUgQ3VycmVuY3kgU3ltYm9sc1xuICAgICAgICAgICAgICAgICdzeW1ib2wve3N5bWJvbH0nLCAvLyBHZXQgc3ltYm9sIGluZm9cbiAgICAgICAgICAgICAgICAnY3VycmVuY3knLCAvLyBBdmFpbGFibGUgQ3VycmVuY2llc1xuICAgICAgICAgICAgICAgICdjdXJyZW5jeS97Y3VycmVuY3l9JywgLy8gR2V0IGN1cnJlbmN5IGluZm9cbiAgICAgICAgICAgICAgICAndGlja2VyJywgLy8gVGlja2VyIGxpc3QgZm9yIGFsbCBzeW1ib2xzXG4gICAgICAgICAgICAgICAgJ3RpY2tlci97c3ltYm9sfScsIC8vIFRpY2tlciBmb3Igc3ltYm9sXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97c3ltYm9sfScsIC8vIFRyYWRlc1xuICAgICAgICAgICAgICAgICdvcmRlcmJvb2sve3N5bWJvbH0nLCAvLyBPcmRlcmJvb2tcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXInLCAvLyBMaXN0IHlvdXIgY3VycmVudCBvcGVuIG9yZGVyc1xuICAgICAgICAgICAgICAgICdvcmRlci97Y2xpZW50T3JkZXJJZH0nLCAvLyBHZXQgYSBzaW5nbGUgb3JkZXIgYnkgY2xpZW50T3JkZXJJZFxuICAgICAgICAgICAgICAgICd0cmFkaW5nL2JhbGFuY2UnLCAvLyBHZXQgdHJhZGluZyBiYWxhbmNlXG4gICAgICAgICAgICAgICAgJ3RyYWRpbmcvZmVlL3tzeW1ib2x9JywgLy8gR2V0IHRyYWRpbmcgZmVlIHJhdGVcbiAgICAgICAgICAgICAgICAnaGlzdG9yeS90cmFkZXMnLCAvLyBHZXQgaGlzdG9yaWNhbCB0cmFkZXNcbiAgICAgICAgICAgICAgICAnaGlzdG9yeS9vcmRlcicsIC8vIEdldCBoaXN0b3JpY2FsIG9yZGVyc1xuICAgICAgICAgICAgICAgICdoaXN0b3J5L29yZGVyL3tpZH0vdHJhZGVzJywgLy8gR2V0IGhpc3RvcmljYWwgdHJhZGVzIGJ5IHNwZWNpZmllZCBvcmRlclxuICAgICAgICAgICAgICAgICdhY2NvdW50L2JhbGFuY2UnLCAvLyBHZXQgbWFpbiBhY2Njb3VudCBiYWxhbmNlXG4gICAgICAgICAgICAgICAgJ2FjY291bnQvdHJhbnNhY3Rpb25zJywgLy8gR2V0IGFjY291bnQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgJ2FjY291bnQvdHJhbnNhY3Rpb25zL3tpZH0nLCAvLyBHZXQgYWNjb3VudCB0cmFuc2FjdGlvbiBieSBpZFxuICAgICAgICAgICAgICAgICdhY2NvdW50L2NyeXB0by9hZGRyZXNzL3tjdXJyZW5jeX0nLCAvLyBHZXQgZGVwb3NpdCBjcnlwcm8gYWRkcmVzc1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIENyZWF0ZSBuZXcgb3JkZXJcbiAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcnLCAvLyBXaXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vYWRkcmVzcy97Y3VycmVuY3l9JywgLy8gQ3JlYXRlIG5ldyBkZXBvc2l0IGNyeXBybyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgJ2FjY291bnQvdHJhbnNmZXInLCAvLyBUcmFuc2ZlciBhbW91bnQgdG8gdHJhZGluZ1xuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwdXQnOiBbXG4gICAgICAgICAgICAgICAgJ29yZGVyL3tjbGllbnRPcmRlcklkfScsIC8vIENyZWF0ZSBuZXcgb3JkZXJcbiAgICAgICAgICAgICAgICAnYWNjb3VudC9jcnlwdG8vd2l0aGRyYXcve2lkfScsIC8vIENvbW1pdCB3aXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICdvcmRlcicsIC8vIENhbmNlbCBhbGwgb3BlbiBvcmRlcnNcbiAgICAgICAgICAgICAgICAnb3JkZXIve2NsaWVudE9yZGVySWR9JywgLy8gQ2FuY2VsIG9yZGVyXG4gICAgICAgICAgICAgICAgJ2FjY291bnQvY3J5cHRvL3dpdGhkcmF3L3tpZH0nLCAvLyBSb2xsYmFjayB3aXRoZHJhdyBjcnlwcm9cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncGF0Y2gnOiBbXG4gICAgICAgICAgICAgICAgJ29yZGVyL3tjbGllbnRPcmRlcklkfScsIC8vIENhbmNlbCBSZXBsYWNlIG9yZGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0U3ltYm9sICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnYmFzZUN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlQ3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBsb3QgPSBtYXJrZXRbJ3F1YW50aXR5SW5jcmVtZW50J107XG4gICAgICAgICAgICBsZXQgc3RlcCA9IG1hcmtldFsndGlja1NpemUnXTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnbG90JzogbG90LFxuICAgICAgICAgICAgICAgICdzdGVwJzogc3RlcCxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldFRyYWRpbmdCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY29kZSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY29kZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3Jlc2VydmVkJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyYm9va1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkJywgJ2FzaycsICdwcmljZScsICdzaXplJyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsndGltZXN0YW1wJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnb3BlbicpLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2Nsb3NlJyksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3F1b3RlVm9sdW1lJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2ldO1xuICAgICAgICAgICAgbGV0IGlkID0gdGlja2VyWydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyU3ltYm9sICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRpY2tlclsnbWVzc2FnZSddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRyYWRlWyd0aW1lc3RhbXAnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsncXVhbnRpdHknXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNTeW1ib2wgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBjbGllbnRPcmRlcklkID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGFtb3VudCA9IHBhcnNlRmxvYXQgKGFtb3VudCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogY2xpZW50T3JkZXJJZC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgIHByaWNlID0gcGFyc2VGbG9hdCAocHJpY2UpO1xuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZS50b0ZpeGVkICgxMCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydjbGllbnRPcmRlcklkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZURlbGV0ZU9yZGVyQ2xpZW50T3JkZXJJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjbGllbnRPcmRlcklkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgYW1vdW50ID0gcGFyc2VGbG9hdCAoYW1vdW50KTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEFjY291bnRDcnlwdG9XaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IGN1cnJlbmN5LFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudC50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9ICcvYXBpJyArICcvJyArIHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gYXBpICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsICs9IHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBpZiAobWV0aG9kICE9ICdHRVQnKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHBheWxvYWQgPSB0aGlzLmVuY29kZSAodGhpcy5hcGlLZXkgKyAnOicgKyB0aGlzLnNlY3JldCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuc3RyaW5nVG9CYXNlNjQgKHBheWxvYWQpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IFwiQmFzaWMgXCIgKyB0aGlzLmRlY29kZSAoYXV0aCksXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGh1b2JpMSA9IHtcblxuICAgICdpZCc6ICdodW9iaTEnLFxuICAgICduYW1lJzogJ0h1b2JpIHYxJyxcbiAgICAnY291bnRyaWVzJzogJ0NOJyxcbiAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAndmVyc2lvbic6ICd2MScsXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICdhY2NvdW50cyc6IHVuZGVmaW5lZCxcbiAgICAnYWNjb3VudHNCeUlkJzogdW5kZWZpbmVkLFxuICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAnMW0nOiAnMW1pbicsXG4gICAgICAgICc1bSc6ICc1bWluJyxcbiAgICAgICAgJzE1bSc6ICcxNW1pbicsXG4gICAgICAgICczMG0nOiAnMzBtaW4nLFxuICAgICAgICAnMWgnOiAnNjBtaW4nLFxuICAgICAgICAnMWQnOiAnMWRheScsXG4gICAgICAgICcxdyc6ICcxd2VlaycsXG4gICAgICAgICcxTSc6ICcxbW9uJyxcbiAgICAgICAgJzF5JzogJzF5ZWFyJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdtYXJrZXQnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdoaXN0b3J5L2tsaW5lJywgLy8g6I635Y+WS+e6v+aVsOaNrlxuICAgICAgICAgICAgICAgICdkZXRhaWwvbWVyZ2VkJywgLy8g6I635Y+W6IGa5ZCI6KGM5oOFKFRpY2tlcilcbiAgICAgICAgICAgICAgICAnZGVwdGgnLCAvLyDojrflj5YgTWFya2V0IERlcHRoIOaVsOaNrlxuICAgICAgICAgICAgICAgICd0cmFkZScsIC8vIOiOt+WPliBUcmFkZSBEZXRhaWwg5pWw5o2uXG4gICAgICAgICAgICAgICAgJ2hpc3RvcnkvdHJhZGUnLCAvLyDmibnph4/ojrflj5bmnIDov5HnmoTkuqTmmJPorrDlvZVcbiAgICAgICAgICAgICAgICAnZGV0YWlsJywgLy8g6I635Y+WIE1hcmtldCBEZXRhaWwgMjTlsI/ml7bmiJDkuqTph4/mlbDmja5cbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdjb21tb24vc3ltYm9scycsIC8vIOafpeivouezu+e7n+aUr+aMgeeahOaJgOacieS6pOaYk+WvuVxuICAgICAgICAgICAgICAgICdjb21tb24vY3VycmVuY3lzJywgLy8g5p+l6K+i57O757uf5pSv5oyB55qE5omA5pyJ5biB56eNXG4gICAgICAgICAgICAgICAgJ2NvbW1vbi90aW1lc3RhbXAnLCAvLyDmn6Xor6Lns7vnu5/lvZPliY3ml7bpl7RcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYWNjb3VudC9hY2NvdW50cycsIC8vIOafpeivouW9k+WJjeeUqOaIt+eahOaJgOaciei0puaItyjljbNhY2NvdW50LWlkKVxuICAgICAgICAgICAgICAgICdhY2NvdW50L2FjY291bnRzL3tpZH0vYmFsYW5jZScsIC8vIOafpeivouaMh+Wumui0puaIt+eahOS9meminVxuICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMve2lkfScsIC8vIOafpeivouafkOS4quiuouWNleivpuaDhVxuICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMve2lkfS9tYXRjaHJlc3VsdHMnLCAvLyDmn6Xor6Lmn5DkuKrorqLljZXnmoTmiJDkuqTmmI7nu4ZcbiAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzJywgLy8g5p+l6K+i5b2T5YmN5aeU5omY44CB5Y6G5Y+y5aeU5omYXG4gICAgICAgICAgICAgICAgJ29yZGVyL21hdGNocmVzdWx0cycsIC8vIOafpeivouW9k+WJjeaIkOS6pOOAgeWOhuWPsuaIkOS6pFxuICAgICAgICAgICAgICAgICdkdy93aXRoZHJhdy12aXJ0dWFsL2FkZHJlc3NlcycsIC8vIOafpeivouiZmuaLn+W4geaPkOeOsOWcsOWdgFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMvcGxhY2UnLCAvLyDliJvlu7rlubbmiafooYzkuIDkuKrmlrDorqLljZUgKOS4gOatpeS4i+WNle+8jCDmjqjojZDkvb/nlKgpXG4gICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycycsIC8vIOWIm+W7uuS4gOS4quaWsOeahOiuouWNleivt+axgiDvvIjku4XliJvlu7rorqLljZXvvIzkuI3miafooYzkuIvljZXvvIlcbiAgICAgICAgICAgICAgICAnb3JkZXIvb3JkZXJzL3tpZH0vcGxhY2UnLCAvLyDmiafooYzkuIDkuKrorqLljZUg77yI5LuF5omn6KGM5bey5Yib5bu655qE6K6i5Y2V77yJXG4gICAgICAgICAgICAgICAgJ29yZGVyL29yZGVycy97aWR9L3N1Ym1pdGNhbmNlbCcsIC8vIOeUs+ivt+aSpOmUgOS4gOS4quiuouWNleivt+axglxuICAgICAgICAgICAgICAgICdvcmRlci9vcmRlcnMvYmF0Y2hjYW5jZWwnLCAvLyDmibnph4/mkqTplIDorqLljZVcbiAgICAgICAgICAgICAgICAnZHcvYmFsYW5jZS90cmFuc2ZlcicsIC8vIOi1hOS6p+WIkui9rFxuICAgICAgICAgICAgICAgICdkdy93aXRoZHJhdy12aXJ0dWFsL2NyZWF0ZScsIC8vIOeUs+ivt+aPkOeOsOiZmuaLn+W4gVxuICAgICAgICAgICAgICAgICdkdy93aXRoZHJhdy12aXJ0dWFsL3tpZH0vcGxhY2UnLCAvLyDnoa7orqTnlLPor7fomZrmi5/luIHmj5DnjrBcbiAgICAgICAgICAgICAgICAnZHcvd2l0aGRyYXctdmlydHVhbC97aWR9L2NhbmNlbCcsIC8vIOeUs+ivt+WPlua2iOaPkOeOsOiZmuaLn+W4gVxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRDb21tb25TeW1ib2xzICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgICAgIGxldCBudW1NYXJrZXRzID0gbWFya2V0cy5sZW5ndGg7XG4gICAgICAgIGlmIChudW1NYXJrZXRzIDwgMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBwdWJsaWNHZXRDb21tb25TeW1ib2xzIHJldHVybmVkIGVtcHR5IHJlc3BvbnNlOiAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbaV07XG4gICAgICAgICAgICBsZXQgYmFzZUlkID0gbWFya2V0WydiYXNlLWN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGVJZCA9IG1hcmtldFsncXVvdGUtY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gYmFzZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gcXVvdGVJZC50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBpZCA9IGJhc2VJZCArIHF1b3RlSWQ7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnbGFzdCcgaW4gdGlja2VyKVxuICAgICAgICAgICAgbGFzdCA9IHRpY2tlclsnbGFzdCddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIGlmICgndHMnIGluIHRpY2tlcilcbiAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpY2tlclsndHMnXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRpY2tlclsnaGlnaCddLFxuICAgICAgICAgICAgJ2xvdyc6IHRpY2tlclsnbG93J10sXG4gICAgICAgICAgICAnYmlkJzogdGlja2VyWydiaWQnXVswXSxcbiAgICAgICAgICAgICdhc2snOiB0aWNrZXJbJ2FzayddWzBdLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHRpY2tlclsnb3BlbiddLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdGlja2VyWydjbG9zZSddLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBsYXN0LFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYW1vdW50J10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGlja2VyWyd2b2wnXSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFya2V0R2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiAnc3RlcDAnLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKHJlc3BvbnNlWyd0aWNrJ10sIHJlc3BvbnNlWyd0aWNrJ11bJ3RzJ10pO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXREZXRhaWxNZXJnZWQgKHsgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHJlc3BvbnNlWyd0aWNrJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0cyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydkaXJlY3Rpb24nXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZXNEYXRhIChkYXRhLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFkZXMgPSB0aGlzLnBhcnNlVHJhZGVzIChkYXRhW2ldWydkYXRhJ10sIG1hcmtldCk7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRyYWRlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0cmFkZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYXJrZXRHZXRIaXN0b3J5VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3NpemUnOiAyMDAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXNEYXRhIChyZXNwb25zZVsnZGF0YSddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WydpZCddICogMTAwMCxcbiAgICAgICAgICAgIG9obGN2WydvcGVuJ10sXG4gICAgICAgICAgICBvaGxjdlsnaGlnaCddLFxuICAgICAgICAgICAgb2hsY3ZbJ2xvdyddLFxuICAgICAgICAgICAgb2hsY3ZbJ2Nsb3NlJ10sXG4gICAgICAgICAgICBvaGxjdlsndm9sJ10sXG4gICAgICAgIF07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT0hMQ1YgKHN5bWJvbCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMubWFya2V0R2V0SGlzdG9yeUtsaW5lICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2QnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgICAgICdzaXplJzogMjAwMCwgLy8gbWF4ID0gMjAwMFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPSExDVnMgKHJlc3BvbnNlWydkYXRhJ10sIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBsb2FkQWNjb3VudHMgKHJlbG9hZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChyZWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudHMgPSBhd2FpdCB0aGlzLmZldGNoQWNjb3VudHMgKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY2NvdW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY291bnRzID0gYXdhaXQgdGhpcy5mZXRjaEFjY291bnRzICgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjb3VudHNCeUlkID0gdGhpcy5pbmRleEJ5ICh0aGlzLmFjY291bnRzLCAnaWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hBY2NvdW50cyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRBY2NvdW50cyAoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydkYXRhJ107XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkQWNjb3VudHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEFjY291bnRBY2NvdW50c0lkQmFsYW5jZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IHRoaXMuYWNjb3VudHNbMF1bJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsnZGF0YSddWydsaXN0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYWxhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tpXTtcbiAgICAgICAgICAgIGxldCB1cHBlcmNhc2UgPSBiYWxhbmNlWydjdXJyZW5jeSddLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHVwcGVyY2FzZSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEFjY291bnRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdhY2NvdW50LWlkJzogdGhpcy5hY2NvdW50c1swXVsnaWQnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQudG9GaXhlZCAoMTApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSArICctJyArIHR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlLnRvRml4ZWQgKDEwKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdE9yZGVyT3JkZXJzUGxhY2UgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2RhdGEnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0T3JkZXJPcmRlcnNJZFN1Ym1pdGNhbmNlbCAoeyAnaWQnOiBpZCB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdXJsICs9IGFwaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgdXJsICs9ICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpO1xuICAgICAgICBpZiAoYXBpID09ICdwcml2YXRlJykge1xuICAgICAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMuWW1kSE1TICh0aGlzLm1pbGxpc2Vjb25kcyAoKSwgJ1QnKTtcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdTaWduYXR1cmVNZXRob2QnOiAnSG1hY1NIQTI1NicsXG4gICAgICAgICAgICAgICAgJ1NpZ25hdHVyZVZlcnNpb24nOiAnMicsXG4gICAgICAgICAgICAgICAgJ0FjY2Vzc0tleUlkJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMudXJsZW5jb2RlIChyZXF1ZXN0KTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkID0gWyBtZXRob2QsIHRoaXMuaG9zdG5hbWUsIHVybCwgYXV0aCBdLmpvaW4gKFwiXFxuXCIpO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHBheWxvYWQpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhMjU2JywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgYXV0aCArPSAnJicgKyB0aGlzLnVybGVuY29kZSAoeyAnU2lnbmF0dXJlJzogc2lnbmF0dXJlIH0pO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBhdXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBodW9iaWNueSA9IGV4dGVuZCAoaHVvYmkxLCB7XG5cbiAgICAnaWQnOiAnaHVvYmljbnknLFxuICAgICduYW1lJzogJ0h1b2JpIENOWScsXG4gICAgJ2hvc3RuYW1lJzogJ2JlLmh1b2JpLmNvbScsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU2OS0xNWFhN2I5YS01ZWRkLTExZTctOWU3Zi00NDc5MWY0ZWU0OWMuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2JlLmh1b2JpLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuaHVvYmkuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vaHVvYmlhcGkvQVBJX0RvY3Mvd2lraS9SRVNUX2FwaV9yZWZlcmVuY2UnLFxuICAgIH0sXG4gICAgLy8gJ21hcmtldHMnOiB7XG4gICAgLy8gICAgICdFVEgvQ05ZJzogeyAnaWQnOiAnZXRoY255JywgJ3N5bWJvbCc6ICdFVEgvQ05ZJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0NOWScgfSxcbiAgICAvLyAgICAgJ0VUQy9DTlknOiB7ICdpZCc6ICdldGNjbnknLCAnc3ltYm9sJzogJ0VUQy9DTlknLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQ05ZJyB9LFxuICAgIC8vICAgICAnQkNIL0NOWSc6IHsgJ2lkJzogJ2JjY2NueScsICdzeW1ib2wnOiAnQkNIL0NOWScsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdDTlknIH0sXG4gICAgLy8gfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGh1b2JpcHJvID0gZXh0ZW5kIChodW9iaTEsIHtcblxuICAgICdpZCc6ICdodW9iaXBybycsXG4gICAgJ25hbWUnOiAnSHVvYmkgUHJvJyxcbiAgICAnaG9zdG5hbWUnOiAnYXBpLmh1b2JpLnBybycsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU2OS0xNWFhN2I5YS01ZWRkLTExZTctOWU3Zi00NDc5MWY0ZWU0OWMuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5odW9iaS5wcm8nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lmh1b2JpLnBybycsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9naXRodWIuY29tL2h1b2JpYXBpL0FQSV9Eb2NzL3dpa2kvUkVTVF9hcGlfcmVmZXJlbmNlJyxcbiAgICB9LFxuICAgIC8vICdtYXJrZXRzJzoge1xuICAgIC8vICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aGJ0YycsICdzeW1ib2wnOiAnRVRIL0JUQycsICdiYXNlJzogJ0VUSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgLy8gICAgICdFVEMvQlRDJzogeyAnaWQnOiAnZXRjY255JywgJ3N5bWJvbCc6ICdFVEMvQlRDJywgJ2Jhc2UnOiAnRVRDJywgJ3F1b3RlJzogJ0JUQycgfSxcbiAgICAvLyAgICAgJ0xUQy9CVEMnOiB7ICdpZCc6ICdsdGNidGMnLCAnc3ltYm9sJzogJ0xUQy9CVEMnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgIC8vICAgICAnQkNIL0JUQyc6IHsgJ2lkJzogJ2JjY2NueScsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnIH0sXG4gICAgLy8gfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGh1b2JpID0ge1xuXG4gICAgJ2lkJzogJ2h1b2JpJyxcbiAgICAnbmFtZSc6ICdIdW9iaScsXG4gICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjMnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAnMW0nOiAnMDAxJyxcbiAgICAgICAgJzVtJzogJzAwNScsXG4gICAgICAgICcxNW0nOiAnMDE1JyxcbiAgICAgICAgJzMwbSc6ICcwMzAnLFxuICAgICAgICAnMWgnOiAnMDYwJyxcbiAgICAgICAgJzFkJzogJzEwMCcsXG4gICAgICAgICcxdyc6ICcyMDAnLFxuICAgICAgICAnMU0nOiAnMzAwJyxcbiAgICAgICAgJzF5JzogJzQwMCcsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU2OS0xNWFhN2I5YS01ZWRkLTExZTctOWU3Zi00NDc5MWY0ZWU0OWMuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwOi8vYXBpLmh1b2JpLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuaHVvYmkuY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2dpdGh1Yi5jb20vaHVvYmlhcGkvQVBJX0RvY3NfZW4vd2lraScsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAnc3RhdGljbWFya2V0Jzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne2lkfV9rbGluZV97cGVyaW9kfScsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcl97aWR9JyxcbiAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfScsXG4gICAgICAgICAgICAgICAgJ2RlcHRoX3tpZH1fe2xlbmd0aH0nLFxuICAgICAgICAgICAgICAgICdkZXRhaWxfe2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAndXNkbWFya2V0Jzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAne2lkfV9rbGluZV97cGVyaW9kfScsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcl97aWR9JyxcbiAgICAgICAgICAgICAgICAnZGVwdGhfe2lkfScsXG4gICAgICAgICAgICAgICAgJ2RlcHRoX3tpZH1fe2xlbmd0aH0nLFxuICAgICAgICAgICAgICAgICdkZXRhaWxfe2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAndHJhZGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnZ2V0X2FjY291bnRfaW5mbycsXG4gICAgICAgICAgICAgICAgJ2dldF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdvcmRlcl9pbmZvJyxcbiAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgJ2J1eV9tYXJrZXQnLFxuICAgICAgICAgICAgICAgICdzZWxsX21hcmtldCcsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgJ2dldF9uZXdfZGVhbF9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdnZXRfb3JkZXJfaWRfYnlfdHJhZGVfaWQnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd19jb2luJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX3dpdGhkcmF3X2NvaW4nLFxuICAgICAgICAgICAgICAgICdnZXRfd2l0aGRyYXdfY29pbl9yZXN1bHQnLFxuICAgICAgICAgICAgICAgICd0cmFuc2ZlcicsXG4gICAgICAgICAgICAgICAgJ2xvYW4nLFxuICAgICAgICAgICAgICAgICdyZXBheW1lbnQnLFxuICAgICAgICAgICAgICAgICdnZXRfbG9hbl9hdmFpbGFibGUnLFxuICAgICAgICAgICAgICAgICdnZXRfbG9hbnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0YycsICdzeW1ib2wnOiAnQlRDL0NOWScsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzdGF0aWNtYXJrZXQnLCAnY29pblR5cGUnOiAxIH0sXG4gICAgICAgICdMVEMvQ05ZJzogeyAnaWQnOiAnbHRjJywgJ3N5bWJvbCc6ICdMVEMvQ05ZJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3N0YXRpY21hcmtldCcsICdjb2luVHlwZSc6IDIgfSxcbiAgICAgICAgLy8gJ0JUQy9VU0QnOiB7ICdpZCc6ICdidGMnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJywgJ3R5cGUnOiAndXNkbWFya2V0JywgICAgJ2NvaW5UeXBlJzogMSB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMudHJhZGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0aGlzLmN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBsb3dlcmNhc2UgPSBjdXJyZW5jeS50b0xvd2VyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5hY2NvdW50ICgpO1xuICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9ICdhdmFpbGFibGVfJyArIGxvd2VyY2FzZSArICdfZGlzcGxheSc7XG4gICAgICAgICAgICBsZXQgZnJvemVuID0gJ2Zyb3plbl8nICsgbG93ZXJjYXNlICsgJ19kaXNwbGF5JztcbiAgICAgICAgICAgIGxldCBsb2FuID0gJ2xvYW5fJyArIGxvd2VyY2FzZSArICdfZGlzcGxheSc7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2F2YWlsYWJsZV0pO1xuICAgICAgICAgICAgaWYgKGZyb3plbiBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1tmcm96ZW5dKTtcbiAgICAgICAgICAgIGlmIChsb2FuIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHRoaXMuc3VtIChhY2NvdW50Wyd1c2VkJ10sIHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvYW5dKSk7XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IG1hcmtldFsndHlwZSddICsgJ0dldERlcHRoSWQnO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoeyAnaWQnOiBtYXJrZXRbJ2lkJ10gfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9IG1hcmtldFsndHlwZSddICsgJ0dldFRpY2tlcklkJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh7ICdpZCc6IG1hcmtldFsnaWQnXSB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWyd0aWNrZXInXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChyZXNwb25zZVsndGltZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0cyddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWydkaXJlY3Rpb24nXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0Wyd0eXBlJ10gKyAnR2V0RGV0YWlsSWQnO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbm90IGltcGxlbWVudGVkIHlldFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgb2hsY3ZbMF0sXG4gICAgICAgICAgICBvaGxjdlsxXSxcbiAgICAgICAgICAgIG9obGN2WzJdLFxuICAgICAgICAgICAgb2hsY3ZbM10sXG4gICAgICAgICAgICBvaGxjdls0XSxcbiAgICAgICAgICAgIG9obGN2WzZdLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gbWFya2V0Wyd0eXBlJ10gKyAnR2V0SWRLbGluZVBlcmlvZCc7XG4gICAgICAgIGxldCBvaGxjdnMgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncGVyaW9kJzogdGhpcy50aW1lZnJhbWVzW3RpbWVmcmFtZV0sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gb2hsY3ZzO1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAob2hsY3ZzLCBtYXJrZXQsIHRpbWVmcmFtZSwgc2luY2UsIGxpbWl0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3RyYWRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnY29pbl90eXBlJzogbWFya2V0Wydjb2luVHlwZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ3F1b3RlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtZXRob2QgKz0gdGhpcy5jYXBpdGFsaXplICh0eXBlKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhZGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICd0cmFkZScsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXTtcbiAgICAgICAgaWYgKGFwaSA9PSAndHJhZGUnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy9hcGknICsgdGhpcy52ZXJzaW9uO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdhY2Nlc3Nfa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZWQnOiB0aGlzLm5vbmNlICgpLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBsZXQgcXVlcnlTdHJpbmcgPSB0aGlzLnVybGVuY29kZSAodGhpcy5vbWl0IChxdWVyeSwgJ21hcmtldCcpKTtcbiAgICAgICAgICAgIC8vIHNlY3JldCBrZXkgbXVzdCBiZSBhcHBlbmRlZCB0byB0aGUgcXVlcnkgYmVmb3JlIHNpZ25pbmdcbiAgICAgICAgICAgIHF1ZXJ5U3RyaW5nICs9ICcmc2VjcmV0X2tleT0nICsgdGhpcy5zZWNyZXQ7XG4gICAgICAgICAgICBxdWVyeVsnc2lnbiddID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAocXVlcnlTdHJpbmcpKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsICs9ICcvJyArIGFwaSArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKSArICdfanNvbi5qcyc7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIGlmICgnY29kZScgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGluZGVwZW5kZW50cmVzZXJ2ZSA9IHtcblxuICAgICdpZCc6ICdpbmRlcGVuZGVudHJlc2VydmUnLFxuICAgICduYW1lJzogJ0luZGVwZW5kZW50IFJlc2VydmUnLFxuICAgICdjb3VudHJpZXMnOiBbICdBVScsICdOWicgXSwgLy8gQXVzdHJhbGlhLCBOZXcgWmVhbGFuZFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMzA1MjE2NjItY2YzZjQ3N2MtOWJjYi0xMWU3LTg5YmMtZDFhYzg1MDEyZWRhLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmluZGVwZW5kZW50cmVzZXJ2ZS5jb20vUHVibGljJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmluZGVwZW5kZW50cmVzZXJ2ZS5jb20vUHJpdmF0ZScsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cuaW5kZXBlbmRlbnRyZXNlcnZlLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuaW5kZXBlbmRlbnRyZXNlcnZlLmNvbS9BUEknLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ0dldFZhbGlkUHJpbWFyeUN1cnJlbmN5Q29kZXMnLFxuICAgICAgICAgICAgICAgICdHZXRWYWxpZFNlY29uZGFyeUN1cnJlbmN5Q29kZXMnLFxuICAgICAgICAgICAgICAgICdHZXRWYWxpZExpbWl0T3JkZXJUeXBlcycsXG4gICAgICAgICAgICAgICAgJ0dldFZhbGlkTWFya2V0T3JkZXJUeXBlcycsXG4gICAgICAgICAgICAgICAgJ0dldFZhbGlkT3JkZXJUeXBlcycsXG4gICAgICAgICAgICAgICAgJ0dldFZhbGlkVHJhbnNhY3Rpb25UeXBlcycsXG4gICAgICAgICAgICAgICAgJ0dldE1hcmtldFN1bW1hcnknLFxuICAgICAgICAgICAgICAgICdHZXRPcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICdHZXRUcmFkZUhpc3RvcnlTdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAnR2V0UmVjZW50VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnR2V0RnhSYXRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdQbGFjZUxpbWl0T3JkZXInLFxuICAgICAgICAgICAgICAgICdQbGFjZU1hcmtldE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdHZXRPcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnR2V0Q2xvc2VkT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnR2V0Q2xvc2VkRmlsbGVkT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnR2V0T3JkZXJEZXRhaWxzJyxcbiAgICAgICAgICAgICAgICAnR2V0QWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdHZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICdHZXREaWdpdGFsQ3VycmVuY3lEZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ0dldERpZ2l0YWxDdXJyZW5jeURlcG9zaXRBZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICdTeW5jaERpZ2l0YWxDdXJyZW5jeURlcG9zaXRBZGRyZXNzV2l0aEJsb2NrY2hhaW4nLFxuICAgICAgICAgICAgICAgICdXaXRoZHJhd0RpZ2l0YWxDdXJyZW5jeScsXG4gICAgICAgICAgICAgICAgJ1JlcXVlc3RGaWF0V2l0aGRyYXdhbCcsXG4gICAgICAgICAgICAgICAgJ0dldFRyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgYmFzZUN1cnJlbmNpZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFZhbGlkUHJpbWFyeUN1cnJlbmN5Q29kZXMgKCk7XG4gICAgICAgIGxldCBxdW90ZUN1cnJlbmNpZXMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFZhbGlkU2Vjb25kYXJ5Q3VycmVuY3lDb2RlcyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VDdXJyZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFzZUlkID0gYmFzZUN1cnJlbmNpZXNbaV07XG4gICAgICAgICAgICBsZXQgYmFzZUlkVXBwZXJjYXNlID0gYmFzZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZUlkVXBwZXJjYXNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVvdGVDdXJyZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlSWQgPSBxdW90ZUN1cnJlbmNpZXNbal07XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlSWRVcHBlcmNhc2UgPSBxdW90ZUlkLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgICAgIGxldCBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZUlkVXBwZXJjYXNlKTtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBiYXNlSWQgKyAnLycgKyBxdW90ZUlkO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAgICAgICAgICdxdW90ZUlkJzogcXVvdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBpZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2ldO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5Q29kZSA9IGJhbGFuY2VbJ0N1cnJlbmN5Q29kZSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5Q29kZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlICh1cHBlcmNhc2UpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBiYWxhbmNlWydBdmFpbGFibGVCYWxhbmNlJ107XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZVsnVG90YWxCYWxhbmNlJ107XG4gICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwcmltYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydiYXNlSWQnXSxcbiAgICAgICAgICAgICdzZWNvbmRhcnlDdXJyZW5jeUNvZGUnOiBtYXJrZXRbJ3F1b3RlSWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAocmVzcG9uc2VbJ0NyZWF0ZWRUaW1lc3RhbXBVdGMnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZSwgdGltZXN0YW1wLCAnQnV5T3JkZXJzJywgJ1NlbGxPcmRlcnMnLCAnUHJpY2UnLCAnVm9sdW1lJyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnQ3JlYXRlZFRpbWVzdGFtcFV0YyddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRpY2tlclsnRGF5SGlnaGVzdFByaWNlJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydEYXlMb3dlc3RQcmljZSddLFxuICAgICAgICAgICAgJ2JpZCc6IHRpY2tlclsnQ3VycmVudEhpZ2hlc3RCaWRQcmljZSddLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlclsnQ3VycmVudExvd2VzdE9mZmVyUHJpY2UnXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRpY2tlclsnTGFzdFByaWNlJ10sXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHRpY2tlclsnRGF5QXZnUHJpY2UnXSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdGlja2VyWydEYXlWb2x1bWVYYnQnXSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRpY2tlclsnRGF5Vm9sdW1lWGJ0SW5TZWNvbmRhcnlDdXJycmVuY3knXSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRTdW1tYXJ5ICh7XG4gICAgICAgICAgICAncHJpbWFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsnYmFzZUlkJ10sXG4gICAgICAgICAgICAnc2Vjb25kYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydxdW90ZUlkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVHJhZGVUaW1lc3RhbXBVdGMnXSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydTZWNvbmRhcnlDdXJyZW5jeVRyYWRlUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnUHJpbWFyeUN1cnJlbmN5QW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRSZWNlbnRUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncHJpbWFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsnYmFzZUlkJ10sXG4gICAgICAgICAgICAnc2Vjb25kYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydxdW90ZUlkJ10sXG4gICAgICAgICAgICAnbnVtYmVyT2ZSZWNlbnRUcmFkZXNUb1JldHJpZXZlJzogNTAsIC8vIG1heCA9IDUwXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ1RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBjYXBpdGFsaXplZE9yZGVyVHlwZSA9IHRoaXMuY2FwaXRhbGl6ZSAodHlwZSk7XG4gICAgICAgIGxldCBtZXRob2QgPSAnUGxhY2UnICsgY2FwaXRhbGl6ZWRPcmRlclR5cGUgKyAnT3JkZXInO1xuICAgICAgICBsZXQgb3JkZXJUeXBlID0gY2FwaXRhbGl6ZWRPcmRlclR5cGU7XG4gICAgICAgIG9yZGVyVHlwZSArPSAoc2lkZSA9PSAnc2VsbCcpID8gICdPZmZlcicgOiAnQmlkJztcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5vcmRlcmVkICh7XG4gICAgICAgICAgICAncHJpbWFyeUN1cnJlbmN5Q29kZSc6IG1hcmtldFsnYmFzZUlkJ10sXG4gICAgICAgICAgICAnc2Vjb25kYXJ5Q3VycmVuY3lDb2RlJzogbWFya2V0WydxdW90ZUlkJ10sXG4gICAgICAgICAgICAnb3JkZXJUeXBlJzogb3JkZXJUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIG9yZGVyWyd2b2x1bWUnXSA9IGFtb3VudDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydPcmRlckd1aWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyR3VpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV0gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IFtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgJ2FwaUtleT0nICsgdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlPScgKyBub25jZS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQga2V5c29ydGVkID0gdGhpcy5rZXlzb3J0IChwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyAocGFyYW1zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGF1dGgucHVzaCAoa2V5ICsgJz0nICsgcGFyYW1zW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBhdXRoLmpvaW4gKCcsJyk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAobWVzc2FnZSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5rZXlzb3J0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdhcGlLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc2lnbmF0dXJlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAvLyB0b2RvIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBpdGJpdCA9IHtcblxuICAgICdpZCc6ICdpdGJpdCcsXG4gICAgJ25hbWUnOiAnaXRCaXQnLFxuICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4MjIxNTktNjYxNTM2MjAtNjBhZC0xMWU3LTg5ZTctMDA1ZjZkN2YzZGUwLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkuaXRiaXQuY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5pdGJpdC5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLml0Yml0LmNvbS9kb2NzJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5pdGJpdC5jb20vYXBpJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdtYXJrZXRzL3tzeW1ib2x9L3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ21hcmtldHMve3N5bWJvbH0vb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgJ21hcmtldHMve3N5bWJvbH0vdHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnd2FsbGV0cycsXG4gICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfScsXG4gICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfS9iYWxhbmNlcy97Y3VycmVuY3lDb2RlfScsXG4gICAgICAgICAgICAgICAgJ3dhbGxldHMve3dhbGxldElkfS9mdW5kaW5nX2hpc3RvcnknLFxuICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnd2FsbGV0cy97d2FsbGV0SWR9L29yZGVycy97aWR9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnd2FsbGV0X3RyYW5zZmVycycsXG4gICAgICAgICAgICAgICAgJ3dhbGxldHMnLFxuICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vY3J5cHRvY3VycmVuY3lfZGVwb3NpdHMnLFxuICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vY3J5cHRvY3VycmVuY3lfd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnd2lyZV93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAnZGVsZXRlJzogW1xuICAgICAgICAgICAgICAgICd3YWxsZXRzL3t3YWxsZXRJZH0vb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ1hCVFVTRCcsICdzeW1ib2wnOiAnQlRDL1VTRCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdVU0QnIH0sXG4gICAgICAgICdCVEMvU0dEJzogeyAnaWQnOiAnWEJUU0dEJywgJ3N5bWJvbCc6ICdCVEMvU0dEJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1NHRCcgfSxcbiAgICAgICAgJ0JUQy9FVVInOiB7ICdpZCc6ICdYQlRFVVInLCAnc3ltYm9sJzogJ0JUQy9FVVInLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnRVVSJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzU3ltYm9sT3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzU3ltYm9sVGlja2VyICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBzZXJ2ZXJUaW1lVVRDID0gKCdzZXJ2ZXJUaW1lVVRDJyBpbiB0aWNrZXIpO1xuICAgICAgICBpZiAoIXNlcnZlclRpbWVVVEMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgZmV0Y2hUaWNrZXIgcmV0dXJuZWQgYSBiYWQgcmVzcG9uc2U6ICcgKyB0aGlzLmpzb24gKHRpY2tlcikpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5wYXJzZTg2MDEgKHRpY2tlclsnc2VydmVyVGltZVVUQyddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaDI0aCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdzI0aCddKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAyNGgnXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlblRvZGF5J10pLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3RQcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZTI0aCddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodHJhZGVbJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgbGV0IGlkID0gdHJhZGVbJ21hdGNoTnVtYmVyJ10udG9TdHJpbmcgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAnb3JkZXInOiBpZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHNTeW1ib2xUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydyZWNlbnRUcmFkZXMnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZUJhbGFuY2UnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogcGFyc2VGbG9hdCAoYmFsYW5jZVsndG90YWxCYWxhbmNlJ10pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGFjY291bnRbJ3RvdGFsJ10gLSBhY2NvdW50WydmcmVlJ107XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBmZXRjaFdhbGxldHMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlR2V0V2FsbGV0cyAoKTtcbiAgICB9LFxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgd2FsbGV0SWRJblBhcmFtcyA9ICgnd2FsbGV0SWQnIGluIHBhcmFtcyk7XG4gICAgICAgIGlmICghd2FsbGV0SWRJblBhcmFtcylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBjcmVhdGVPcmRlciByZXF1aXJlcyBhIHdhbGxldElkIHBhcmFtZXRlcicpO1xuICAgICAgICBhbW91bnQgPSBhbW91bnQudG9TdHJpbmcgKCk7XG4gICAgICAgIHByaWNlID0gcHJpY2UudG9TdHJpbmcgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ2N1cnJlbmN5JzogbWFya2V0WydiYXNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICdpbnN0cnVtZW50JzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGVBZGQgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IHdhbGxldElkSW5QYXJhbXMgPSAoJ3dhbGxldElkJyBpbiBwYXJhbXMpO1xuICAgICAgICBpZiAoIXdhbGxldElkSW5QYXJhbXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgY2FuY2VsT3JkZXIgcmVxdWlyZXMgYSB3YWxsZXRJZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZURlbGV0ZVdhbGxldHNXYWxsZXRJZE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYm9keSA9ICcnO1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKS50b1N0cmluZyAoKTtcbiAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSBub25jZTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gWyBtZXRob2QsIHVybCwgYm9keSwgbm9uY2UsIHRpbWVzdGFtcCBdO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBub25jZSArIHRoaXMuanNvbiAoYXV0aCk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKG1lc3NhZ2UpLCAnc2hhMjU2JywgJ2JpbmFyeScpO1xuICAgICAgICAgICAgbGV0IGJpbmhhc2ggPSB0aGlzLmJpbmFyeUNvbmNhdCAodXJsLCBoYXNoKTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKGJpbmhhc2gsIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBdXRob3JpemF0aW9uJzogc2VsZi5hcGlLZXkgKyAnOicgKyBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnWC1BdXRoLVRpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAnWC1BdXRoLU5vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIganViaSA9IHtcblxuICAgICdpZCc6ICdqdWJpJyxcbiAgICAnbmFtZSc6ICdqdWJpLmNvbScsXG4gICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgJ3JhdGVMaW1pdCc6IDE1MDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY1ODEtOWQzOTdkOWEtNWVkZC0xMWU3LThmYjktNWQ4MjM2YzBlNjkyLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuanViaS5jb20vYXBpJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5qdWJpLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cuanViaS5jb20vaGVscC9hcGkuaHRtbCcsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICdhbGx0aWNrZXInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlX2FkZCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlX2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlX2xpc3QnLFxuICAgICAgICAgICAgICAgICd0cmFkZV92aWV3JyxcbiAgICAgICAgICAgICAgICAnd2FsbGV0JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBbGx0aWNrZXIgKCk7XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwga2V5cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IGlkID0ga2V5c1twXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gaWQudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSAnQ05ZJztcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgaWYgKGxvd2VyY2FzZSA9PSAnZGFzaCcpXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlID0gJ2Ryayc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gbG93ZXJjYXNlICsgJ19iYWxhbmNlJztcbiAgICAgICAgICAgIGxldCB1c2VkID0gbG93ZXJjYXNlICsgJ19sb2NrJztcbiAgICAgICAgICAgIGlmIChmcmVlIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2ZyZWVdKTtcbiAgICAgICAgICAgIGlmICh1c2VkIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW3VzZWRdKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICAgICAgcmVzdWx0Wydhc2tzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0Wydhc2tzJ10sIDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYnV5J10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnc2VsbCddKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbCddKSxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBbGx0aWNrZXIgKCk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnY29pbic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3RpZCddLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10sXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlQWRkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2NvaW4nOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdFRyYWRlQ2FuY2VsICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuaGFzaCAodGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSk7XG4gICAgICAgICAgICBxdWVyeVsnc2lnbmF0dXJlJ10gPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChyZXF1ZXN0KSwgdGhpcy5lbmNvZGUgKHNlY3JldCkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGtyYWtlbiBpcyBhbHNvIG93bmVyIG9mIGV4LiBDb2luc2V0dGVyIC8gQ2FWaXJ0RXggLyBDbGV2ZXJjb2luXG5cbnZhciBrcmFrZW4gPSB7XG5cbiAgICAnaWQnOiAna3Jha2VuJyxcbiAgICAnbmFtZSc6ICdLcmFrZW4nLFxuICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICd2ZXJzaW9uJzogJzAnLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICdtYXJrZXRzQnlBbHRuYW1lJzoge30sXG4gICAgJ3RpbWVmcmFtZXMnOiB7XG4gICAgICAgICcxbSc6ICcxJyxcbiAgICAgICAgJzVtJzogJzUnLFxuICAgICAgICAnMTVtJzogJzE1JyxcbiAgICAgICAgJzMwbSc6ICczMCcsXG4gICAgICAgICcxaCc6ICc2MCcsXG4gICAgICAgICc0aCc6ICcyNDAnLFxuICAgICAgICAnMWQnOiAnMTQ0MCcsXG4gICAgICAgICcxdyc6ICcxMDA4MCcsXG4gICAgICAgICcydyc6ICcyMTYwMCcsXG4gICAgfSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjU5OS0yMjcwOTMwNC01ZWRlLTExZTctOWRlMS05ZjMzNzMyZTE1MDkuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5rcmFrZW4uY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5rcmFrZW4uY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3d3dy5rcmFrZW4uY29tL2VuLXVzL2hlbHAvYXBpJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vbm90aGluZ2lzZGVhZC9ucG0ta3Jha2VuLWFwaScsXG4gICAgICAgIF0sXG4gICAgICAgICdmZWVzJzogJ2h0dHBzOi8vd3d3LmtyYWtlbi5jb20vZW4tdXMvaGVscC9mZWVzJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdBc3NldHMnLFxuICAgICAgICAgICAgICAgICdBc3NldFBhaXJzJyxcbiAgICAgICAgICAgICAgICAnRGVwdGgnLFxuICAgICAgICAgICAgICAgICdPSExDJyxcbiAgICAgICAgICAgICAgICAnU3ByZWFkJyxcbiAgICAgICAgICAgICAgICAnVGlja2VyJyxcbiAgICAgICAgICAgICAgICAnVGltZScsXG4gICAgICAgICAgICAgICAgJ1RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdBZGRPcmRlcicsXG4gICAgICAgICAgICAgICAgJ0JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgJ0Nsb3NlZE9yZGVycycsXG4gICAgICAgICAgICAgICAgJ0RlcG9zaXRBZGRyZXNzZXMnLFxuICAgICAgICAgICAgICAgICdEZXBvc2l0TWV0aG9kcycsXG4gICAgICAgICAgICAgICAgJ0RlcG9zaXRTdGF0dXMnLFxuICAgICAgICAgICAgICAgICdMZWRnZXJzJyxcbiAgICAgICAgICAgICAgICAnT3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgJ09wZW5Qb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICdRdWVyeUxlZGdlcnMnLFxuICAgICAgICAgICAgICAgICdRdWVyeU9yZGVycycsXG4gICAgICAgICAgICAgICAgJ1F1ZXJ5VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnVHJhZGVCYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAnVHJhZGVzSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ1RyYWRlVm9sdW1lJyxcbiAgICAgICAgICAgICAgICAnV2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICdXaXRoZHJhd0NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ1dpdGhkcmF3SW5mbycsXG4gICAgICAgICAgICAgICAgJ1dpdGhkcmF3U3RhdHVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRBc3NldFBhaXJzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydyZXN1bHQnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBrZXlzW3BdO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3Jlc3VsdCddW2lkXTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gbWFya2V0WydiYXNlJ107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3F1b3RlJ107XG4gICAgICAgICAgICBpZiAoKGJhc2VbMF0gPT0gJ1gnKSB8fCAoYmFzZVswXSA9PSAnWicpKVxuICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLnNsaWNlICgxKTtcbiAgICAgICAgICAgIGlmICgocXVvdGVbMF0gPT0gJ1gnKSB8fCAocXVvdGVbMF0gPT0gJ1onKSlcbiAgICAgICAgICAgICAgICBxdW90ZSA9IHF1b3RlLnNsaWNlICgxKTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICBsZXQgZGFya3Bvb2wgPSBpZC5pbmRleE9mICgnLmQnKSA+PSAwO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGRhcmtwb29sID8gbWFya2V0WydhbHRuYW1lJ10gOiAoYmFzZSArICcvJyArIHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBtYWtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnZmVlc19tYWtlcicgaW4gbWFya2V0KVxuICAgICAgICAgICAgICAgIG1ha2VyID0gbWFya2V0WydmZWVzX21ha2VyJ11bMF1bMV07XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdkYXJrcG9vbCc6IGRhcmtwb29sLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgICAgICdhbHRuYW1lJzogbWFya2V0WydhbHRuYW1lJ10sXG4gICAgICAgICAgICAgICAgJ21ha2VyJzogbWFrZXIsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogbWFya2V0WydmZWVzJ11bMF1bMV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtldHNCeUFsdG5hbWUgPSB0aGlzLmluZGV4QnkgKHJlc3VsdCwgJ2FsdG5hbWUnKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGRhcmtwb29sID0gc3ltYm9sLmluZGV4T2YgKCcuZCcpID49IDA7XG4gICAgICAgIGlmIChkYXJrcG9vbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkb2VzIG5vdCBwcm92aWRlIGFuIG9yZGVyIGJvb2sgZm9yIGRhcmtwb29sIHN5bWJvbCAnICsgc3ltYm9sKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbJ3Jlc3VsdCddW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2spO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoJ11bMV0pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbCddWzFdKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2InXVswXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydhJ11bMF0pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3AnXVsxXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnbyddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydjJ11bMF0pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndiddWzFdKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0aGlzLnN5bWJvbHMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSB0aGlzLnN5bWJvbHNbc107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICBpZiAoIW1hcmtldFsnZGFya3Bvb2wnXSlcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoIChtYXJrZXRbJ2lkJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWx0ZXIgPSBwYWlycy5qb2luICgnLCcpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ3BhaXInOiBmaWx0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGRhcmtwb29sID0gc3ltYm9sLmluZGV4T2YgKCcuZCcpID49IDA7XG4gICAgICAgIGlmIChkYXJrcG9vbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkb2VzIG5vdCBwcm92aWRlIGEgdGlja2VyIGZvciBkYXJrcG9vbCBzeW1ib2wgJyArIHN5bWJvbCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXIgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydyZXN1bHQnXVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZU9ITENWIChvaGxjdiwgbWFya2V0ID0gdW5kZWZpbmVkLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9obGN2WzBdICogMTAwMCxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzFdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzJdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzNdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzRdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQgKG9obGN2WzZdKSxcbiAgICAgICAgXTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdpbnRlcnZhbCc6IHRoaXMudGltZWZyYW1lc1t0aW1lZnJhbWVdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2luY2UpXG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gcGFyc2VJbnQgKHNpbmNlIC8gMTAwMCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T0hMQyAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICBsZXQgb2hsY3ZzID0gcmVzcG9uc2VbJ3Jlc3VsdCddW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT0hMQ1ZzIChvaGxjdnMsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbMl0gKiAxMDAwKTtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbM10gPT0gJ3MnKSA/ICdzZWxsJyA6ICdidXknO1xuICAgICAgICBsZXQgdHlwZSA9ICh0cmFkZVs0XSA9PSAnbCcpID8gJ2xpbWl0JyA6ICdtYXJrZXQnO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdHlwZSxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWzBdKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsxXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdHJhZGVzID0gcmVzcG9uc2VbJ3Jlc3VsdCddW2lkXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHRyYWRlcywgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3Jlc3VsdCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGNvZGUgPSBjdXJyZW5jeTtcbiAgICAgICAgICAgIC8vIFgtSVNPNDIxNy1BMyBzdGFuZGFyZCBjdXJyZW5jeSBjb2Rlc1xuICAgICAgICAgICAgaWYgKGNvZGVbMF0gPT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUuc2xpY2UgKDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlWzBdID09ICdaJykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnNsaWNlICgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoY29kZSk7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2N1cnJlbmN5XSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY29kZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYWlyJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgICAgICdvcmRlcnR5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3ZvbHVtZSc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RBZGRPcmRlciAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHJlc3BvbnNlWydyZXN1bHQnXVsndHhpZCddLmxlbmd0aDtcbiAgICAgICAgbGV0IGlkID0gKGxlbmd0aCA+IDEpID8gcmVzcG9uc2VbJ3Jlc3VsdCddWyd0eGlkJ10gOiByZXNwb25zZVsncmVzdWx0J11bJ3R4aWQnXVswXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VPcmRlciAob3JkZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBvcmRlclsnZGVzY3InXTtcbiAgICAgICAgbGV0IHNpZGUgPSBkZXNjcmlwdGlvblsndHlwZSddO1xuICAgICAgICBsZXQgdHlwZSA9IGRlc2NyaXB0aW9uWydvcmRlcnR5cGUnXTtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFtYXJrZXQpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gZGVzY3JpcHRpb25bJ3BhaXInXTtcbiAgICAgICAgICAgIGlmIChwYWlyIGluIHRoaXMubWFya2V0c0J5QWx0bmFtZSkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c0J5QWx0bmFtZVtwYWlyXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFpciBpbiB0aGlzLm1hcmtldHNfYnlfaWQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbcGFpcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtldClcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAob3JkZXJbJ29wZW50bSddICogMTAwMCk7XG4gICAgICAgIGxldCBhbW91bnQgPSBwYXJzZUZsb2F0IChvcmRlclsndm9sJ10pO1xuICAgICAgICBsZXQgZmlsbGVkID0gcGFyc2VGbG9hdCAob3JkZXJbJ3ZvbF9leGVjJ10pO1xuICAgICAgICBsZXQgcmVtYWluaW5nID0gYW1vdW50IC0gZmlsbGVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogb3JkZXJbJ2lkJ10sXG4gICAgICAgICAgICAnaW5mbyc6IG9yZGVyLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBvcmRlclsnc3RhdHVzJ10sXG4gICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ3NpZGUnOiBzaWRlLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAob3JkZXJbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgICAgICdmaWxsZWQnOiBmaWxsZWQsXG4gICAgICAgICAgICAncmVtYWluaW5nJzogcmVtYWluaW5nLFxuICAgICAgICAgICAgLy8gJ3RyYWRlcyc6IHRoaXMucGFyc2VUcmFkZXMgKG9yZGVyWyd0cmFkZXMnXSwgbWFya2V0KSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChvcmRlcnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5leHRlbmQgKHsgJ2lkJzogaWQgfSwgb3JkZXJzW2lkXSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5wYXJzZU9yZGVyIChvcmRlciwgbWFya2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RRdWVyeU9yZGVycyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICd0cmFkZXMnOiB0cnVlLCAvLyB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRyYWRlcyBpbiBvdXRwdXQgKG9wdGlvbmFsLCBkZWZhdWx0IGZhbHNlKVxuICAgICAgICAgICAgJ3R4aWQnOiBpZCwgLy8gY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgdHJhbnNhY3Rpb24gaWRzIHRvIHF1ZXJ5IGluZm8gYWJvdXQgKDIwIG1heGltdW0pXG4gICAgICAgICAgICAvLyAndXNlcnJlZic6ICdvcHRpb25hbCcsIC8vIHJlc3RyaWN0IHJlc3VsdHMgdG8gZ2l2ZW4gdXNlciByZWZlcmVuY2UgaWQgKG9wdGlvbmFsKVxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IHJlc3BvbnNlWydyZXN1bHQnXTtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyIChvcmRlcnNbaWRdKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kICh7ICdpbmZvJzogcmVzcG9uc2UgfSwgb3JkZXIpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAoeyAndHhpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyB3aXRoZHJhdyAoY3VycmVuY3ksIGFtb3VudCwgYWRkcmVzcywgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCdrZXknIGluIHBhcmFtcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RXaXRoZHJhdyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXNzZXQnOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgICAgIC8vICdhZGRyZXNzJzogYWRkcmVzcywgLy8gdGhleSBkb24ndCBhbGxvdyB3aXRoZHJhd2FscyB0byBkaXJlY3QgYWRkcmVzc2VzXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAnaWQnOiByZXNwb25zZVsncmVzdWx0J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgXCIgd2l0aGRyYXcgcmVxdWlyZXMgYSAna2V5JyBwYXJhbWV0ZXIgKHdpdGhkcmF3YWwga2V5IG5hbWUsIGFzIHNldCB1cCBvbiB5b3VyIGFjY291bnQpXCIpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0SWQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RPcGVuT3JkZXJzIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddWydvcGVuJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldElkIChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0Q2xvc2VkT3JkZXJzIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVycyAocmVzcG9uc2VbJ3Jlc3VsdCddWydjbG9zZWQnXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgYXBpICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoeyAnbm9uY2UnOiBub25jZSB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGxldCBhdXRoID0gdGhpcy5lbmNvZGUgKG5vbmNlICsgYm9keSk7XG4gICAgICAgICAgICBsZXQgaGFzaCA9IHRoaXMuaGFzaCAoYXV0aCwgJ3NoYTI1NicsICdiaW5hcnknKTtcbiAgICAgICAgICAgIGxldCBiaW5hcnkgPSB0aGlzLnN0cmluZ1RvQmluYXJ5ICh0aGlzLmVuY29kZSAodXJsKSk7XG4gICAgICAgICAgICBsZXQgYmluaGFzaCA9IHRoaXMuYmluYXJ5Q29uY2F0IChiaW5hcnksIGhhc2gpO1xuICAgICAgICAgICAgbGV0IHNlY3JldCA9IHRoaXMuYmFzZTY0VG9CaW5hcnkgKHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKGJpbmhhc2gsIHNlY3JldCwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FQSS1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnQVBJLVNpZ24nOiB0aGlzLmRlY29kZSAoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyB1cmw7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBudW1FcnJvcnMgPSByZXNwb25zZVsnZXJyb3InXS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobnVtRXJyb3JzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBsYWtlYnRjID0ge1xuXG4gICAgJ2lkJzogJ2xha2VidGMnLFxuICAgICduYW1lJzogJ0xha2VCVEMnLFxuICAgICdjb3VudHJpZXMnOiAnVVMnLFxuICAgICd2ZXJzaW9uJzogJ2FwaV92MicsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDc0MTIwLTcyYjdjMzhhLTY2NjAtMTFlNy05MmQ5LWQ5MDI3NTAyMjgxZC5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmxha2VidGMuY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5sYWtlYnRjLmNvbScsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cubGFrZWJ0Yy5jb20vcy9hcGlfdjInLFxuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lmxha2VidGMuY29tL3MvYXBpJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdiY29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgJ2JjdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2J1eU9yZGVyJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnZ2V0QWNjb3VudEluZm8nLFxuICAgICAgICAgICAgICAgICdnZXRFeHRlcm5hbEFjY291bnRzJyxcbiAgICAgICAgICAgICAgICAnZ2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnZ2V0VHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnb3Blbk9yZGVycycsXG4gICAgICAgICAgICAgICAgJ3NlbGxPcmRlcicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKG1hcmtldHMpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNba107XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgcXVvdGUgPSBxdW90ZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0R2V0QWNjb3VudEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgbGV0IGN1cnJlbmNpZXMgPSBPYmplY3Qua2V5cyAoYmFsYW5jZXMpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGN1cnJlbmNpZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2N1cnJlbmN5XSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogYmFsYW5jZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAobWFya2V0LCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRCY29yZGVyYm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbWFya2V0WydpZCddXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2JpZCcpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdhc2snKSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdsYXN0JyksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ3ZvbHVtZScpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEJjdHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdPcmRlcic7XG4gICAgICAgIGxldCBtYXJrZXRJZCA9IHRoaXMubWFya2V0SWQgKG1hcmtldCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICdwYXJhbXMnOiBbIHByaWNlLCBhbW91bnQsIG1hcmtldElkIF0sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKG9yZGVyLCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzcG9uc2UsXG4gICAgICAgICAgICAnaWQnOiByZXNwb25zZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ3BhcmFtcyc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgcGF0aDtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLmpvaW4gKCcsJyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gJyc7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnVybGVuY29kZSAoe1xuICAgICAgICAgICAgICAgICd0b25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdhY2Nlc3NrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAncmVxdWVzdG1ldGhvZCc6IG1ldGhvZC50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICAgICAnaWQnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgICAgICAncGFyYW1zJzogcGFyYW1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAnaWQnOiBub25jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHF1ZXJ5KSwgdGhpcy5zZWNyZXQsICdzaGExJywgJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnSnNvbi1ScGMtVG9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IFwiQmFzaWMgXCIgKyB0aGlzLmFwaUtleSArICc6JyArIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBsaXZlY29pbiA9IHtcblxuICAgICdpZCc6ICdsaXZlY29pbicsXG4gICAgJ25hbWUnOiAnTGl2ZUNvaW4nLFxuICAgICdjb3VudHJpZXMnOiBbICdVUycsICdVSycsICdSVScgXSxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTgwNzY4LWYyMmZjNDI0LTYzOGEtMTFlNy04OWM5LTYwMTBhNTRmZjliZS5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLmxpdmVjb2luLm5ldCcsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cubGl2ZWNvaW4ubmV0JyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5saXZlY29pbi5uZXQvYXBpP2xhbmc9ZW4nLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2FsbC9vcmRlcl9ib29rJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvbGFzdF90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9tYXhiaWRfbWluYXNrJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3Jlc3RyaWN0aW9ucycsXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL3RpY2tlcicsIC8vIG9taXQgcGFyYW1zIHRvIGdldCBhbGwgdGlja2VycyBhdCBvbmNlXG4gICAgICAgICAgICAgICAgJ2luZm8vY29pbkluZm8nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdleGNoYW5nZS9jbGllbnRfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2Uvb3JkZXInLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9jb21taXNzaW9uJyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvY29tbWlzc2lvbkNvbW1vbkluZm8nLFxuICAgICAgICAgICAgICAgICdwYXltZW50L2JhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC9nZXQvYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ3BheW1lbnQvaGlzdG9yeS9zaXplJyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC9oaXN0b3J5L3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2V4Y2hhbmdlL2J1eWxpbWl0JyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvYnV5bWFya2V0JyxcbiAgICAgICAgICAgICAgICAnZXhjaGFuZ2UvY2FuY2VsbGltaXQnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9zZWxsbGltaXQnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZS9zZWxsbWFya2V0JyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvY2FwaXRhbGlzdCcsXG4gICAgICAgICAgICAgICAgJ3BheW1lbnQvb3V0L2NhcmQnLFxuICAgICAgICAgICAgICAgICdwYXltZW50L291dC9jb2luJyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC9vdXQvb2twYXknLFxuICAgICAgICAgICAgICAgICdwYXltZW50L291dC9wYXllZXInLFxuICAgICAgICAgICAgICAgICdwYXltZW50L291dC9wZXJmZWN0bW9uZXknLFxuICAgICAgICAgICAgICAgICdwYXltZW50L3ZvdWNoZXIvYW1vdW50JyxcbiAgICAgICAgICAgICAgICAncGF5bWVudC92b3VjaGVyL21ha2UnLFxuICAgICAgICAgICAgICAgICdwYXltZW50L3ZvdWNoZXIvcmVkZWVtJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRpY2tlciAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBpZDtcbiAgICAgICAgICAgIGxldCBbIGJhc2UsIHF1b3RlIF0gPSBzeW1ib2wuc3BsaXQgKCcvJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRQYXltZW50QmFsYW5jZXMgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCB0aGlzLmN1cnJlbmNpZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY3VycmVuY3kgaW4gcmVzdWx0KVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSByZXN1bHRbY3VycmVuY3ldO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAoYmFsYW5jZVsndHlwZSddID09ICd0b3RhbCcpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3ZhbHVlJ10pO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2VbJ3R5cGUnXSA9PSAnYXZhaWxhYmxlJylcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIGlmIChiYWxhbmNlWyd0eXBlJ10gPT0gJ3RyYWRlJylcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlT3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnZ3JvdXBCeVByaWNlJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICdkZXB0aCc6IDEwMCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBvcmRlcmJvb2tbJ3RpbWVzdGFtcCddO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rLCB0aW1lc3RhbXApO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmVzdF9iaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydiZXN0X2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlVGlja2VyICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2UsICdzeW1ib2wnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGNoYW5nZVRpY2tlciAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWyd0aW1lJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0eXBlJ10udG9Mb3dlckNhc2UgKCksXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsncXVhbnRpdHknXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEV4Y2hhbmdlTGFzdFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RFeGNoYW5nZScgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgdHlwZTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzW21ldGhvZF0gKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RFeGNoYW5nZUNhbmNlbGxpbWl0ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVySWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmtleXNvcnQgKHBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJylcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBpZiAocXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBxdWVyeTtcbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChxdWVyeSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGEyNTYnKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FwaS1LZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHNpZ25hdHVyZS50b1VwcGVyQ2FzZSAoKSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGxpcXVpID0ge1xuICAgICdpZCc6ICdsaXF1aScsXG4gICAgJ25hbWUnOiAnTGlxdWknLFxuICAgICdjb3VudHJpZXMnOiAnVUEnLFxuICAgICdyYXRlTGltaXQnOiAyMDAwLFxuICAgICd2ZXJzaW9uJzogJzMnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5ODIwMjItNzVhZWE4MjgtNjNhMC0xMWU3LTk1MTEtY2E1ODRhOGVkZDc0LmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmxpcXVpLmlvL2FwaScsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5saXF1aS5pby90YXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL2xpcXVpLmlvJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2xpcXVpLmlvL2FwaScsXG4gICAgICAgICdmZWVzJzogJ2h0dHBzOi8vbGlxdWkuaW8vZmVlJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdpbmZvJyxcbiAgICAgICAgICAgICAgICAndGlja2VyL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2RlcHRoL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97cGFpcn0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnZ2V0SW5mbycsXG4gICAgICAgICAgICAgICAgJ1RyYWRlJyxcbiAgICAgICAgICAgICAgICAnQWN0aXZlT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnT3JkZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAnQ2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICdUcmFuc0hpc3RvcnknLFxuICAgICAgICAgICAgICAgICdDb2luRGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW4nLFxuICAgICAgICAgICAgICAgICdDcmVhdGVDb3Vwb24nLFxuICAgICAgICAgICAgICAgICdSZWRlZW1Db3Vwb24nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdmZWVzJzoge1xuICAgICAgICAndHJhZGluZyc6IHtcbiAgICAgICAgICAgICdtYWtlcic6IDAuMDAxLFxuICAgICAgICAgICAgJ3Rha2VyJzogMC4wMDI1LFxuICAgICAgICB9LFxuICAgICAgICAnZnVuZGluZyc6IDAuMCxcbiAgICB9LFxuXG4gICAgY2FsY3VsYXRlRmVlUmF0ZSAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlLCB0YWtlck9yTWFrZXIgPSAndGFrZXInLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQga2V5ID0gKHNpZGUgPT0gJ3NlbGwnKSA/ICdxdW90ZScgOiAnYmFzZSc7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNbc3ltYm9sXTtcbiAgICAgICAgcmV0dXJuIHsgJ2N1cnJlbmN5JzogbWFya2V0W2tleV0sICdyYXRlJzogbWFya2V0W3Rha2VyT3JNYWtlcl0gfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRJbmZvICgpO1xuICAgICAgICBsZXQgbWFya2V0cyA9IHJlc3BvbnNlWydwYWlycyddO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBiYXNlID0gYmFzZS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIHF1b3RlID0gcXVvdGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgYmFzZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYXNlKTtcbiAgICAgICAgICAgIHF1b3RlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKHF1b3RlKTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5leHRlbmQgKHRoaXMuZmVlc1sndHJhZGluZyddLCB7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ3Rha2VyJzogbWFya2V0WydmZWUnXSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSByZXNwb25zZVsncmV0dXJuJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgbGV0IGZ1bmRzID0gYmFsYW5jZXNbJ2Z1bmRzJ107XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGZ1bmRzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgLy8gdGhleSBtaXNzcGVsbCBEQVNIIGFzIGRzaCA6L1xuICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICB1cHBlcmNhc2UgPSAnREFTSCc7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZ1bmRzW2N1cnJlbmN5XSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBmdW5kc1tjdXJyZW5jeV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W3VwcGVyY2FzZV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXREZXB0aFBhaXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGlmIChtYXJrZXRbJ2lkJ10gaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVttYXJrZXRbJ2lkJ11dO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgICAgICAgICByZXN1bHRbJ2JpZHMnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2JpZHMnXSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXN1bHRbJ2Fza3MnXSA9IHRoaXMuc29ydEJ5IChyZXN1bHRbJ2Fza3MnXSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgbWFya2V0WydzeW1ib2wnXSArICcgb3JkZXIgYm9vayBpcyBlbXB0eSBvciBub3QgYXZhaWxhYmxlJyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGlja2VyWyd1cGRhdGVkJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2hpZ2gnKSxcbiAgICAgICAgICAgICdsb3cnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbG93JyksXG4gICAgICAgICAgICAnYmlkJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2J1eScpLFxuICAgICAgICAgICAgJ2Fzayc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdzZWxsJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnbGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYXZnJyksXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICd2b2xfY3VyJyksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAndm9sJyksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzIChzeW1ib2xzID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBpZHMgPSAoc3ltYm9scykgPyB0aGlzLm1hcmtldElkcyAoc3ltYm9scykgOiB0aGlzLmlkcztcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlclBhaXIgKHtcbiAgICAgICAgICAgICdwYWlyJzogaWRzLmpvaW4gKCctJyksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNba107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBpZCA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLmZldGNoVGlja2VycyAoWyBpZCBdKTtcbiAgICAgICAgcmV0dXJuIHRpY2tlcnNbc3ltYm9sXTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYXNrJykgPyAnc2VsbCcgOiAnYnV5JztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXSxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2lkJ107XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzUGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbaWRdLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXR1cm4nXVsnb3JkZXJfaWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyKSB7XG4gICAgICAgIGxldCBzdGF0dXNDb2RlID0gb3JkZXJbJ3N0YXR1cyddO1xuICAgICAgICBsZXQgc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PSAwKSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnb3Blbic7XG4gICAgICAgIH0gZWxzZSBpZiAoKHN0YXR1c0NvZGUgPT0gMikgfHwgKHN0YXR1c0NvZGUgPT0gMykpIHtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdjYW5jZWxlZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0dXMgPSAnY2xvc2VkJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJbJ3RpbWVzdGFtcF9jcmVhdGVkJ10gKiAxMDAwO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW29yZGVyWydwYWlyJ11dO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgJ3NpZGUnOiBvcmRlclsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogb3JkZXJbJ3JhdGUnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiBvcmRlclsnc3RhcnRfYW1vdW50J10sXG4gICAgICAgICAgICAncmVtYWluaW5nJzogb3JkZXJbJ2Ftb3VudCddLFxuICAgICAgICAgICAgJ3N0YXR1cyc6IHN0YXR1cyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcGFyc2VPcmRlcnMgKG9yZGVycywgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAob3JkZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG9yZGVyID0gb3JkZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBleHRlbmRlZCA9IHRoaXMuZXh0ZW5kIChvcmRlciwgeyAnaWQnOiBpZCB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh0aGlzLnBhcnNlT3JkZXIgKGV4dGVuZGVkLCBtYXJrZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyIChpZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJJbmZvICh7ICdvcmRlcl9pZCc6IGlkIH0pO1xuICAgICAgICBsZXQgb3JkZXIgPSByZXNwb25zZVsncmV0dXJuJ11baWRdO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyICh0aGlzLmV4dGVuZCAoeyAnaWQnOiBpZCB9LCBvcmRlcikpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9wZW5PcmRlcnMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKCFzeW1ib2wpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgcmVxdWlyZXMgYSBzeW1ib2wnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QWN0aXZlT3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmV0dXJuJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXdDb2luICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2NvaW5OYW1lJzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgICAgICdhZGRyZXNzJzogYWRkcmVzcyxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3JldHVybiddWyd0SWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIHVybCArPSAgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnbWV0aG9kJzogcGF0aCxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3MnIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVsnc3VjY2VzcyddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgbHVubyA9IHtcblxuICAgICdpZCc6ICdsdW5vJyxcbiAgICAnbmFtZSc6ICdsdW5vJyxcbiAgICAnY291bnRyaWVzJzogWyAnR0InLCAnU0cnLCAnWkEnIF0sXG4gICAgJ3JhdGVMaW1pdCc6IDMwMDAsXG4gICAgJ3ZlcnNpb24nOiAnMScsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjYwNy04YzFhNjlkOC01ZWRlLTExZTctOTMwYy01NDBiNWViOWJlMjQuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL2FwaS5teWJpdHguY29tL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cubHVuby5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lmx1bm8uY29tL2VuL2FwaScsXG4gICAgICAgICAgICAnaHR0cHM6Ly9ucG1qcy5vcmcvcGFja2FnZS9iaXR4JyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vYmF1c21laWVyL25vZGUtYml0eCcsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0vcGVuZGluZycsXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzL3tpZH0vdHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2ZlZV9pbmZvJyxcbiAgICAgICAgICAgICAgICAnZnVuZGluZ19hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnbGlzdG9yZGVycycsXG4gICAgICAgICAgICAgICAgJ2xpc3R0cmFkZXMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgJ3F1b3Rlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd2Fscy97aWR9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdwb3N0b3JkZXInLFxuICAgICAgICAgICAgICAgICdtYXJrZXRvcmRlcicsXG4gICAgICAgICAgICAgICAgJ3N0b3BvcmRlcicsXG4gICAgICAgICAgICAgICAgJ2Z1bmRpbmdfYWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3YWxzJyxcbiAgICAgICAgICAgICAgICAnc2VuZCcsXG4gICAgICAgICAgICAgICAgJ3F1b3RlcycsXG4gICAgICAgICAgICAgICAgJ29hdXRoMi9ncmFudCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAncXVvdGVzL3tpZH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgJ3F1b3Rlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdhbHMve2lkfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VycyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHNbJ3RpY2tlcnMnXS5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbJ3RpY2tlcnMnXVtwXTtcbiAgICAgICAgICAgIGxldCBpZCA9IG1hcmtldFsncGFpciddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBpZC5zbGljZSAoMywgNik7XG4gICAgICAgICAgICBiYXNlID0gdGhpcy5jb21tb25DdXJyZW5jeUNvZGUgKGJhc2UpO1xuICAgICAgICAgICAgcXVvdGUgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAocXVvdGUpO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZUdldEJhbGFuY2UgKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydiYWxhbmNlJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChiYWxhbmNlWydhc3NldCddKTtcbiAgICAgICAgICAgIGxldCByZXNlcnZlZCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ3Jlc2VydmVkJ10pO1xuICAgICAgICAgICAgbGV0IHVuY29uZmlybWVkID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsndW5jb25maXJtZWQnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2JhbGFuY2UnXSksXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB0aGlzLnN1bSAocmVzZXJ2ZWQsIHVuY29uZmlybWVkKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiAwLjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWNjb3VudFsndG90YWwnXSA9IHRoaXMuc3VtIChhY2NvdW50WydmcmVlJ10sIGFjY291bnRbJ3VzZWQnXSk7XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWyd0aW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnYmlkcycsICdhc2tzJywgJ3ByaWNlJywgJ3ZvbHVtZScpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3RyYWRlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsncm9sbGluZ18yNF9ob3VyX3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlcnMgKCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gdGhpcy5pbmRleEJ5IChyZXNwb25zZVsndGlja2VycyddLCAncGFpcicpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRpY2tlciAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCBzaWRlID0gKHRyYWRlWydpc19idXknXSkgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdHJhZGVbJ3RpbWVzdGFtcCddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsndGltZXN0YW1wJ10pLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsndm9sdW1lJ10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VHJhZGVzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3RyYWRlcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAobWFya2V0LCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JztcbiAgICAgICAgbGV0IG9yZGVyID0geyAncGFpcic6IHRoaXMubWFya2V0SWQgKG1hcmtldCkgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnTWFya2V0b3JkZXInO1xuICAgICAgICAgICAgb3JkZXJbJ3R5cGUnXSA9IHNpZGUudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICBpZiAoc2lkZSA9PSAnYnV5JylcbiAgICAgICAgICAgICAgICBvcmRlclsnY291bnRlcl92b2x1bWUnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsnYmFzZV92b2x1bWUnXSA9IGFtb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnT3JkZXInO1xuICAgICAgICAgICAgb3JkZXJbJ3ZvbHVtZSddID0gYW1vdW50O1xuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgICAgIGlmIChzaWRlID09ICdidXknKVxuICAgICAgICAgICAgICAgIG9yZGVyWyd0eXBlJ10gPSAnQklEJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcmRlclsndHlwZSddID0gJ0FTSyc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RTdG9wb3JkZXIgKHsgJ29yZGVyX2lkJzogaWQgfSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzIChxdWVyeSkubGVuZ3RoKVxuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBsZXQgYXV0aCA9IHRoaXMuZW5jb2RlICh0aGlzLmFwaUtleSArICc6JyArIHRoaXMuc2VjcmV0KTtcbiAgICAgICAgICAgIGF1dGggPSB0aGlzLnN0cmluZ1RvQmFzZTY0IChhdXRoKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogJ0Jhc2ljICcgKyB0aGlzLmRlY29kZSAoYXV0aCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3InIGluIHJlc3BvbnNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBtZXJjYWRvID0ge1xuXG4gICAgJ2lkJzogJ21lcmNhZG8nLFxuICAgICduYW1lJzogJ01lcmNhZG8gQml0Y29pbicsXG4gICAgJ2NvdW50cmllcyc6ICdCUicsIC8vIEJyYXppbFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YzJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4MzcwNjAtZTdjNTg3MTQtNjBlYS0xMWU3LTkxOTItZjA1ZTg2YWRiODNmLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLm5ldC9hcGknLFxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly93d3cubWVyY2Fkb2JpdGNvaW4ubmV0L3RhcGknLFxuICAgICAgICB9LFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLmNvbS5icicsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly93d3cubWVyY2Fkb2JpdGNvaW4uY29tLmJyL2FwaS1kb2MnLFxuICAgICAgICAgICAgJ2h0dHBzOi8vd3d3Lm1lcmNhZG9iaXRjb2luLmNvbS5ici90cmFkZS1hcGknLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbIC8vIGxhc3Qgc2xhc2ggY3JpdGljYWxcbiAgICAgICAgICAgICAgICAnb3JkZXJib29rLycsXG4gICAgICAgICAgICAgICAgJ29yZGVyYm9va19saXRlY29pbi8nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIvJyxcbiAgICAgICAgICAgICAgICAndGlja2VyX2xpdGVjb2luLycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy8nLFxuICAgICAgICAgICAgICAgICd0cmFkZXNfbGl0ZWNvaW4vJyxcbiAgICAgICAgICAgICAgICAndjIvdGlja2VyLycsXG4gICAgICAgICAgICAgICAgJ3YyL3RpY2tlcl9saXRlY29pbi8nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAnZ2V0X2FjY291bnRfaW5mbycsXG4gICAgICAgICAgICAgICAgJ2dldF9vcmRlcicsXG4gICAgICAgICAgICAgICAgJ2dldF93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAnbGlzdF9zeXN0ZW1fbWVzc2FnZXMnLFxuICAgICAgICAgICAgICAgICdsaXN0X29yZGVycycsXG4gICAgICAgICAgICAgICAgJ2xpc3Rfb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAncGxhY2VfYnV5X29yZGVyJyxcbiAgICAgICAgICAgICAgICAncGxhY2Vfc2VsbF9vcmRlcicsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2NvaW4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0JSTCc6IHsgJ2lkJzogJ0JSTEJUQycsICdzeW1ib2wnOiAnQlRDL0JSTCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdCUkwnLCAnc3VmZml4JzogJycgfSxcbiAgICAgICAgJ0xUQy9CUkwnOiB7ICdpZCc6ICdCUkxMVEMnLCAnc3ltYm9sJzogJ0xUQy9CUkwnLCAnYmFzZSc6ICdMVEMnLCAncXVvdGUnOiAnQlJMJywgJ3N1ZmZpeCc6ICdMaXRlY29pbicgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldE9yZGVyYm9vaycgKyB0aGlzLmNhcGl0YWxpemUgKG1hcmtldFsnc3VmZml4J10pO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdIChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9yZGVyQm9vayAob3JkZXJib29rKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0VjJUaWNrZXInICsgdGhpcy5jYXBpdGFsaXplIChtYXJrZXRbJ3N1ZmZpeCddKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICgpO1xuICAgICAgICBsZXQgdGlja2VyID0gcmVzcG9uc2VbJ3RpY2tlciddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsnZGF0ZSddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydkYXRlJ10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsndHlwZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0VHJhZGVzJyArIHRoaXMuY2FwaXRhbGl6ZSAobWFya2V0WydzdWZmaXgnXSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRBY2NvdW50SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2UnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlXVsnYXZhaWxhYmxlJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2VdWyd0b3RhbCddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ21hcmtldCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgYWxsb3dzIGxpbWl0IG9yZGVycyBvbmx5Jyk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3RQbGFjZScgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpICsgJ09yZGVyJztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2NvaW5fcGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgICAgICAnbGltaXRfcHJpY2UnOiBwcmljZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXNwb25zZV9kYXRhJ11bJ29yZGVyJ11bJ29yZGVyX2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXVthcGldICsgJy8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCArPSB0aGlzLnZlcnNpb24gKyAnLyc7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICd0YXBpX21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3RhcGlfbm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSAnL3RhcGkvJyArIHRoaXMudmVyc2lvbiArICcvJyArICc/JyArIGJvZHk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnVEFQSS1JRCc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdUQVBJLU1BQyc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGF1dGgpLCB0aGlzLnNlY3JldCwgJ3NoYTUxMicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3JfbWVzc2FnZScgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIG1peGNvaW5zID0ge1xuXG4gICAgJ2lkJzogJ21peGNvaW5zJyxcbiAgICAnbmFtZSc6ICdNaXhDb2lucycsXG4gICAgJ2NvdW50cmllcyc6IFsgJ0dCJywgJ0hLJyBdLFxuICAgICdyYXRlTGltaXQnOiAxNTAwLFxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzMwMjM3MjEyLWVkMjkzMDNjLTk1MzUtMTFlNy04YWY4LWZjZDM4MWNmYTIwYy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vbWl4Y29pbnMuY29tL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly9taXhjb2lucy5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vbWl4Y29pbnMuY29tL2hlbHAvYXBpLycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnY2FuY2VsJyxcbiAgICAgICAgICAgICAgICAnaW5mbycsXG4gICAgICAgICAgICAgICAgJ29yZGVycycsXG4gICAgICAgICAgICAgICAgJ29yZGVyJyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y191c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnQkNIL0JUQyc6IHsgJ2lkJzogJ2JjY19idGMnLCAnc3ltYm9sJzogJ0JDSC9CVEMnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnTFNLL0JUQyc6IHsgJ2lkJzogJ2xza19idGMnLCAnc3ltYm9sJzogJ0xTSy9CVEMnLCAnYmFzZSc6ICdMU0snLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnQkNIL1VTRCc6IHsgJ2lkJzogJ2JjY191c2QnLCAnc3ltYm9sJzogJ0JDSC9VU0QnLCAnYmFzZSc6ICdCQ0gnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnRVRIL1VTRCc6IHsgJ2lkJzogJ2V0aF91c2QnLCAnc3ltYm9sJzogJ0VUSC9VU0QnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RJbmZvICgpO1xuICAgICAgICBsZXQgYmFsYW5jZSA9IHJlc3BvbnNlWydyZXN1bHQnXVsnd2FsbGV0J107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSBwYXJzZUZsb2F0IChiYWxhbmNlW2xvd2VyY2FzZV1bJ2F2YWlsJ10pO1xuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbbG93ZXJjYXNlXVsnbG9jayddKTtcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChyZXNwb25zZVsncmVzdWx0J10pO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsncmVzdWx0J107XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2J1eSddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3NlbGwnXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRyYWRlWydkYXRlJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0ICh0cmFkZVsncHJpY2UnXSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAodHJhZGVbJ2Ftb3VudCddKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdtYXJrZXQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ3Jlc3VsdCddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnbWFya2V0JzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgICAgICdvcCc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0Jykge1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IDE7XG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3JkZXJbJ29yZGVyX3R5cGUnXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFRyYWRlICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydyZXN1bHQnXVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsICh7ICdpZCc6IGlkIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aDtcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzIChwYXJhbXMpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ1NpZ24nOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChib2R5KSwgdGhpcy5zZWNyZXQsICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddID09IDIwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIG5vdmEgPSB7XG5cbiAgICAnaWQnOiAnbm92YScsXG4gICAgJ25hbWUnOiAnTm92YWV4Y2hhbmdlJyxcbiAgICAnY291bnRyaWVzJzogJ1RaJywgLy8gVGFuemFuaWFcbiAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAndmVyc2lvbic6ICd2MicsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDUxODU3MS03OGNhMGJjYS05YjhhLTExZTctODg0MC02NGI4M2E0YTk0YjIuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL25vdmFleGNoYW5nZS5jb20vcmVtb3RlJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL25vdmFleGNoYW5nZS5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vbm92YWV4Y2hhbmdlLmNvbS9yZW1vdGUvZmFxJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdtYXJrZXRzLycsXG4gICAgICAgICAgICAgICAgJ21hcmtldHMve2Jhc2VjdXJyZW5jeX0nLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvaW5mby97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L29yZGVyaGlzdG9yeS97cGFpcn0vJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0L29wZW5vcmRlcnMve3BhaXJ9L2J1eS8nLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbm9yZGVycy97cGFpcn0vc2VsbC8nLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbm9yZGVycy97cGFpcn0vYm90aC8nLFxuICAgICAgICAgICAgICAgICdtYXJrZXQvb3Blbm9yZGVycy97cGFpcn0ve29yZGVydHlwZX0vJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2dldGJhbGFuY2VzLycsXG4gICAgICAgICAgICAgICAgJ2dldGJhbGFuY2Uve2N1cnJlbmN5fS8nLFxuICAgICAgICAgICAgICAgICdnZXRkZXBvc2l0cy8nLFxuICAgICAgICAgICAgICAgICdnZXR3aXRoZHJhd2Fscy8nLFxuICAgICAgICAgICAgICAgICdnZXRuZXdkZXBvc2l0YWRkcmVzcy97Y3VycmVuY3l9LycsXG4gICAgICAgICAgICAgICAgJ2dldGRlcG9zaXRhZGRyZXNzL3tjdXJyZW5jeX0vJyxcbiAgICAgICAgICAgICAgICAnbXlvcGVub3JkZXJzLycsXG4gICAgICAgICAgICAgICAgJ215b3Blbm9yZGVyc19tYXJrZXQve3BhaXJ9LycsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbG9yZGVyL3tvcmRlcmlkfS8nLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhdy97Y3VycmVuY3l9LycsXG4gICAgICAgICAgICAgICAgJ3RyYWRlL3twYWlyfS8nLFxuICAgICAgICAgICAgICAgICd0cmFkZWhpc3RvcnkvJyxcbiAgICAgICAgICAgICAgICAnZ2V0ZGVwb3NpdGhpc3RvcnkvJyxcbiAgICAgICAgICAgICAgICAnZ2V0d2l0aGRyYXdhbGhpc3RvcnkvJyxcbiAgICAgICAgICAgICAgICAnd2FsbGV0c3RhdHVzLycsXG4gICAgICAgICAgICAgICAgJ3dhbGxldHN0YXR1cy97Y3VycmVuY3l9LycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXRzID0gcmVzcG9uc2VbJ21hcmtldHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW2ldO1xuICAgICAgICAgICAgaWYgKCFtYXJrZXRbJ2Rpc2FibGVkJ10pIHtcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ21hcmtldG5hbWUnXTtcbiAgICAgICAgICAgICAgICBsZXQgWyBxdW90ZSwgYmFzZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3Blbm9yZGVyc1BhaXJCb3RoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5b3JkZXJzJywgJ3NlbGxvcmRlcnMnLCAncHJpY2UnLCAnYW1vdW50Jyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRJbmZvUGFpciAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHJlc3BvbnNlWydtYXJrZXRzJ11bMF07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaDI0aCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdzI0aCddKSxcbiAgICAgICAgICAgICdiaWQnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnYmlkJyksXG4gICAgICAgICAgICAnYXNrJzogdGhpcy5zYWZlRmxvYXQgKHRpY2tlciwgJ2FzaycpLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnY2hhbmdlMjRoJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2x1bWUyNGgnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3VuaXhfdF9kYXRlc3RhbXAnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29yZGVyJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHRyYWRlWyd0cmFkZXR5cGUnXS50b0xvd2VyQ2FzZSAoKSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0TWFya2V0T3JkZXJoaXN0b3J5UGFpciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdwYWlyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlWydpdGVtcyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRiYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgbG9ja2JveCA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF9sb2NrYm94J10pO1xuICAgICAgICAgICAgbGV0IHRyYWRlcyA9IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90cmFkZXMnXSk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudCddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHRoaXMuc3VtIChsb2NrYm94LCB0cmFkZXMpLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2Ftb3VudF90b3RhbCddKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgYW1vdW50ID0gYW1vdW50LnRvU3RyaW5nICgpO1xuICAgICAgICBwcmljZSA9IHByaWNlLnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlciA9IHtcbiAgICAgICAgICAgICd0cmFkZXR5cGUnOiBzaWRlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3RyYWRlYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3RyYWRlcHJpY2UnOiBwcmljZSxcbiAgICAgICAgICAgICd0cmFkZWJhc2UnOiAxLFxuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZVBhaXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2Vsb3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJyArIHRoaXMudmVyc2lvbiArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpXG4gICAgICAgICAgICB1cmwgKz0gYXBpICsgJy8nO1xuICAgICAgICB1cmwgKz0gdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHsgJ25vbmNlJzogbm9uY2UgfSk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAodXJsKSwgdGhpcy5lbmNvZGUgKHRoaXMuc2VjcmV0KSwgJ3NoYTUxMicsICdiYXNlNjQnKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpa2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH0sIHF1ZXJ5KSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2VbJ3N0YXR1cyddICE9ICdzdWNjZXNzJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9LQ29pblxuLy8gQ2hpbmFcbi8vIGh0dHBzOi8vd3d3Lm9rY29pbi5jb20vXG4vLyBodHRwczovL3d3dy5va2NvaW4uY29tL3Jlc3RfZ2V0U3RhcnRlZC5odG1sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vT0tDb2luL3dlYnNvY2tldFxuLy8gaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb2tjb2luLmNvbVxuLy8gaHR0cHM6Ly93d3cub2tjb2luLmNuXG4vLyBodHRwczovL3d3dy5va2NvaW4uY24vcmVzdF9nZXRTdGFydGVkLmh0bWxcblxudmFyIG9rY29pbiA9IHtcblxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCwgLy8gdXAgdG8gMzAwMCByZXF1ZXN0cyBwZXIgNSBtaW51dGVzIOKJiCA2MDAgcmVxdWVzdHMgcGVyIG1pbnV0ZSDiiYggMTAgcmVxdWVzdHMgcGVyIHNlY29uZCDiiYggMTAwIG1zXG4gICAgJ2hhc0ZldGNoT0hMQ1YnOiB0cnVlLFxuICAgICd0aW1lZnJhbWVzJzoge1xuICAgICAgICAnMW0nOiAnMW1pbicsXG4gICAgICAgICczbSc6ICczbWluJyxcbiAgICAgICAgJzVtJzogJzVtaW4nLFxuICAgICAgICAnMTVtJzogJzE1bWluJyxcbiAgICAgICAgJzMwbSc6ICczMG1pbicsXG4gICAgICAgICcxaCc6ICcxaG91cicsXG4gICAgICAgICcyaCc6ICcyaG91cicsXG4gICAgICAgICc0aCc6ICc0aG91cicsXG4gICAgICAgICc2aCc6ICc2aG91cicsXG4gICAgICAgICcxMmgnOiAnMTJob3VyJyxcbiAgICAgICAgJzFkJzogJzFkYXknLFxuICAgICAgICAnM2QnOiAnM2RheScsXG4gICAgICAgICcxdyc6ICcxd2VlaycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnZGVwdGgnLFxuICAgICAgICAgICAgICAgICdleGNoYW5nZV9yYXRlJyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX2RlcHRoJyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX2VzdGltYXRlZF9wcmljZScsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9ob2xkX2Ftb3VudCcsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9pbmRleCcsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9rbGluZScsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9wcmljZV9saW1pdCcsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV90aWNrZXInLFxuICAgICAgICAgICAgICAgICdmdXR1cmVfdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAna2xpbmUnLFxuICAgICAgICAgICAgICAgICdvdGNzJyxcbiAgICAgICAgICAgICAgICAndGlja2VyJyxcbiAgICAgICAgICAgICAgICAndHJhZGVzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ2FjY291bnRfcmVjb3JkcycsXG4gICAgICAgICAgICAgICAgJ2JhdGNoX3RyYWRlJyxcbiAgICAgICAgICAgICAgICAnYm9ycm93X21vbmV5JyxcbiAgICAgICAgICAgICAgICAnYm9ycm93X29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICdib3Jyb3dzX2luZm8nLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfYm9ycm93JyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX290Y19vcmRlcicsXG4gICAgICAgICAgICAgICAgJ2NhbmNlbF93aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9iYXRjaF90cmFkZScsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9jYW5jZWwnLFxuICAgICAgICAgICAgICAgICdmdXR1cmVfZGV2b2x2ZScsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9leHBsb3NpdmUnLFxuICAgICAgICAgICAgICAgICdmdXR1cmVfb3JkZXJfaW5mbycsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9vcmRlcnNfaW5mbycsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9wb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgJ2Z1dHVyZV9wb3NpdGlvbl80Zml4JyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX3RyYWRlJyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX3RyYWRlc19oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX3VzZXJpbmZvJyxcbiAgICAgICAgICAgICAgICAnZnV0dXJlX3VzZXJpbmZvXzRmaXgnLFxuICAgICAgICAgICAgICAgICdsZW5kX2RlcHRoJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfZmVlJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfaGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICdvcmRlcnNfaW5mbycsXG4gICAgICAgICAgICAgICAgJ290Y19vcmRlcl9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnb3RjX29yZGVyX2luZm8nLFxuICAgICAgICAgICAgICAgICdyZXBheW1lbnQnLFxuICAgICAgICAgICAgICAgICdzdWJtaXRfb3RjX29yZGVyJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAndHJhZGVfb3RjX29yZGVyJyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd19pbmZvJyxcbiAgICAgICAgICAgICAgICAndW5yZXBheW1lbnRzX2luZm8nLFxuICAgICAgICAgICAgICAgICd1c2VyaW5mbycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmUnO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICB9XG4gICAgICAgIG1ldGhvZCArPSAnRGVwdGgnO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogb3JkZXJib29rWydiaWRzJ10sXG4gICAgICAgICAgICAnYXNrcyc6IHRoaXMuc29ydEJ5IChvcmRlcmJvb2tbJ2Fza3MnXSwgMCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRpY2tlclsndGltZXN0YW1wJ107XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3B1YmxpY0dldCc7XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ1RpY2tlcic7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAocmVxdWVzdCk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAocmVzcG9uc2VbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgdGlja2VyID0gdGhpcy5leHRlbmQgKHJlc3BvbnNlWyd0aWNrZXInXSwgeyAndGltZXN0YW1wJzogdGltZXN0YW1wIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpXG4gICAgICAgICAgICBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0cmFkZVsnZGF0ZV9tcyddLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0cmFkZVsnZGF0ZV9tcyddKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsnYW1vdW50J10pLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICB9O1xuICAgICAgICBpZiAobWFya2V0WydmdXR1cmUnXSkge1xuICAgICAgICAgICAgbWV0aG9kICs9ICdGdXR1cmUnO1xuICAgICAgICAgICAgcmVxdWVzdFsnY29udHJhY3RfdHlwZSddID0gJ3RoaXNfd2Vlayc7IC8vIG5leHRfd2VlaywgcXVhcnRlclxuICAgICAgICB9XG4gICAgICAgIG1ldGhvZCArPSAnVHJhZGVzJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPSExDViAoc3ltYm9sLCB0aW1lZnJhbWUgPSAnMW0nLCBzaW5jZSA9IHVuZGVmaW5lZCwgbGltaXQgPSAxNDQwLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHVibGljR2V0JztcbiAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydpZCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLnRpbWVmcmFtZXNbdGltZWZyYW1lXSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIHJlcXVlc3RbJ2NvbnRyYWN0X3R5cGUnXSA9ICd0aGlzX3dlZWsnOyAvLyBuZXh0X3dlZWssIHF1YXJ0ZXJcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ0tsaW5lJztcbiAgICAgICAgaWYgKGxpbWl0KVxuICAgICAgICAgICAgcmVxdWVzdFsnc2l6ZSddID0gcGFyc2VJbnQgKGxpbWl0KTtcbiAgICAgICAgaWYgKHNpbmNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gc2luY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0WydzaW5jZSddID0gdGhpcy5taWxsaXNlY29uZHMgKCkgLSA4NjQwMDAwMDsgLy8gbGFzdCAyNCBob3Vyc1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHJlcXVlc3QsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2UsIG1hcmtldCwgdGltZWZyYW1lLCBzaW5jZSwgbGltaXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RVc2VyaW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2luZm8nXVsnZnVuZHMnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiByZXNwb25zZSB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBhY2NvdW50WydmcmVlJ10gPSB0aGlzLnNhZmVGbG9hdCAoYmFsYW5jZXNbJ2ZyZWUnXSwgbG93ZXJjYXNlLCAwLjApO1xuICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gdGhpcy5zYWZlRmxvYXQgKGJhbGFuY2VzWydmcmVlemVkJ10sIGxvd2VyY2FzZSwgMC4wKTtcbiAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSB0aGlzLnN1bSAoYWNjb3VudFsnZnJlZSddLCBhY2NvdW50Wyd1c2VkJ10pO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgbWV0aG9kID0gJ3ByaXZhdGVQb3N0JztcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICd0eXBlJzogc2lkZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1hcmtldFsnZnV0dXJlJ10pIHtcbiAgICAgICAgICAgIG1ldGhvZCArPSAnRnV0dXJlJztcbiAgICAgICAgICAgIG9yZGVyID0gdGhpcy5leHRlbmQgKG9yZGVyLCB7XG4gICAgICAgICAgICAgICAgJ2NvbnRyYWN0X3R5cGUnOiAndGhpc193ZWVrJywgLy8gbmV4dF93ZWVrLCBxdWFydGVyXG4gICAgICAgICAgICAgICAgJ21hdGNoX3ByaWNlJzogMCwgLy8gbWF0Y2ggYmVzdCBjb3VudGVyIHBhcnR5IHByaWNlPyAwIG9yIDEsIGlnbm9yZXMgcHJpY2UgaWYgMVxuICAgICAgICAgICAgICAgICdsZXZlcl9yYXRlJzogMTAsIC8vIGxldmVyYWdlIHJhdGUgdmFsdWU6IDEwIG9yIDIwICgxMCBieSBkZWZhdWx0KVxuICAgICAgICAgICAgICAgICdwcmljZSc6IHByaWNlLFxuICAgICAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICAgICAgICAgIG9yZGVyWydhbW91bnQnXSA9IGFtb3VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXJbJ3R5cGUnXSArPSAnX21hcmtldCc7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPT0gJ2J1eScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJbJ2Ftb3VudCddID0gYW1vdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgKz0gJ1RyYWRlJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9ICcvJyArICdhcGknICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgcGF0aCArICcuZG8nO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHBhcmFtcykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMua2V5c29ydCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAnYXBpX2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgICAgICAvLyBzZWNyZXQga2V5IG11c3QgYmUgYXQgdGhlIGVuZCBvZiBxdWVyeVxuICAgICAgICAgICAgbGV0IHF1ZXJ5U3RyaW5nID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KSArICcmc2VjcmV0X2tleT0nICsgdGhpcy5zZWNyZXQ7XG4gICAgICAgICAgICBxdWVyeVsnc2lnbiddID0gdGhpcy5oYXNoICh0aGlzLmVuY29kZSAocXVlcnlTdHJpbmcpKS50b1VwcGVyQ2FzZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnIH07XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gdGhpcy51cmxzWydhcGknXSArIHVybDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ3Jlc3VsdCcgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWydyZXN1bHQnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIG9rY29pbmNueSA9IGV4dGVuZCAob2tjb2luLCB7XG4gICAgJ2lkJzogJ29rY29pbmNueScsXG4gICAgJ25hbWUnOiAnT0tDb2luIENOWScsXG4gICAgJ2NvdW50cmllcyc6ICdDTicsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njc5Mi04YmU5MTU3YS01ZWU1LTExZTctOTI2Yy02ZDY5YjhkMzM3OGQuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5va2NvaW4uY24nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3Lm9rY29pbi5jbicsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly93d3cub2tjb2luLmNuL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0NOWSc6IHsgJ2lkJzogJ2J0Y19jbnknLCAnc3ltYm9sJzogJ0JUQy9DTlknLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICdMVEMvQ05ZJzogeyAnaWQnOiAnbHRjX2NueScsICdzeW1ib2wnOiAnTFRDL0NOWScsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICAgICAgJ0VUSC9DTlknOiB7ICdpZCc6ICdldGhfY255JywgJ3N5bWJvbCc6ICdFVEgvQ05ZJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0NOWScsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAnRVRDL0NOWSc6IHsgJ2lkJzogJ2V0Y19jbnknLCAnc3ltYm9sJzogJ0VUQy9DTlknLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQ05ZJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICdCQ0gvQ05ZJzogeyAnaWQnOiAnYmNjX2NueScsICdzeW1ib2wnOiAnQkNIL0NOWScsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdDTlknLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICB9LFxufSlcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgb2tjb2ludXNkID0gZXh0ZW5kIChva2NvaW4sIHtcbiAgICAnaWQnOiAnb2tjb2ludXNkJyxcbiAgICAnbmFtZSc6ICdPS0NvaW4gVVNEJyxcbiAgICAnY291bnRyaWVzJzogWyAnQ04nLCAnVVMnIF0sXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2Njc5MS04OWZmYjUwMi01ZWU1LTExZTctOGE1Yi1jNTk1MGI2OGFjNjUuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5va2NvaW4uY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy5va2NvaW4uY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3d3dy5va2NvaW4uY29tL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9va2NvaW4uY29tJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y191c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICdMVEMvVVNEJzogeyAnaWQnOiAnbHRjX3VzZCcsICdzeW1ib2wnOiAnTFRDL1VTRCcsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdVU0QnLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICAgICAgJ0VUSC9VU0QnOiB7ICdpZCc6ICdldGhfdXNkJywgJ3N5bWJvbCc6ICdFVEgvVVNEJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ1VTRCcsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAnRVRDL1VTRCc6IHsgJ2lkJzogJ2V0Y191c2QnLCAnc3ltYm9sJzogJ0VUQy9VU0QnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnVVNEJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIG9rZXggPSBleHRlbmQgKG9rY29pbiwge1xuICAgICdpZCc6ICdva2V4JyxcbiAgICAnbmFtZSc6ICdPS0VYJyxcbiAgICAnY291bnRyaWVzJzogWyAnQ04nLCAnVVMnIF0sXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yOTU2MjU5My05MDM4YTliYy04NzQyLTExZTctOTFjYy04MjAxZjg0NWJmYzEuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3d3dy5va2V4LmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cub2tleC5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3Lm9rZXguY29tL3Jlc3RfZ2V0U3RhcnRlZC5odG1sJyxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y191c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJywgJ3R5cGUnOiAnZnV0dXJlJywgJ3Nwb3QnOiBmYWxzZSwgJ2Z1dHVyZSc6IHRydWUgfSxcbiAgICAgICAgJ0xUQy9VU0QnOiB7ICdpZCc6ICdsdGNfdXNkJywgJ3N5bWJvbCc6ICdMVEMvVVNEJywgJ2Jhc2UnOiAnTFRDJywgJ3F1b3RlJzogJ1VTRCcsICd0eXBlJzogJ2Z1dHVyZScsICdzcG90JzogZmFsc2UsICdmdXR1cmUnOiB0cnVlIH0sXG4gICAgICAgICdMVEMvQlRDJzogeyAnaWQnOiAnbHRjX2J0YycsICdzeW1ib2wnOiAnTFRDL0JUQycsICdiYXNlJzogJ0xUQycsICdxdW90ZSc6ICdCVEMnLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICAgICAgJ0VUSC9CVEMnOiB7ICdpZCc6ICdldGhfYnRjJywgJ3N5bWJvbCc6ICdFVEgvQlRDJywgJ2Jhc2UnOiAnRVRIJywgJ3F1b3RlJzogJ0JUQycsICd0eXBlJzogJ3Nwb3QnLCAnc3BvdCc6IHRydWUsICdmdXR1cmUnOiBmYWxzZSB9LFxuICAgICAgICAnRVRDL0JUQyc6IHsgJ2lkJzogJ2V0Y19idGMnLCAnc3ltYm9sJzogJ0VUQy9CVEMnLCAnYmFzZSc6ICdFVEMnLCAncXVvdGUnOiAnQlRDJywgJ3R5cGUnOiAnc3BvdCcsICdzcG90JzogdHJ1ZSwgJ2Z1dHVyZSc6IGZhbHNlIH0sXG4gICAgICAgICdCQ0gvQlRDJzogeyAnaWQnOiAnYmNjX2J0YycsICdzeW1ib2wnOiAnQkNIL0JUQycsICdiYXNlJzogJ0JDSCcsICdxdW90ZSc6ICdCVEMnLCAndHlwZSc6ICdzcG90JywgJ3Nwb3QnOiB0cnVlLCAnZnV0dXJlJzogZmFsc2UgfSxcbiAgICB9LFxuXG4gICAgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdEZ1dHVyZUNhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcl9pZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxufSlcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgcGF5bWl1bSA9IHtcblxuICAgICdpZCc6ICdwYXltaXVtJyxcbiAgICAnbmFtZSc6ICdQYXltaXVtJyxcbiAgICAnY291bnRyaWVzJzogWyAnRlInLCAnRVUnIF0sXG4gICAgJ3JhdGVMaW1pdCc6IDIwMDAsXG4gICAgJ3ZlcnNpb24nOiAndjEnLFxuICAgICdoYXNDT1JTJzogdHJ1ZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc5MDU2NC1hOTQ1YTlkNC01ZmY5LTExZTctOWQyZC1iNjM1NzYzZjJmMjQuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3BheW1pdW0uY29tL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucGF5bWl1bS5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9QYXltaXVtL2FwaS1kb2N1bWVudGF0aW9uJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5wYXltaXVtLmNvbS9wYWdlL2RldmVsb3BlcnMnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2NvdW50cmllcycsXG4gICAgICAgICAgICAgICAgJ2RhdGEve2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICdkYXRhL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0YS97aWR9L2RlcHRoJyxcbiAgICAgICAgICAgICAgICAnYml0Y29pbl9jaGFydHMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICdiaXRjb2luX2NoYXJ0cy97aWR9L2RlcHRoJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdwcml2YXRlJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnbWVyY2hhbnQvZ2V0X3BheW1lbnQve1VVSUR9JyxcbiAgICAgICAgICAgICAgICAndXNlcicsXG4gICAgICAgICAgICAgICAgJ3VzZXIvYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAndXNlci9hZGRyZXNzZXMve2J0Y19hZGRyZXNzfScsXG4gICAgICAgICAgICAgICAgJ3VzZXIvb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAndXNlci9vcmRlcnMve1VVSUR9JyxcbiAgICAgICAgICAgICAgICAndXNlci9wcmljZV9hbGVydHMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICd1c2VyL29yZGVycycsXG4gICAgICAgICAgICAgICAgJ3VzZXIvYWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAndXNlci9wYXltZW50X3JlcXVlc3RzJyxcbiAgICAgICAgICAgICAgICAndXNlci9wcmljZV9hbGVydHMnLFxuICAgICAgICAgICAgICAgICdtZXJjaGFudC9jcmVhdGVfcGF5bWVudCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ2RlbGV0ZSc6IFtcbiAgICAgICAgICAgICAgICAndXNlci9vcmRlcnMve1VVSUR9L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ3VzZXIvcHJpY2VfYWxlcnRzL3tpZH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0VVUic6IHsgJ2lkJzogJ2V1cicsICdzeW1ib2wnOiAnQlRDL0VVUicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdFVVInIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0VXNlciAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMuY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gdGhpcy5jdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGxvd2VyY2FzZSA9IGN1cnJlbmN5LnRvTG93ZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLmFjY291bnQgKCk7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9ICdiYWxhbmNlXycgKyBsb3dlcmNhc2U7XG4gICAgICAgICAgICBsZXQgbG9ja2VkID0gJ2xvY2tlZF8nICsgbG93ZXJjYXNlO1xuICAgICAgICAgICAgaWYgKGJhbGFuY2UgaW4gYmFsYW5jZXMpXG4gICAgICAgICAgICAgICAgYWNjb3VudFsnZnJlZSddID0gYmFsYW5jZXNbYmFsYW5jZV07XG4gICAgICAgICAgICBpZiAobG9ja2VkIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGFjY291bnRbJ3VzZWQnXSA9IGJhbGFuY2VzW2xvY2tlZF07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERhdGFJZERlcHRoICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAobWFya2V0KSB7XG4gICAgICAgIGxldCB0aWNrZXIgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERhdGFJZFRpY2tlciAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAobWFya2V0KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ2F0J10gKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Z3YXAnXSksXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydwcmljZSddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndmFyaWF0aW9uJ10pLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsndm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50ICh0cmFkZVsnY3JlYXRlZF9hdF9pbnQnXSkgKiAxMDAwO1xuICAgICAgICBsZXQgdm9sdW1lID0gJ3RyYWRlZF8nICsgbWFya2V0WydiYXNlJ10udG9Mb3dlckNhc2UgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ3V1aWQnXSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbdm9sdW1lXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldERhdGFJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ3R5cGUnOiB0aGlzLmNhcGl0YWxpemUgKHR5cGUpICsgJ09yZGVyJyxcbiAgICAgICAgICAgICdjdXJyZW5jeSc6IHRoaXMubWFya2V0SWQgKG1hcmtldCksXG4gICAgICAgICAgICAnZGlyZWN0aW9uJzogc2lkZSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFVzZXJPcmRlcnMgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3V1aWQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsT3JkZXIgKGlkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcml2YXRlUG9zdENhbmNlbE9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyTnVtYmVyJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLmpzb24gKHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybCArIGJvZHk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdBcGktS2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ0FwaS1TaWduYXR1cmUnOiB0aGlzLmhtYWMgKHRoaXMuZW5jb2RlIChhdXRoKSwgdGhpcy5zZWNyZXQpLFxuICAgICAgICAgICAgICAgICdBcGktTm9uY2UnOiBub25jZSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnZXJyb3JzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyAnICsgdGhpcy5qc29uIChyZXNwb25zZSkpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgcG9sb25pZXggPSB7XG5cbiAgICAnaWQnOiAncG9sb25pZXgnLFxuICAgICduYW1lJzogJ1BvbG9uaWV4JyxcbiAgICAnY291bnRyaWVzJzogJ1VTJyxcbiAgICAncmF0ZUxpbWl0JzogNTAwLCAvLyB1cCA2IGNhbGxzIHBlciBzZWNvbmRcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4MTctZTk0NTYzMTItNWVlNi0xMWU3LTliM2MtYjYyOGNhNTYyNmE1LmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vcG9sb25pZXguY29tL3B1YmxpYycsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL3BvbG9uaWV4LmNvbS90cmFkaW5nQXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3BvbG9uaWV4LmNvbScsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cHM6Ly9wb2xvbmlleC5jb20vc3VwcG9ydC9hcGkvJyxcbiAgICAgICAgICAgICdodHRwOi8vcGFzdGViaW4uY29tL2RNWDdtWkUwJyxcbiAgICAgICAgXSxcbiAgICAgICAgJ2ZlZXMnOiAnaHR0cHM6Ly9wb2xvbmlleC5jb20vZmVlcycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAncmV0dXJuMjRoVm9sdW1lJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuQ2hhcnREYXRhJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuQ3VycmVuY2llcycsXG4gICAgICAgICAgICAgICAgJ3JldHVybkxvYW5PcmRlcnMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5PcmRlckJvb2snLFxuICAgICAgICAgICAgICAgICdyZXR1cm5UaWNrZXInLFxuICAgICAgICAgICAgICAgICdyZXR1cm5UcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYnV5JyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsTG9hbk9mZmVyJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdjbG9zZU1hcmdpblBvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAnY3JlYXRlTG9hbk9mZmVyJyxcbiAgICAgICAgICAgICAgICAnZ2VuZXJhdGVOZXdBZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnZ2V0TWFyZ2luUG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICdtYXJnaW5CdXknLFxuICAgICAgICAgICAgICAgICdtYXJnaW5TZWxsJyxcbiAgICAgICAgICAgICAgICAnbW92ZU9yZGVyJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuQWN0aXZlTG9hbnMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5BdmFpbGFibGVBY2NvdW50QmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5CYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgJ3JldHVybkNvbXBsZXRlQmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5EZXBvc2l0QWRkcmVzc2VzJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuRGVwb3NpdHNXaXRoZHJhd2FscycsXG4gICAgICAgICAgICAgICAgJ3JldHVybkZlZUluZm8nLFxuICAgICAgICAgICAgICAgICdyZXR1cm5MZW5kaW5nSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ3JldHVybk1hcmdpbkFjY291bnRTdW1tYXJ5JyxcbiAgICAgICAgICAgICAgICAncmV0dXJuT3BlbkxvYW5PZmZlcnMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5PcGVuT3JkZXJzJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuT3JkZXJUcmFkZXMnLFxuICAgICAgICAgICAgICAgICdyZXR1cm5UcmFkYWJsZUJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAncmV0dXJuVHJhZGVIaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnc2VsbCcsXG4gICAgICAgICAgICAgICAgJ3RvZ2dsZUF1dG9SZW5ldycsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZmVyQmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAnZmVlcyc6IHtcbiAgICAgICAgJ3RyYWRpbmcnOiB7XG4gICAgICAgICAgICAnbWFrZXInOiAwLjAwMTUsXG4gICAgICAgICAgICAndGFrZXInOiAwLjAwMjUsXG4gICAgICAgIH0sXG4gICAgICAgICdmdW5kaW5nJzogMC4wLFxuICAgIH0sXG5cbiAgICBjYWxjdWxhdGVGZWVSYXRlIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UsIHRha2VyT3JNYWtlciA9ICd0YWtlcicsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBrZXkgPSAoc2lkZSA9PSAnc2VsbCcpID8gJ3F1b3RlJyA6ICdiYXNlJztcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c1tzeW1ib2xdO1xuICAgICAgICByZXR1cm4geyAnY3VycmVuY3knOiBtYXJrZXRba2V5XSwgJ3JhdGUnOiBtYXJrZXRbdGFrZXJPck1ha2VyXSB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVGlja2VyICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1tpZF07XG4gICAgICAgICAgICBsZXQgWyBxdW90ZSwgYmFzZSBdID0gaWQuc3BsaXQgKCdfJyk7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHRoaXMuZXh0ZW5kICh0aGlzLmZlZXNbJ3RyYWRpbmcnXSwge1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybkNvbXBsZXRlQmFsYW5jZXMgKHtcbiAgICAgICAgICAgICdhY2NvdW50JzogJ2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGxldCBjdXJyZW5jaWVzID0gT2JqZWN0LmtleXMgKGJhbGFuY2VzKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBjdXJyZW5jaWVzW2NdO1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tjdXJyZW5jeV07XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ2F2YWlsYWJsZSddKSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHBhcnNlRmxvYXQgKGJhbGFuY2VbJ29uT3JkZXJzJ10pLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IDAuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gdGhpcy5zdW0gKGFjY291bnRbJ2ZyZWUnXSwgYWNjb3VudFsndXNlZCddKTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoRmVlcyAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGZlZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuRmVlSW5mbyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogZmVlcyxcbiAgICAgICAgICAgICdtYWtlcic6IHBhcnNlRmxvYXQgKGZlZXNbJ21ha2VyRmVlJ10pLFxuICAgICAgICAgICAgJ3Rha2VyJzogcGFyc2VGbG9hdCAoZmVlc1sndGFrZXJGZWUnXSksXG4gICAgICAgICAgICAnd2l0aGRyYXcnOiAwLjAsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFJldHVybk9yZGVyQm9vayAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gyNGhyJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93MjRociddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2hlc3RCaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dlc3RBc2snXSksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xhc3QnXSksXG4gICAgICAgICAgICAnY2hhbmdlJzogcGFyc2VGbG9hdCAodGlja2VyWydwZXJjZW50Q2hhbmdlJ10pLFxuICAgICAgICAgICAgJ3BlcmNlbnRhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXZlcmFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydiYXNlVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWydxdW90ZVZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVGlja2VyICgpO1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaWQgPSBpZHNbaV07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRSZXR1cm5UaWNrZXIgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW21hcmtldFsnaWQnXV07XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZSddKTtcbiAgICAgICAgbGV0IGlkID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgb3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzeW1ib2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgIH0gZWxzZSBpZiAoJ2N1cnJlbmN5UGFpcicgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXRJZCA9IHRyYWRlWydjdXJyZW5jeVBhaXInXTtcbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMubWFya2V0c19ieV9pZFttYXJrZXRJZF1bJ3N5bWJvbCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgndHJhZGVJRCcgaW4gdHJhZGUpXG4gICAgICAgICAgICBpZCA9IHRyYWRlWyd0cmFkZUlEJ107XG4gICAgICAgIGlmICgnb3JkZXJOdW1iZXInIGluIHRyYWRlKVxuICAgICAgICAgICAgb3JkZXIgPSB0cmFkZVsnb3JkZXJOdW1iZXInXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydyYXRlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRyYWRlcyA9IGF3YWl0IHRoaXMucHVibGljR2V0UmV0dXJuVHJhZGVIaXN0b3J5ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5UGFpcic6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdlbmQnOiB0aGlzLnNlY29uZHMgKCksIC8vIGxhc3QgNTAwMDAgdHJhZGVzIGJ5IGRlZmF1bHRcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTXlUcmFkZXMgKHN5bWJvbCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN5bWJvbClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcGFpciA9IG1hcmtldCA/IG1hcmtldFsnaWQnXSA6ICdhbGwnO1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogcGFpcixcbiAgICAgICAgICAgICdlbmQnOiB0aGlzLnNlY29uZHMgKCksIC8vIGxhc3QgNTAwMDAgdHJhZGVzIGJ5IGRlZmF1bHRcbiAgICAgICAgfSwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVyblRyYWRlSGlzdG9yeSAocmVxdWVzdCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYXJrZXQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0geyAnaW5mbyc6IHJlc3BvbnNlIH07XG4gICAgICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbaWRdLCBtYXJrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRyYWRlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdyZXN1bHRpbmdUcmFkZXMnIGluIG9yZGVyKVxuICAgICAgICAgICAgdHJhZGVzID0gdGhpcy5wYXJzZVRyYWRlcyAob3JkZXJbJ3Jlc3VsdGluZ1RyYWRlcyddLCBtYXJrZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiBvcmRlcixcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydvcmRlck51bWJlciddLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IG9yZGVyWyd0aW1lc3RhbXAnXSxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAob3JkZXJbJ3RpbWVzdGFtcCddKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiBvcmRlclsnc3RhdHVzJ10sXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKG9yZGVyWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0IChvcmRlclsnYW1vdW50J10pLFxuICAgICAgICAgICAgJ3RyYWRlcyc6IHRyYWRlcyxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VPcGVuT3JkZXJzIChvcmRlcnMsIG1hcmtldCwgcmVzdWx0ID0gW10pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBvcmRlciA9IG9yZGVyc1tpXTtcbiAgICAgICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAob3JkZXJbJ2RhdGUnXSk7XG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWQgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHtcbiAgICAgICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICdzaWRlJzogb3JkZXJbJ3R5cGUnXSxcbiAgICAgICAgICAgICAgICAncHJpY2UnOiBvcmRlclsncmF0ZSddLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5wYXJzZU9yZGVyIChleHRlbmRlZCwgbWFya2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzeW1ib2wpXG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHBhaXIgPSBtYXJrZXQgPyBtYXJrZXRbJ2lkJ10gOiAnYWxsJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFJldHVybk9wZW5PcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lQYWlyJzogcGFpcixcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAobWFya2V0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVuT3JkZXJzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzIChyZXNwb25zZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBvcmRlcnMgPSByZXNwb25zZVtpZF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW2lkXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBtYXJrZXRbJ3N5bWJvbCddO1xuICAgICAgICAgICAgdGhpcy5wYXJzZU9wZW5PcmRlcnMgKG9yZGVycywgbWFya2V0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJTdGF0dXMgKGlkLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcGVuT3JkZXJzIChtYXJrZXQpO1xuICAgICAgICBsZXQgaW5kZXhlZCA9IHRoaXMuaW5kZXhCeSAob3JkZXJzLCAnaWQnKTtcbiAgICAgICAgcmV0dXJuIChpZCBpbiBpbmRleGVkKSA/ICdvcGVuJyA6ICdjbG9zZWQnO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZSA9PSAnbWFya2V0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBhbGxvd3MgbGltaXQgb3JkZXJzIG9ubHknKTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXNbbWV0aG9kXSAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdjdXJyZW5jeVBhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgICAgICAncmF0ZSc6IHByaWNlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0gdGhpcy5wYXJzZU9yZGVyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAndHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiBwYXJzZUZsb2F0IChwcmljZSksXG4gICAgICAgICAgICAnYW1vdW50JzogcGFyc2VGbG9hdCAoYW1vdW50KSxcbiAgICAgICAgfSwgcmVzcG9uc2UpLCBtYXJrZXQpO1xuICAgICAgICBsZXQgaWQgPSBvcmRlclsnaWQnXTtcbiAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gb3JkZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuZCAoeyAnaW5mbyc6IHJlc3BvbnNlIH0sIG9yZGVyKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlciAoaWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVycyA9IGF3YWl0IHRoaXMuZmV0Y2hPcGVuT3JkZXJzICgpO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmluZGV4QnkgKG9yZGVycywgJ2lkJyk7XG4gICAgICAgIGlmIChpZCBpbiBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdID0gaW5kZXhbaWRdO1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4W2lkXTtcbiAgICAgICAgfSBlbHNlIGlmIChpZCBpbiB0aGlzLm9yZGVycykge1xuICAgICAgICAgICAgdGhpcy5vcmRlcnNbaWRdWydzdGF0dXMnXSA9ICdjbG9zZWQnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgb3JkZXIgJyArIGlkICsgJyBub3QgZm91bmQnKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlclRyYWRlcyAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0cmFkZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0UmV0dXJuT3JkZXJUcmFkZXMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJOdW1iZXInOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzICh0cmFkZXMpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJOdW1iZXInOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFdpdGhkcmF3ICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2N1cnJlbmN5JzogY3VycmVuY3ksXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2FkZHJlc3MnOiBhZGRyZXNzLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogcmVzdWx0LFxuICAgICAgICAgICAgJ2lkJzogcmVzdWx0WydyZXNwb25zZSddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7ICdjb21tYW5kJzogcGF0aCB9LCBwYXJhbXMpO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5Wydub25jZSddID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgICAgIGJvZHkgPSB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ0tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdTaWduJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSkge1xuICAgICAgICAgICAgbGV0IGVycm9yID0gdGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpO1xuICAgICAgICAgICAgbGV0IGZhaWxlZCA9IHJlc3BvbnNlWydlcnJvciddLmluZGV4T2YgKCdOb3QgZW5vdWdoJykgPj0gMDtcbiAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudEZ1bmRzIChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBxdWFkcmlnYWN4ID0ge1xuXG4gICAgJ2lkJzogJ3F1YWRyaWdhY3gnLFxuICAgICduYW1lJzogJ1F1YWRyaWdhQ1gnLFxuICAgICdjb3VudHJpZXMnOiAnQ0EnLFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4MjUtOThhNmQwZGUtNWVlNy0xMWU3LTlmYTQtMzhlMTFhMmM2ZjUyLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXVhZHJpZ2FjeC5jb20nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnF1YWRyaWdhY3guY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy5xdWFkcmlnYWN4LmNvbS9hcGlfaW5mbycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcicsXG4gICAgICAgICAgICAgICAgJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAnYml0Y29pbl9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdiaXRjb2luX3dpdGhkcmF3YWwnLFxuICAgICAgICAgICAgICAgICdidXknLFxuICAgICAgICAgICAgICAgICdjYW5jZWxfb3JkZXInLFxuICAgICAgICAgICAgICAgICdldGhlcl9kZXBvc2l0X2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdldGhlcl93aXRoZHJhd2FsJyxcbiAgICAgICAgICAgICAgICAnbG9va3VwX29yZGVyJyxcbiAgICAgICAgICAgICAgICAnb3Blbl9vcmRlcnMnLFxuICAgICAgICAgICAgICAgICdzZWxsJyxcbiAgICAgICAgICAgICAgICAndXNlcl90cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL0NBRCc6IHsgJ2lkJzogJ2J0Y19jYWQnLCAnc3ltYm9sJzogJ0JUQy9DQUQnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnQ0FEJyB9LFxuICAgICAgICAnQlRDL1VTRCc6IHsgJ2lkJzogJ2J0Y191c2QnLCAnc3ltYm9sJzogJ0JUQy9VU0QnLCAnYmFzZSc6ICdCVEMnLCAncXVvdGUnOiAnVVNEJyB9LFxuICAgICAgICAnRVRIL0JUQyc6IHsgJ2lkJzogJ2V0aF9idGMnLCAnc3ltYm9sJzogJ0VUSC9CVEMnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQlRDJyB9LFxuICAgICAgICAnRVRIL0NBRCc6IHsgJ2lkJzogJ2V0aF9jYWQnLCAnc3ltYm9sJzogJ0VUSC9DQUQnLCAnYmFzZSc6ICdFVEgnLCAncXVvdGUnOiAnQ0FEJyB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IHBhcnNlRmxvYXQgKGJhbGFuY2VzW2xvd2VyY2FzZSArICdfYXZhaWxhYmxlJ10pLFxuICAgICAgICAgICAgICAgICd1c2VkJzogcGFyc2VGbG9hdCAoYmFsYW5jZXNbbG93ZXJjYXNlICsgJ19yZXNlcnZlZCddKSxcbiAgICAgICAgICAgICAgICAndG90YWwnOiBwYXJzZUZsb2F0IChiYWxhbmNlc1tsb3dlcmNhc2UgKyAnX2JhbGFuY2UnXSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJCb29rICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHBhcnNlSW50IChvcmRlcmJvb2tbJ3RpbWVzdGFtcCddKSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICh7XG4gICAgICAgICAgICAnYm9vayc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKHRpY2tlclsndGltZXN0YW1wJ10pICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2JpZCddKSxcbiAgICAgICAgICAgICdhc2snOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2FzayddKSxcbiAgICAgICAgICAgICd2d2FwJzogcGFyc2VGbG9hdCAodGlja2VyWyd2d2FwJ10pLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBwYXJzZVRyYWRlICh0cmFkZSwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSBwYXJzZUludCAodHJhZGVbJ2RhdGUnXSkgKiAxMDAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiB0cmFkZSxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICdpZCc6IHRyYWRlWyd0aWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogcGFyc2VGbG9hdCAodHJhZGVbJ3ByaWNlJ10pLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHBhcnNlRmxvYXQgKHRyYWRlWydhbW91bnQnXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFuc2FjdGlvbnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnYm9vayc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKHN5bWJvbCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9ICdwcml2YXRlUG9zdCcgKyB0aGlzLmNhcGl0YWxpemUgKHNpZGUpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ2Jvb2snOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZSA9PSAnbGltaXQnKVxuICAgICAgICAgICAgb3JkZXJbJ3ByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyBwYXRoO1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBgJyArIHRoaXMuaWQgKyAnLnVpZGAgcHJvcGVydHkgZm9yIGF1dGhlbnRpY2F0aW9uJyk7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSBbIG5vbmNlLnRvU3RyaW5nICgpLCB0aGlzLnVpZCwgdGhpcy5hcGlLZXkgXS5qb2luICgnJyk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAocmVxdWVzdCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICAgICAna2V5JzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ3NpZ25hdHVyZSc6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHF1b2luZSA9IHtcblxuICAgICdpZCc6ICdxdW9pbmUnLFxuICAgICduYW1lJzogJ1FVT0lORScsXG4gICAgJ2NvdW50cmllcyc6IFsgJ0pQJywgJ1NHJywgJ1ZOJyBdLFxuICAgICd2ZXJzaW9uJzogJzInLFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4NDQtOTYxNWE0ZTgtNWVlOC0xMWU3LTg4MTQtZmNkMDA0ZGI4Y2RkLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkucXVvaW5lLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cucXVvaW5lLmNvbScsXG4gICAgICAgICdkb2MnOiAnaHR0cHM6Ly9kZXZlbG9wZXJzLnF1b2luZS5jb20nLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ3Byb2R1Y3RzJyxcbiAgICAgICAgICAgICAgICAncHJvZHVjdHMve2lkfScsXG4gICAgICAgICAgICAgICAgJ3Byb2R1Y3RzL3tpZH0vcHJpY2VfbGV2ZWxzJyxcbiAgICAgICAgICAgICAgICAnZXhlY3V0aW9ucycsXG4gICAgICAgICAgICAgICAgJ2lyX2xhZGRlcnMve2N1cnJlbmN5fScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2FjY291bnRzL2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdjcnlwdG9fYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdleGVjdXRpb25zL21lJyxcbiAgICAgICAgICAgICAgICAnZmlhdF9hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgJ2xvYW5fYmlkcycsXG4gICAgICAgICAgICAgICAgJ2xvYW5zJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzL3tpZH0nLFxuICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgICAgICd0cmFkZXMnLFxuICAgICAgICAgICAgICAgICd0cmFkZXMve2lkfS9sb2FucycsXG4gICAgICAgICAgICAgICAgJ3RyYWRpbmdfYWNjb3VudHMnLFxuICAgICAgICAgICAgICAgICd0cmFkaW5nX2FjY291bnRzL3tpZH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdmaWF0X2FjY291bnRzJyxcbiAgICAgICAgICAgICAgICAnbG9hbl9iaWRzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncHV0JzogW1xuICAgICAgICAgICAgICAgICdsb2FuX2JpZHMve2lkfS9jbG9zZScsXG4gICAgICAgICAgICAgICAgJ2xvYW5zL3tpZH0nLFxuICAgICAgICAgICAgICAgICdvcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgJ29yZGVycy97aWR9L2NhbmNlbCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97aWR9JyxcbiAgICAgICAgICAgICAgICAndHJhZGVzL3tpZH0vY2xvc2UnLFxuICAgICAgICAgICAgICAgICd0cmFkZXMvY2xvc2VfYWxsJyxcbiAgICAgICAgICAgICAgICAndHJhZGluZ19hY2NvdW50cy97aWR9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcm9kdWN0cyAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydpZCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ2Jhc2VfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsncXVvdGVkX2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QWNjb3VudHNCYWxhbmNlICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnYmFsYW5jZSddKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogdG90YWwsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiAwLjAsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdG90YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHNJZFByaWNlTGV2ZWxzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogdGhpcy5tYXJrZXRJZCAoc3ltYm9sKSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHVuZGVmaW5lZCwgJ2J1eV9wcmljZV9sZXZlbHMnLCAnc2VsbF9wcmljZV9sZXZlbHMnKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgbGV0IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgnbGFzdF90cmFkZWRfcHJpY2UnIGluIHRpY2tlcikge1xuICAgICAgICAgICAgaWYgKHRpY2tlclsnbGFzdF90cmFkZWRfcHJpY2UnXSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSB0aWNrZXJbJ2xhc3RfdHJhZGVkX3ByaWNlJ10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gcGFyc2VGbG9hdCAodGlja2VyWydsYXN0X3RyYWRlZF9wcmljZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoX21hcmtldF9hc2snXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3dfbWFya2V0X2JpZCddKSxcbiAgICAgICAgICAgICdiaWQnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ21hcmtldF9iaWQnXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydtYXJrZXRfYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogbGFzdCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV8yNGgnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXJzICgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFByb2R1Y3RzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGlja2Vycy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbdF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHRpY2tlclsnYmFzZV9jdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHF1b3RlID0gdGlja2VyWydxdW90ZWRfY3VycmVuY3knXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXRzW3N5bWJvbF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJvZHVjdHNJZCAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2NyZWF0ZWRfYXQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ2lkJzogdHJhZGVbJ2lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ3Rha2VyX3NpZGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHBhcnNlRmxvYXQgKHRyYWRlWydwcmljZSddKSxcbiAgICAgICAgICAgICdhbW91bnQnOiBwYXJzZUZsb2F0ICh0cmFkZVsncXVhbnRpdHknXSksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRFeGVjdXRpb25zICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3Byb2R1Y3RfaWQnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2VbJ21vZGVscyddLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgb3JkZXIgPSB7XG4gICAgICAgICAgICAnb3JkZXJfdHlwZSc6IHR5cGUsXG4gICAgICAgICAgICAncHJvZHVjdF9pZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncXVhbnRpdHknOiBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlID09ICdsaW1pdCcpXG4gICAgICAgICAgICBvcmRlclsncHJpY2UnXSA9IHByaWNlO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0T3JkZXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ29yZGVyJzogb3JkZXIsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQdXRPcmRlcnNJZENhbmNlbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnWC1RdW9pbmUtQVBJLVZlcnNpb24nOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpID09ICdwdWJsaWMnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgJ3BhdGgnOiB1cmwsXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ3Rva2VuX2lkJzogdGhpcy5hcGlLZXksXG4gICAgICAgICAgICAgICAgJ2lhdCc6IE1hdGguZmxvb3IgKG5vbmNlIC8gMTAwMCksIC8vIGlzc3VlZCBhdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICBoZWFkZXJzWydYLVF1b2luZS1BdXRoJ10gPSB0aGlzLmp3dCAocmVxdWVzdCwgdGhpcy5zZWNyZXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHRoaXMudXJsc1snYXBpJ10gKyB1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHNvdXRoeGNoYW5nZSA9IHtcblxuICAgICdpZCc6ICdzb3V0aHhjaGFuZ2UnLFxuICAgICduYW1lJzogJ1NvdXRoWGNoYW5nZScsXG4gICAgJ2NvdW50cmllcyc6ICdBUicsIC8vIEFyZ2VudGluYVxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc4Mzg5MTItNGY5NGVjOGEtNjBmNi0xMWU3LTllNWQtYmJmOWJkNTBhNTU5LmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly93d3cuc291dGh4Y2hhbmdlLmNvbS9hcGknLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd3d3LnNvdXRoeGNoYW5nZS5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vd3d3LnNvdXRoeGNoYW5nZS5jb20vSG9tZS9BcGknLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ21hcmtldHMnLFxuICAgICAgICAgICAgICAgICdwcmljZS97c3ltYm9sfScsXG4gICAgICAgICAgICAgICAgJ3ByaWNlcycsXG4gICAgICAgICAgICAgICAgJ2Jvb2sve3N5bWJvbH0nLFxuICAgICAgICAgICAgICAgICd0cmFkZXMve3N5bWJvbH0nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnY2FuY2VsTWFya2V0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdnZW5lcmF0ZW5ld2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdsaXN0T3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnbGlzdEJhbGFuY2VzJyxcbiAgICAgICAgICAgICAgICAncGxhY2VPcmRlcicsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFswXTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IG1hcmtldFsxXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICBsZXQgaWQgPSBzeW1ib2w7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0TGlzdEJhbGFuY2VzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydDdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnVwcGVyY2FzZTtcbiAgICAgICAgICAgIGxldCBmcmVlID0gcGFyc2VGbG9hdCAoYmFsYW5jZVsnQXZhaWxhYmxlJ10pO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSBwYXJzZUZsb2F0IChiYWxhbmNlWydVbmNvbmZpcm1lZCddKTtcbiAgICAgICAgICAgIGxldCB0b3RhbCA9IHRoaXMuc3VtIChmcmVlLCB1c2VkKTtcbiAgICAgICAgICAgIGxldCBhY2NvdW50ID0ge1xuICAgICAgICAgICAgICAgICdmcmVlJzogZnJlZSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IHVzZWQsXG4gICAgICAgICAgICAgICAgJ3RvdGFsJzogdG90YWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0Qm9va1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnQnV5T3JkZXJzJywgJ1NlbGxPcmRlcnMnLCAnUHJpY2UnLCAnQW1vdW50Jyk7XG4gICAgfSxcblxuICAgIHBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbG93JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2JpZCc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdCaWQnKSxcbiAgICAgICAgICAgICdhc2snOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnQXNrJyksXG4gICAgICAgICAgICAndndhcCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdvcGVuJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Nsb3NlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2ZpcnN0JzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2xhc3QnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnTGFzdCcpLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHRoaXMuc2FmZUZsb2F0ICh0aWNrZXIsICdWYXJpYXRpb24yNEhyJyksXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aGlzLnNhZmVGbG9hdCAodGlja2VyLCAnVm9sdW1lMjRIcicpLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VycyAoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0UHJpY2VzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IHRoaXMuaW5kZXhCeSAocmVzcG9uc2UsICdNYXJrZXQnKTtcbiAgICAgICAgbGV0IGlkcyA9IE9iamVjdC5rZXlzICh0aWNrZXJzKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGlkID0gaWRzW2ldO1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW2lkXTtcbiAgICAgICAgICAgIHJlc3VsdFtzeW1ib2xdID0gdGhpcy5wYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VyID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRQcmljZVN5bWJvbCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRyYWRlWydBdCddICogMTAwMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdHJhZGVbJ1R5cGUnXSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydQcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydBbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYWRlc1N5bWJvbCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2xpc3RpbmdDdXJyZW5jeSc6IG1hcmtldFsnYmFzZSddLFxuICAgICAgICAgICAgJ3JlZmVyZW5jZUN1cnJlbmN5JzogbWFya2V0WydxdW90ZSddLFxuICAgICAgICAgICAgJ3R5cGUnOiBzaWRlLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydsaW1pdFByaWNlJ10gPSBwcmljZTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdFBsYWNlT3JkZXIgKHRoaXMuZXh0ZW5kIChvcmRlciwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2UudG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlckNvZGUnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdwdWJsaWMnLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCBxdWVyeSA9IHRoaXMub21pdCAocGFyYW1zLCB0aGlzLmV4dHJhY3RQYXJhbXMgKHBhdGgpKTtcbiAgICAgICAgaWYgKGFwaSA9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ2tleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdub25jZSc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgcXVlcnkpO1xuICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdIYXNoJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYm9keSksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICAvLyBpZiAoIXJlc3BvbnNlKVxuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnICcgKyB0aGlzLmpzb24gKHJlc3BvbnNlKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXJiaXRjb2luID0gZXh0ZW5kIChibGlua3RyYWRlLCB7XG4gICAgJ2lkJzogJ3N1cmJpdGNvaW4nLFxuICAgICduYW1lJzogJ1N1ckJpdGNvaW4nLFxuICAgICdjb3VudHJpZXMnOiAnVkUnLFxuICAgICdoYXNDT1JTJzogZmFsc2UsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc5OTE1MTEtZjBhNTAxOTQtNjQ4MS0xMWU3LTk5YjUtOGYwMjkzMjQyNGNjLmpwZycsXG4gICAgICAgICdhcGknOiB7XG4gICAgICAgICAgICAncHVibGljJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL2FwaScsXG4gICAgICAgICAgICAncHJpdmF0ZSc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS90YXBpJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3N1cmJpdGNvaW4uY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAnQmxpbmt0cmFkZSBBUEknLFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1ZFRic6IHsgJ2lkJzogJ0JUQ1ZFRicsICdzeW1ib2wnOiAnQlRDL1ZFRicsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdWRUYnLCAnYnJva2VySWQnOiAxLCAnYnJva2VyJzogJ1N1ckJpdGNvaW4nIH0sXG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHRoZXJvY2sgPSB7XG5cbiAgICAnaWQnOiAndGhlcm9jaycsXG4gICAgJ25hbWUnOiAnVGhlUm9ja1RyYWRpbmcnLFxuICAgICdjb3VudHJpZXMnOiAnTVQnLFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODY5LTc1MDU3ZmEyLTVlZTktMTFlNy05YTZmLTEzZTY0MWZhNDcwNy5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLnRoZXJvY2t0cmFkaW5nLmNvbScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly90aGVyb2NrdHJhZGluZy5jb20nLFxuICAgICAgICAnZG9jJzogW1xuICAgICAgICAgICAgJ2h0dHBzOi8vYXBpLnRoZXJvY2t0cmFkaW5nLmNvbS9kb2MvdjEvaW5kZXguaHRtbCcsXG4gICAgICAgICAgICAnaHR0cHM6Ly9hcGkudGhlcm9ja3RyYWRpbmcuY29tL2RvYy8nLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tpZH0vb3JkZXJib29rJyxcbiAgICAgICAgICAgICAgICAnZnVuZHMve2lkfS90aWNrZXInLFxuICAgICAgICAgICAgICAgICdmdW5kcy97aWR9L3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3RpY2tlcnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdiYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgJ2JhbGFuY2VzL3tpZH0nLFxuICAgICAgICAgICAgICAgICdkaXNjb3VudHMnLFxuICAgICAgICAgICAgICAgICdkaXNjb3VudHMve2lkfScsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzJyxcbiAgICAgICAgICAgICAgICAnZnVuZHMve2lkfScsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tpZH0vdHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnZnVuZHMve2Z1bmRfaWR9L29yZGVycycsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9wb3NpdGlvbl9iYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9wb3NpdGlvbnMnLFxuICAgICAgICAgICAgICAgICdmdW5kcy97ZnVuZF9pZH0vcG9zaXRpb25zL3tpZH0nLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMve2lkfScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3X2xpbWl0cy97aWR9JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXdfbGltaXRzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnYXRtcy93aXRoZHJhdycsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMve2lkfScsXG4gICAgICAgICAgICAgICAgJ2Z1bmRzL3tmdW5kX2lkfS9vcmRlcnMvcmVtb3ZlX2FsbCcsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNUaWNrZXJzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0c1sndGlja2VycyddLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sndGlja2VycyddW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydmdW5kX2lkJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IGlkLnNsaWNlICgwLCAzKTtcbiAgICAgICAgICAgIGxldCBxdW90ZSA9IGlkLnNsaWNlICgzLCA2KTtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBiYXNlICsgJy8nICsgcXVvdGU7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2JhbGFuY2VzJ107XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogcmVzcG9uc2UgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ2N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgZnJlZSA9IGJhbGFuY2VbJ3RyYWRpbmdfYmFsYW5jZSddO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gYmFsYW5jZVsnYmFsYW5jZSddO1xuICAgICAgICAgICAgbGV0IHVzZWQgPSB0b3RhbCAtIGZyZWU7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEZ1bmRzSWRPcmRlcmJvb2sgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLm1hcmtldElkIChzeW1ib2wpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxIChvcmRlcmJvb2tbJ2RhdGUnXSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJCb29rIChvcmRlcmJvb2ssIHRpbWVzdGFtcCwgJ2JpZHMnLCAnYXNrcycsICdwcmljZScsICdhbW91bnQnKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KSB7XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLnBhcnNlODYwMSAodGlja2VyWydkYXRlJ10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogcGFyc2VGbG9hdCAodGlja2VyWydoaWdoJ10pLFxuICAgICAgICAgICAgJ2xvdyc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbG93J10pLFxuICAgICAgICAgICAgJ2JpZCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYmlkJ10pLFxuICAgICAgICAgICAgJ2Fzayc6IHBhcnNlRmxvYXQgKHRpY2tlclsnYXNrJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnY2xvc2UnXSksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnbGFzdCddKSxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZV90cmFkZWQnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3ZvbHVtZSddKSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEZ1bmRzVGlja2VycyAoKTtcbiAgICAgICAgbGV0IHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHJlc3BvbnNlWyd0aWNrZXJzJ10sICdmdW5kX2lkJyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldHNfYnlfaWRbaWRdO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgdGlja2VyID0gdGlja2Vyc1tpZF07XG4gICAgICAgICAgICByZXN1bHRbc3ltYm9sXSA9IHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNJZFRpY2tlciAoe1xuICAgICAgICAgICAgJ2lkJzogbWFya2V0WydpZCddLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFt0cmFkZVsnZnVuZF9pZCddXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnZGF0ZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsnaWQnXS50b1N0cmluZyAoKSxcbiAgICAgICAgICAgICdvcmRlcic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3NpZGUnOiB0cmFkZVsnc2lkZSddLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ3ByaWNlJ10sXG4gICAgICAgICAgICAnYW1vdW50JzogdHJhZGVbJ2Ftb3VudCddLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRyYWRlcyAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0RnVuZHNJZFRyYWRlcyAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJhZGVzIChyZXNwb25zZVsndHJhZGVzJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0RnVuZHNGdW5kSWRPcmRlcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnZnVuZF9pZCc6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3ByaWNlJzogcHJpY2UsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVEZWxldGVGdW5kc0Z1bmRJZE9yZGVyc0lkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddICsgJy8nICsgdGhpcy52ZXJzaW9uICsgJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpLnRvU3RyaW5nICgpO1xuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHVybDtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1gtVFJULUtFWSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgICAgICdYLVRSVC1OT05DRSc6IG5vbmNlLFxuICAgICAgICAgICAgICAgICdYLVRSVC1TSUdOJzogdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGE1MTInKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uIChxdWVyeSk7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9ycycgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHVyZHViaXQgPSBleHRlbmQgKGJsaW5rdHJhZGUsIHtcbiAgICAnaWQnOiAndXJkdWJpdCcsXG4gICAgJ25hbWUnOiAnVXJkdUJpdCcsXG4gICAgJ2NvdW50cmllcyc6ICdQSycsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzk5MTQ1My0xNTZiZjNhZS02NDgwLTExZTctODJlYi03Mjk1ZmUxYjViYjQuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vYXBpJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vYXBpLmJsaW5rdHJhZGUuY29tL3RhcGknLFxuICAgICAgICB9LFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vdXJkdWJpdC5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYmxpbmt0cmFkZS5jb20vZG9jcycsXG4gICAgfSxcbiAgICAnY29tbWVudCc6ICdCbGlua3RyYWRlIEFQSScsXG4gICAgJ21hcmtldHMnOiB7XG4gICAgICAgICdCVEMvUEtSJzogeyAnaWQnOiAnQlRDUEtSJywgJ3N5bWJvbCc6ICdCVEMvUEtSJywgJ2Jhc2UnOiAnQlRDJywgJ3F1b3RlJzogJ1BLUicsICdicm9rZXJJZCc6IDgsICdicm9rZXInOiAnVXJkdUJpdCcgfSxcbiAgICB9LFxufSlcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdmF1bHRvcm8gPSB7XG5cbiAgICAnaWQnOiAndmF1bHRvcm8nLFxuICAgICduYW1lJzogJ1ZhdWx0b3JvJyxcbiAgICAnY291bnRyaWVzJzogJ0NIJyxcbiAgICAncmF0ZUxpbWl0JzogMTAwMCxcbiAgICAndmVyc2lvbic6ICcxJyxcbiAgICAnaGFzQ09SUyc6IHRydWUsXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjc3NjY4ODAtZjIwNWU4NzAtNWVlOS0xMWU3LThmZTItMGQ1YjE1ODgwNzUyLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly9hcGkudmF1bHRvcm8uY29tJyxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy52YXVsdG9yby5jb20nLFxuICAgICAgICAnZG9jJzogJ2h0dHBzOi8vYXBpLnZhdWx0b3JvLmNvbScsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnYmlkYW5kYXNrJyxcbiAgICAgICAgICAgICAgICAnYnV5b3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnbGF0ZXN0JyxcbiAgICAgICAgICAgICAgICAnbGF0ZXN0dHJhZGVzJyxcbiAgICAgICAgICAgICAgICAnbWFya2V0cycsXG4gICAgICAgICAgICAgICAgJ29yZGVyYm9vaycsXG4gICAgICAgICAgICAgICAgJ3NlbGxvcmRlcnMnLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMvZGF5JyxcbiAgICAgICAgICAgICAgICAndHJhbnNhY3Rpb25zL2hvdXInLFxuICAgICAgICAgICAgICAgICd0cmFuc2FjdGlvbnMvbW9udGgnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdiYWxhbmNlJyxcbiAgICAgICAgICAgICAgICAnbXl0cmFkZXMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdidXkve3N5bWJvbH0ve3R5cGV9JyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsL3tpZH0nLFxuICAgICAgICAgICAgICAgICdzZWxsL3tzeW1ib2x9L3t0eXBlfScsXG4gICAgICAgICAgICAgICAgJ3dpdGhkcmF3JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzWydkYXRhJ107XG4gICAgICAgIGxldCBiYXNlID0gbWFya2V0WydCYXNlQ3VycmVuY3knXTtcbiAgICAgICAgbGV0IHF1b3RlID0gbWFya2V0WydNYXJrZXRDdXJyZW5jeSddO1xuICAgICAgICBsZXQgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICBsZXQgYmFzZUlkID0gYmFzZTtcbiAgICAgICAgbGV0IHF1b3RlSWQgPSBxdW90ZTtcbiAgICAgICAgbGV0IGlkID0gbWFya2V0WydNYXJrZXROYW1lJ107XG4gICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICdiYXNlSWQnOiBiYXNlSWQsXG4gICAgICAgICAgICAncXVvdGVJZCc6IHF1b3RlSWQsXG4gICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QmFsYW5jZSAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJhbGFuY2VzLmxlbmd0aDsgYisrKSB7XG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGJhbGFuY2VzW2JdO1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gYmFsYW5jZVsnY3VycmVuY3lfY29kZSddO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGZyZWUgPSBiYWxhbmNlWydjYXNoJ107XG4gICAgICAgICAgICBsZXQgdXNlZCA9IGJhbGFuY2VbJ3Jlc2VydmVkJ107XG4gICAgICAgICAgICBsZXQgdG90YWwgPSB0aGlzLnN1bSAoZnJlZSwgdXNlZCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGZyZWUsXG4gICAgICAgICAgICAgICAgJ3VzZWQnOiB1c2VkLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IHRvdGFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFtjdXJyZW5jeV0gPSBhY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoT3JkZXJCb29rIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHVibGljR2V0T3JkZXJib29rIChwYXJhbXMpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0ge1xuICAgICAgICAgICAgJ2JpZHMnOiByZXNwb25zZVsnZGF0YSddWzBdWydiJ10sXG4gICAgICAgICAgICAnYXNrcyc6IHJlc3BvbnNlWydkYXRhJ11bMV1bJ3MnXSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYmlkcycsICdhc2tzJywgJ0dvbGRfUHJpY2UnLCAnR29sZF9BbW91bnQnKTtcbiAgICAgICAgcmVzdWx0WydiaWRzJ10gPSB0aGlzLnNvcnRCeSAocmVzdWx0WydiaWRzJ10sIDAsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlciAoc3ltYm9sKSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBxdW90ZSA9IGF3YWl0IHRoaXMucHVibGljR2V0QmlkYW5kYXNrICgpO1xuICAgICAgICBsZXQgYmlkc0xlbmd0aCA9IHF1b3RlWydiaWRzJ10ubGVuZ3RoO1xuICAgICAgICBsZXQgYmlkID0gcXVvdGVbJ2JpZHMnXVtiaWRzTGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBhc2sgPSBxdW90ZVsnYXNrcyddWzBdO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldE1hcmtldHMgKCk7XG4gICAgICAgIGxldCB0aWNrZXIgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJzI0aEhpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWycyNGhMb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogYmlkWzBdLFxuICAgICAgICAgICAgJ2Fzayc6IGFza1swXSxcbiAgICAgICAgICAgICd2d2FwJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnTGFzdFByaWNlJ10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnMjRoVm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlVHJhZGUgKHRyYWRlLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMucGFyc2U4NjAxICh0cmFkZVsnVGltZSddKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAnb3JkZXInOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3ByaWNlJzogdHJhZGVbJ0dvbGRfUHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnR29sZF9BbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnB1YmxpY0dldFRyYW5zYWN0aW9uc0RheSAocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlLCBtYXJrZXQpO1xuICAgIH0sXG5cbiAgICBhc3luYyBjcmVhdGVPcmRlciAoc3ltYm9sLCB0eXBlLCBzaWRlLCBhbW91bnQsIHByaWNlID0gdW5kZWZpbmVkLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBtZXRob2QgPSAncHJpdmF0ZVBvc3QnICsgdGhpcy5jYXBpdGFsaXplIChzaWRlKSArICdTeW1ib2xUeXBlJztcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpc1ttZXRob2RdICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsncXVvdGVJZCddLnRvTG93ZXJDYXNlICgpLFxuICAgICAgICAgICAgJ3R5cGUnOiB0eXBlLFxuICAgICAgICAgICAgJ2dsZCc6IGFtb3VudCxcbiAgICAgICAgICAgICdwcmljZSc6IHByaWNlIHx8IDEsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydkYXRhJ11bJ09yZGVyX0lEJ10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxJZCAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdCAocGF0aCwgYXBpID0gJ3B1YmxpYycsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9IHBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgdXJsICs9IHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICAgICAgJ2FwaWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgfSwgdGhpcy5vbWl0IChwYXJhbXMsIHRoaXMuZXh0cmFjdFBhcmFtcyAocGF0aCkpKTtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdYLVNpZ25hdHVyZSc6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKHVybCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCkpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdmJ0YyA9IGV4dGVuZCAoYmxpbmt0cmFkZSwge1xuICAgICdpZCc6ICd2YnRjJyxcbiAgICAnbmFtZSc6ICdWQlRDJyxcbiAgICAnY291bnRyaWVzJzogJ1ZOJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3OTkxNDgxLTFmNTNkMWQ4LTY0ODEtMTFlNy04ODRlLTIxZDE3ZTc5MzlkYi5qcGcnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwczovL2FwaS5ibGlua3RyYWRlLmNvbS9hcGknLFxuICAgICAgICAgICAgJ3ByaXZhdGUnOiAnaHR0cHM6Ly9hcGkuYmxpbmt0cmFkZS5jb20vdGFwaScsXG4gICAgICAgIH0sXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly92YnRjLmV4Y2hhbmdlJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL2JsaW5rdHJhZGUuY29tL2RvY3MnLFxuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiAnQmxpbmt0cmFkZSBBUEknLFxuICAgICdtYXJrZXRzJzoge1xuICAgICAgICAnQlRDL1ZORCc6IHsgJ2lkJzogJ0JUQ1ZORCcsICdzeW1ib2wnOiAnQlRDL1ZORCcsICdiYXNlJzogJ0JUQycsICdxdW90ZSc6ICdWTkQnLCAnYnJva2VySWQnOiAzLCAnYnJva2VyJzogJ1ZCVEMnIH0sXG4gICAgfSxcbn0pXG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdmlyd294ID0ge1xuXG4gICAgJ2lkJzogJ3ZpcndveCcsXG4gICAgJ25hbWUnOiAnVmlyV29YJyxcbiAgICAnY291bnRyaWVzJzogWyAnQVQnLCAnRVUnIF0sXG4gICAgJ3JhdGVMaW1pdCc6IDEwMDAsXG4gICAgJ2hhc0NPUlMnOiB0cnVlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2ODk0LTZkYTlkMzYwLTVlZWEtMTFlNy05MGFhLTQxZjI3MTFiNzQwNS5qcGcnLFxuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ3B1YmxpYyc6ICdodHRwOi8vYXBpLnZpcndveC5jb20vYXBpL2pzb24ucGhwJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd3d3LnZpcndveC5jb20vYXBpL3RyYWRpbmcucGhwJyxcbiAgICAgICAgfSxcbiAgICAgICAgJ3d3dyc6ICdodHRwczovL3d3dy52aXJ3b3guY29tJyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy52aXJ3b3guY29tL2RldmVsb3BlcnMucGhwJyxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdnZXRJbnN0cnVtZW50cycsXG4gICAgICAgICAgICAgICAgJ2dldEJlc3RQcmljZXMnLFxuICAgICAgICAgICAgICAgICdnZXRNYXJrZXREZXB0aCcsXG4gICAgICAgICAgICAgICAgJ2VzdGltYXRlTWFya2V0T3JkZXInLFxuICAgICAgICAgICAgICAgICdnZXRUcmFkZWRQcmljZVZvbHVtZScsXG4gICAgICAgICAgICAgICAgJ2dldFJhd1RyYWRlRGF0YScsXG4gICAgICAgICAgICAgICAgJ2dldFN0YXRpc3RpY3MnLFxuICAgICAgICAgICAgICAgICdnZXRUZXJtaW5hbExpc3QnLFxuICAgICAgICAgICAgICAgICdnZXRHcmlkTGlzdCcsXG4gICAgICAgICAgICAgICAgJ2dldEdyaWRTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnZ2V0SW5zdHJ1bWVudHMnLFxuICAgICAgICAgICAgICAgICdnZXRCZXN0UHJpY2VzJyxcbiAgICAgICAgICAgICAgICAnZ2V0TWFya2V0RGVwdGgnLFxuICAgICAgICAgICAgICAgICdlc3RpbWF0ZU1hcmtldE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnZ2V0VHJhZGVkUHJpY2VWb2x1bWUnLFxuICAgICAgICAgICAgICAgICdnZXRSYXdUcmFkZURhdGEnLFxuICAgICAgICAgICAgICAgICdnZXRTdGF0aXN0aWNzJyxcbiAgICAgICAgICAgICAgICAnZ2V0VGVybWluYWxMaXN0JyxcbiAgICAgICAgICAgICAgICAnZ2V0R3JpZExpc3QnLFxuICAgICAgICAgICAgICAgICdnZXRHcmlkU3RhdGlzdGljcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnZ2V0QmFsYW5jZXMnLFxuICAgICAgICAgICAgICAgICdnZXRDb21taXNzaW9uRGlzY291bnQnLFxuICAgICAgICAgICAgICAgICdnZXRPcmRlcnMnLFxuICAgICAgICAgICAgICAgICdnZXRUcmFuc2FjdGlvbnMnLFxuICAgICAgICAgICAgICAgICdwbGFjZU9yZGVyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncG9zdCc6IFtcbiAgICAgICAgICAgICAgICAnY2FuY2VsT3JkZXInLFxuICAgICAgICAgICAgICAgICdnZXRCYWxhbmNlcycsXG4gICAgICAgICAgICAgICAgJ2dldENvbW1pc3Npb25EaXNjb3VudCcsXG4gICAgICAgICAgICAgICAgJ2dldE9yZGVycycsXG4gICAgICAgICAgICAgICAgJ2dldFRyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgJ3BsYWNlT3JkZXInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hNYXJrZXRzICgpIHtcbiAgICAgICAgbGV0IG1hcmtldHMgPSBhd2FpdCB0aGlzLnB1YmxpY0dldEluc3RydW1lbnRzICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydyZXN1bHQnXSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBrZXlzLmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncmVzdWx0J11ba2V5c1twXV07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ2luc3RydW1lbnRJRCddO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IG1hcmtldFsnc3ltYm9sJ107XG4gICAgICAgICAgICBsZXQgYmFzZSA9IG1hcmtldFsnbG9uZ0N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ3Nob3J0Q3VycmVuY3knXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoICh7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbCc6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAnYmFzZSc6IGJhc2UsXG4gICAgICAgICAgICAgICAgJ3F1b3RlJzogcXVvdGUsXG4gICAgICAgICAgICAgICAgJ2luZm8nOiBtYXJrZXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJhbGFuY2UgKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RHZXRCYWxhbmNlcyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3Jlc3VsdCddWydhY2NvdW50TGlzdCddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYmFsYW5jZXMubGVuZ3RoOyBiKyspIHtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbYl07XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSBiYWxhbmNlWydjdXJyZW5jeSddO1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gYmFsYW5jZVsnYmFsYW5jZSddO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiB0b3RhbCxcbiAgICAgICAgICAgICAgICAndXNlZCc6IDAuMCxcbiAgICAgICAgICAgICAgICAndG90YWwnOiB0b3RhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXN1bHRbY3VycmVuY3ldID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaEJlc3RQcmljZXMgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0QmVzdFByaWNlcyAoe1xuICAgICAgICAgICAgJ3N5bWJvbHMnOiBbIHN5bWJvbCBdLFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNQb3N0R2V0TWFya2V0RGVwdGggKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnc3ltYm9scyc6IFsgc3ltYm9sIF0sXG4gICAgICAgICAgICAnYnV5RGVwdGgnOiAxMDAsXG4gICAgICAgICAgICAnc2VsbERlcHRoJzogMTAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IHJlc3BvbnNlWydyZXN1bHQnXVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdW5kZWZpbmVkLCAnYnV5JywgJ3NlbGwnLCAncHJpY2UnLCAndm9sdW1lJyk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgc3RhcnQgPSBlbmQgLSA4NjQwMDAwMDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZWRQcmljZVZvbHVtZSAoe1xuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBzeW1ib2wsXG4gICAgICAgICAgICAnZW5kRGF0ZSc6IHRoaXMuWW1kSE1TIChlbmQpLFxuICAgICAgICAgICAgJ3N0YXJ0RGF0ZSc6IHRoaXMuWW1kSE1TIChzdGFydCksXG4gICAgICAgICAgICAnSExPQyc6IDEsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgdGlja2VycyA9IHJlc3BvbnNlWydyZXN1bHQnXVsncHJpY2VWb2x1bWVMaXN0J107XG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMgKHRpY2tlcnMpO1xuICAgICAgICBsZXQgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGxldCBsYXN0S2V5ID0ga2V5c1tsZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbGFzdEtleV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHBhcnNlRmxvYXQgKHRpY2tlclsnaGlnaCddKSxcbiAgICAgICAgICAgICdsb3cnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvdyddKSxcbiAgICAgICAgICAgICdiaWQnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYXNrJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHBhcnNlRmxvYXQgKHRpY2tlclsnb3BlbiddKSxcbiAgICAgICAgICAgICdjbG9zZSc6IHBhcnNlRmxvYXQgKHRpY2tlclsnY2xvc2UnXSksXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2xvbmdWb2x1bWUnXSksXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ3Nob3J0Vm9sdW1lJ10pLFxuICAgICAgICAgICAgJ2luZm8nOiB0aWNrZXIsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChtYXJrZXQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnB1YmxpY0dldFJhd1RyYWRlRGF0YSh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiBtYXJrZXQsXG4gICAgICAgICAgICAndGltZXNwYW4nOiAzNjAwLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY3JlYXRlT3JkZXIgKG1hcmtldCwgdHlwZSwgc2lkZSwgYW1vdW50LCBwcmljZSA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyID0ge1xuICAgICAgICAgICAgJ2luc3RydW1lbnQnOiB0aGlzLnN5bWJvbCAobWFya2V0KSxcbiAgICAgICAgICAgICdvcmRlclR5cGUnOiBzaWRlLnRvVXBwZXJDYXNlICgpLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IGFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGUgPT0gJ2xpbWl0JylcbiAgICAgICAgICAgIG9yZGVyWydwcmljZSddID0gcHJpY2U7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RQbGFjZU9yZGVyICh0aGlzLmV4dGVuZCAob3JkZXIsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXNwb25zZSxcbiAgICAgICAgICAgICdpZCc6IHJlc3BvbnNlWydvcmRlcklEJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZVBvc3RDYW5jZWxPcmRlciAodGhpcy5leHRlbmQgKHtcbiAgICAgICAgICAgICdvcmRlcklEJzogaWQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgIH0sXG5cbiAgICBhc3luYyByZXF1ZXN0IChwYXRoLCBhcGkgPSAncHVibGljJywgbWV0aG9kID0gJ0dFVCcsIHBhcmFtcyA9IHt9LCBoZWFkZXJzID0gdW5kZWZpbmVkLCBib2R5ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybHNbJ2FwaSddW2FwaV07XG4gICAgICAgIGxldCBhdXRoID0ge307XG4gICAgICAgIGlmIChhcGkgPT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgICBhdXRoWydrZXknXSA9IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgYXV0aFsndXNlciddID0gdGhpcy5sb2dpbjtcbiAgICAgICAgICAgIGF1dGhbJ3Bhc3MnXSA9IHRoaXMucGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vbmNlID0gdGhpcy5ub25jZSAoKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PSAnR0VUJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgICAgICdtZXRob2QnOiBwYXRoLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSwgYXV0aCwgcGFyYW1zKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzID0geyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH07XG4gICAgICAgICAgICBib2R5ID0gdGhpcy5qc29uICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ3BhcmFtcyc6IHRoaXMuZXh0ZW5kIChhdXRoLCBwYXJhbXMpLFxuICAgICAgICAgICAgICAgICdpZCc6IG5vbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCAodXJsLCBtZXRob2QsIGhlYWRlcnMsIGJvZHkpO1xuICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZVsnZXJyb3InXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHdleCA9IGV4dGVuZCAobGlxdWksIHtcblxuICAgICdpZCc6ICd3ZXgnLFxuICAgICduYW1lJzogJ1dFWCcsXG4gICAgJ2NvdW50cmllcyc6ICdOWicsIC8vIE5ldyBaZWFsYW5kXG4gICAgJ3ZlcnNpb24nOiAnMycsXG4gICAgJ2hhc0ZldGNoVGlja2Vycyc6IHRydWUsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8zMDY1Mjc1MS1kNzRlYzhmOC05ZTMxLTExZTctOThjNS03MTQ2OWZjZWYwM2UuanBnJyxcbiAgICAgICAgJ2FwaSc6IHtcbiAgICAgICAgICAgICdwdWJsaWMnOiAnaHR0cHM6Ly93ZXgubnovYXBpJyxcbiAgICAgICAgICAgICdwcml2YXRlJzogJ2h0dHBzOi8vd2V4Lm56L3RhcGknLFxuICAgICAgICB9LFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vd2V4Lm56JyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3dleC5uei9hcGkvMy9kb2NzJyxcbiAgICAgICAgICAgICdodHRwczovL3dleC5uei90YXBpL2RvY3MnLFxuICAgICAgICBdLFxuICAgIH0sXG4gICAgJ2FwaSc6IHtcbiAgICAgICAgJ3B1YmxpYyc6IHtcbiAgICAgICAgICAgICdnZXQnOiBbXG4gICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAndHJhZGVzL3twYWlyfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAnVHJhZGUnLFxuICAgICAgICAgICAgICAgICdBY3RpdmVPcmRlcnMnLFxuICAgICAgICAgICAgICAgICdPcmRlckluZm8nLFxuICAgICAgICAgICAgICAgICdDYW5jZWxPcmRlcicsXG4gICAgICAgICAgICAgICAgJ1RyYWRlSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ1RyYW5zSGlzdG9yeScsXG4gICAgICAgICAgICAgICAgJ0NvaW5EZXBvc2l0QWRkcmVzcycsXG4gICAgICAgICAgICAgICAgJ1dpdGhkcmF3Q29pbicsXG4gICAgICAgICAgICAgICAgJ0NyZWF0ZUNvdXBvbicsXG4gICAgICAgICAgICAgICAgJ1JlZGVlbUNvdXBvbicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9XG4gICAgfSxcbn0pXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHhidGNlID0ge1xuXG4gICAgJ2lkJzogJ3hidGNlJyxcbiAgICAnbmFtZSc6ICd4QlRDZScsXG4gICAgJ2NvdW50cmllcyc6ICdSVScsXG4gICAgJ3JhdGVMaW1pdCc6IDIwMDAsIC8vIHJlc3BvbnNlcyBhcmUgY2FjaGVkIGV2ZXJ5IDIgc2Vjb25kc1xuICAgICd2ZXJzaW9uJzogJ3YxJyxcbiAgICAnaGFzUHVibGljQVBJJzogZmFsc2UsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAnaGFzRmV0Y2hUaWNrZXJzJzogdHJ1ZSxcbiAgICAnaGFzRmV0Y2hPSExDVic6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI4MDU5NDE0LWUyMzU5NzBjLTY2MmMtMTFlNy04YzNhLTA4ZTMxZjc4Njg0Yi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vY3J5cHRvdHRsaXZld2ViYXBpLnhidGNlLm5ldDo4NDQzL2FwaScsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cueGJ0Y2UuY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3d3dy54YnRjZS5jb20vdHJhZGVhcGknLFxuICAgICAgICAgICAgJ2h0dHBzOi8vc3VwcG9ydC54YnRjZS5pbmZvL0tub3dsZWRnZWJhc2UvQXJ0aWNsZS9WaWV3LzUyLzI1L3hidGNlLWV4Y2hhbmdlLWFwaScsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnY3VycmVuY3knLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeS97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgJ2xldmVsMicsXG4gICAgICAgICAgICAgICAgJ2xldmVsMi97ZmlsdGVyfScsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYXNrJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9iaWQnLFxuICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0vbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICAnc3ltYm9sL3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAndGljaycsXG4gICAgICAgICAgICAgICAgJ3RpY2sve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICd0aWNrZXInLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICd0cmFkZXNlc3Npb24nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICd0cmFkZXNlcnZlcmluZm8nLFxuICAgICAgICAgICAgICAgICd0cmFkZXNlc3Npb24nLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jeScsXG4gICAgICAgICAgICAgICAgJ2N1cnJlbmN5L3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAnbGV2ZWwyJyxcbiAgICAgICAgICAgICAgICAnbGV2ZWwyL3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICAnc3ltYm9sL3tmaWx0ZXJ9JyxcbiAgICAgICAgICAgICAgICAndGljaycsXG4gICAgICAgICAgICAgICAgJ3RpY2sve2ZpbHRlcn0nLFxuICAgICAgICAgICAgICAgICdhY2NvdW50JyxcbiAgICAgICAgICAgICAgICAnYXNzZXQnLFxuICAgICAgICAgICAgICAgICdhc3NldC97aWR9JyxcbiAgICAgICAgICAgICAgICAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICdwb3NpdGlvbi97aWR9JyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICd0cmFkZS97aWR9JyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9hc2snLFxuICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2Fzay9pbmZvJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3twZXJpb2RpY2l0eX0vYmFycy9iaWQnLFxuICAgICAgICAgICAgICAgICdxdW90ZWhpc3Rvcnkve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2JpZC9pbmZvJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS9sZXZlbDIvaW5mbycsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS97c3ltYm9sfS9wZXJpb2RpY2l0aWVzJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3tzeW1ib2x9L3RpY2tzL2luZm8nLFxuICAgICAgICAgICAgICAgICdxdW90ZWhpc3RvcnkvY2FjaGUve3N5bWJvbH0ve3BlcmlvZGljaXR5fS9iYXJzL2FzaycsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9jYWNoZS97c3ltYm9sfS97cGVyaW9kaWNpdHl9L2JhcnMvYmlkJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L2NhY2hlL3tzeW1ib2x9L2xldmVsMicsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9jYWNoZS97c3ltYm9sfS90aWNrcycsXG4gICAgICAgICAgICAgICAgJ3F1b3RlaGlzdG9yeS9zeW1ib2xzJyxcbiAgICAgICAgICAgICAgICAncXVvdGVoaXN0b3J5L3ZlcnNpb24nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICd0cmFkZScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlaGlzdG9yeScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3B1dCc6IFtcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdkZWxldGUnOiBbXG4gICAgICAgICAgICAgICAgJ3RyYWRlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0U3ltYm9sICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWFya2V0cy5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgbGV0IG1hcmtldCA9IG1hcmtldHNbcF07XG4gICAgICAgICAgICBsZXQgaWQgPSBtYXJrZXRbJ1N5bWJvbCddO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBtYXJrZXRbJ01hcmdpbkN1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgcXVvdGUgPSBtYXJrZXRbJ1Byb2ZpdEN1cnJlbmN5J107XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGJhc2UgKyAnLycgKyBxdW90ZTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG1hcmtldFsnSXNUcmFkZUFsbG93ZWQnXSA/IHN5bWJvbCA6IGlkO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0QXNzZXQgKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7ICdpbmZvJzogYmFsYW5jZXMgfTtcbiAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiYWxhbmNlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgbGV0IGJhbGFuY2UgPSBiYWxhbmNlc1tiXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW5jeSA9IGJhbGFuY2VbJ0N1cnJlbmN5J107XG4gICAgICAgICAgICBsZXQgdXBwZXJjYXNlID0gY3VycmVuY3kudG9VcHBlckNhc2UgKCk7XG4gICAgICAgICAgICAvLyB4YnRjZSBuYW1lcyBEQVNIIGluY29ycmVjdGx5IGFzIERTSFxuICAgICAgICAgICAgaWYgKHVwcGVyY2FzZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICB1cHBlcmNhc2UgPSAnREFTSCc7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBiYWxhbmNlWydiYWxhbmNlJ107XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHtcbiAgICAgICAgICAgICAgICAnZnJlZSc6IGJhbGFuY2VbJ0ZyZWVBbW91bnQnXSxcbiAgICAgICAgICAgICAgICAndXNlZCc6IGJhbGFuY2VbJ0xvY2tlZEFtb3VudCddLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2VbJ0Ftb3VudCddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdFt1cHBlcmNhc2VdID0gYWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9yZGVyQm9vayAoc3ltYm9sLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcmJvb2sgPSBhd2FpdCB0aGlzLnByaXZhdGVHZXRMZXZlbDJGaWx0ZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnZmlsdGVyJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgb3JkZXJib29rID0gb3JkZXJib29rWzBdO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gb3JkZXJib29rWydUaW1lc3RhbXAnXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vaywgdGltZXN0YW1wLCAnQmlkcycsICdBc2tzJywgJ1ByaWNlJywgJ1ZvbHVtZScpO1xuICAgIH0sXG5cbiAgICBwYXJzZVRpY2tlciAodGlja2VyLCBtYXJrZXQpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IDA7XG4gICAgICAgIGxldCBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoJ0xhc3RCdXlUaW1lc3RhbXAnIGluIHRpY2tlcilcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXAgPCB0aWNrZXJbJ0xhc3RCdXlUaW1lc3RhbXAnXSkge1xuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IHRpY2tlclsnTGFzdEJ1eVRpbWVzdGFtcCddO1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0aWNrZXJbJ0xhc3RCdXlQcmljZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoJ0xhc3RTZWxsVGltZXN0YW1wJyBpbiB0aWNrZXIpXG4gICAgICAgICAgICBpZiAodGltZXN0YW1wIDwgdGlja2VyWydMYXN0U2VsbFRpbWVzdGFtcCddKSB7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wID0gdGlja2VyWydMYXN0U2VsbFRpbWVzdGFtcCddO1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0aWNrZXJbJ0xhc3RTZWxsUHJpY2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKCF0aW1lc3RhbXApXG4gICAgICAgICAgICB0aW1lc3RhbXAgPSB0aGlzLm1pbGxpc2Vjb25kcyAoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgICAgICAnaGlnaCc6IHRpY2tlclsnRGFpbHlCZXN0QnV5UHJpY2UnXSxcbiAgICAgICAgICAgICdsb3cnOiB0aWNrZXJbJ0RhaWx5QmVzdFNlbGxQcmljZSddLFxuICAgICAgICAgICAgJ2JpZCc6IHRpY2tlclsnQmVzdEJpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlclsnQmVzdEFzayddLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogbGFzdCxcbiAgICAgICAgICAgICdjaGFuZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncGVyY2VudGFnZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdhdmVyYWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2Jhc2VWb2x1bWUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAncXVvdGVWb2x1bWUnOiB0aWNrZXJbJ0RhaWx5VHJhZGVkVG90YWxWb2x1bWUnXSxcbiAgICAgICAgICAgICdpbmZvJzogdGlja2VyLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaFRpY2tlcnMgKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyICgpO1xuICAgICAgICB0aWNrZXJzID0gdGhpcy5pbmRleEJ5ICh0aWNrZXJzLCAnU3ltYm9sJyk7XG4gICAgICAgIGxldCBpZHMgPSBPYmplY3Qua2V5cyAodGlja2Vycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGlkIGluIHRoaXMubWFya2V0c19ieV9pZCkge1xuICAgICAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtpZF07XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbWFya2V0WydzeW1ib2wnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhc2UgPSBpZC5zbGljZSAoMCwgMyk7XG4gICAgICAgICAgICAgICAgbGV0IHF1b3RlID0gaWQuc2xpY2UgKDMsIDYpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlID09ICdEU0gnKVxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gJ0RBU0gnO1xuICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PSAnRFNIJylcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAnREFTSCc7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gYmFzZSArICcvJyArIHF1b3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbaWRdO1xuICAgICAgICAgICAgcmVzdWx0W3N5bWJvbF0gPSB0aGlzLnBhcnNlVGlja2VyICh0aWNrZXIsIG1hcmtldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUaWNrZXIgKHN5bWJvbCkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgbWFya2V0ID0gdGhpcy5tYXJrZXQgKHN5bWJvbCk7XG4gICAgICAgIGxldCB0aWNrZXJzID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUaWNrZXJGaWx0ZXIgKHtcbiAgICAgICAgICAgICdmaWx0ZXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGlja2Vycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGZldGNoVGlja2VyIHJldHVybmVkIGVtcHR5IHJlc3BvbnNlLCB4QlRDZSBwdWJsaWMgQVBJIGVycm9yJyk7XG4gICAgICAgIHRpY2tlcnMgPSB0aGlzLmluZGV4QnkgKHRpY2tlcnMsICdTeW1ib2wnKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IHRpY2tlcnNbbWFya2V0WydpZCddXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaWNrZXIgKHRpY2tlciwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgLy8gbm8gbWV0aG9kIGZvciB0cmFkZXM/XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByaXZhdGVHZXRUcmFkZSAocGFyYW1zKTtcbiAgICB9LFxuXG4gICAgcGFyc2VPSExDViAob2hsY3YsIG1hcmtldCA9IHVuZGVmaW5lZCwgdGltZWZyYW1lID0gJzFtJywgc2luY2UgPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBvaGxjdlsnVGltZXN0YW1wJ10sXG4gICAgICAgICAgICBvaGxjdlsnT3BlbiddLFxuICAgICAgICAgICAgb2hsY3ZbJ0hpZ2gnXSxcbiAgICAgICAgICAgIG9obGN2WydMb3cnXSxcbiAgICAgICAgICAgIG9obGN2WydDbG9zZSddLFxuICAgICAgICAgICAgb2hsY3ZbJ1ZvbHVtZSddLFxuICAgICAgICBdO1xuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE9ITENWIChzeW1ib2wsIHRpbWVmcmFtZSA9ICcxbScsIHNpbmNlID0gdW5kZWZpbmVkLCBsaW1pdCA9IHVuZGVmaW5lZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZCAodGhpcy5pZCArICcgZmV0Y2hPSExDViBpcyBkaXNhYmxlZCBieSB0aGUgZXhjaGFuZ2UnKTtcbiAgICAgICAgbGV0IG1pbnV0ZXMgPSBwYXJzZUludCAodGltZWZyYW1lIC8gNjApOyAvLyAxIG1pbnV0ZSBieSBkZWZhdWx0XG4gICAgICAgIGxldCBwZXJpb2RpY2l0eSA9IG1pbnV0ZXMudG9TdHJpbmcgKCk7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgaWYgKCFzaW5jZSlcbiAgICAgICAgICAgIHNpbmNlID0gdGhpcy5zZWNvbmRzICgpIC0gODY0MDAgKiA3OyAvLyBsYXN0IGRheSBieSBkZWZ1bGF0XG4gICAgICAgIGlmICghbGltaXQpXG4gICAgICAgICAgICBsaW1pdCA9IDEwMDA7IC8vIGRlZmF1bHRcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlR2V0UXVvdGVoaXN0b3J5U3ltYm9sUGVyaW9kaWNpdHlCYXJzQmlkICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgICAgICdwZXJpb2RpY2l0eSc6ICc1bScsIC8vIHBlcmlvZGljaXR5LFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHNpbmNlLFxuICAgICAgICAgICAgJ2NvdW50JzogbGltaXQsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9ITENWcyAocmVzcG9uc2VbJ0JhcnMnXSwgbWFya2V0LCB0aW1lZnJhbWUsIHNpbmNlLCBsaW1pdCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRhcGlQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ0lkJ10udG9TdHJpbmcgKCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGNhbmNlbE9yZGVyIChpZCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpdmF0ZURlbGV0ZVRyYWRlICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ1R5cGUnOiAnQ2FuY2VsJyxcbiAgICAgICAgICAgICdJZCc6IGlkLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICB9LFxuXG4gICAgbm9uY2UgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMgKCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdhcGknLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yICh0aGlzLmlkICsgJyByZXF1aXJlcyBhcGlLZXkgZm9yIGFsbCByZXF1ZXN0cywgdGhlaXIgcHVibGljIEFQSSBpcyBhbHdheXMgYnVzeScpO1xuICAgICAgICBpZiAoIXRoaXMudWlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IgKHRoaXMuaWQgKyAnIHJlcXVpcmVzIHVpZCBwcm9wZXJ0eSBmb3IgYXV0aGVudGljYXRpb24gYW5kIHRyYWRpbmcnKTtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyB0aGlzLnZlcnNpb247XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpXG4gICAgICAgICAgICB1cmwgKz0gJy8nICsgYXBpO1xuICAgICAgICB1cmwgKz0gJy8nICsgdGhpcy5pbXBsb2RlUGFyYW1zIChwYXRoLCBwYXJhbXMpO1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgIGlmIChhcGkgPT0gJ3B1YmxpYycpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aClcbiAgICAgICAgICAgICAgICB1cmwgKz0gJz8nICsgdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7ICdBY2NlcHQtRW5jb2RpbmcnOiAnZ3ppcCwgZGVmbGF0ZScgfTtcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCkudG9TdHJpbmcgKCk7XG4gICAgICAgICAgICBpZiAobWV0aG9kID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyAocXVlcnkpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IHRoaXMuanNvbiAocXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHVybCArPSAnPycgKyB0aGlzLnVybGVuY29kZSAocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGF1dGggPSBub25jZSArIHRoaXMudWlkICsgdGhpcy5hcGlLZXkgKyBtZXRob2QgKyB1cmw7XG4gICAgICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgICAgICBhdXRoICs9IGJvZHk7XG4gICAgICAgICAgICBsZXQgc2lnbmF0dXJlID0gdGhpcy5obWFjICh0aGlzLmVuY29kZSAoYXV0aCksIHRoaXMuZW5jb2RlICh0aGlzLnNlY3JldCksICdzaGEyNTYnLCAnYmFzZTY0Jyk7XG4gICAgICAgICAgICBsZXQgY3JlZGVudGlhbHMgPSB0aGlzLnVpZCArICc6JyArIHRoaXMuYXBpS2V5ICsgJzonICsgbm9uY2UgKyAnOicgKyB0aGlzLmJpbmFyeVRvU3RyaW5nIChzaWduYXR1cmUpO1xuICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gJ0hNQUMgJyArIGNyZWRlbnRpYWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoICh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSk7XG4gICAgfSxcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgeW9iaXQgPSB7XG5cbiAgICAnaWQnOiAneW9iaXQnLFxuICAgICduYW1lJzogJ1lvQml0JyxcbiAgICAnY291bnRyaWVzJzogJ1JVJyxcbiAgICAncmF0ZUxpbWl0JzogMjAwMCwgLy8gcmVzcG9uc2VzIGFyZSBjYWNoZWQgZXZlcnkgMiBzZWNvbmRzXG4gICAgJ3ZlcnNpb24nOiAnMycsXG4gICAgJ2hhc0NPUlMnOiBmYWxzZSxcbiAgICAndXJscyc6IHtcbiAgICAgICAgJ2xvZ28nOiAnaHR0cHM6Ly91c2VyLWltYWdlcy5naXRodWJ1c2VyY29udGVudC5jb20vMTI5NDQ1NC8yNzc2NjkxMC1jZGNiZmRhZS01ZWVhLTExZTctOTg1OS0wM2ZlYTg3MzI3MmQuanBnJyxcbiAgICAgICAgJ2FwaSc6ICdodHRwczovL3lvYml0Lm5ldCcsXG4gICAgICAgICd3d3cnOiAnaHR0cHM6Ly93d3cueW9iaXQubmV0JyxcbiAgICAgICAgJ2RvYyc6ICdodHRwczovL3d3dy55b2JpdC5uZXQvZW4vYXBpLycsXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAnYXBpJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAnZGVwdGgve3BhaXJzfScsXG4gICAgICAgICAgICAgICAgJ2luZm8nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJzfScsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcy97cGFpcnN9JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICd0YXBpJzoge1xuICAgICAgICAgICAgJ3Bvc3QnOiBbXG4gICAgICAgICAgICAgICAgJ0FjdGl2ZU9yZGVycycsXG4gICAgICAgICAgICAgICAgJ0NhbmNlbE9yZGVyJyxcbiAgICAgICAgICAgICAgICAnR2V0RGVwb3NpdEFkZHJlc3MnLFxuICAgICAgICAgICAgICAgICdnZXRJbmZvJyxcbiAgICAgICAgICAgICAgICAnT3JkZXJJbmZvJyxcbiAgICAgICAgICAgICAgICAnVHJhZGUnLFxuICAgICAgICAgICAgICAgICdUcmFkZUhpc3RvcnknLFxuICAgICAgICAgICAgICAgICdXaXRoZHJhd0NvaW5zVG9BZGRyZXNzJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoTWFya2V0cyAoKSB7XG4gICAgICAgIGxldCBtYXJrZXRzID0gYXdhaXQgdGhpcy5hcGlHZXRJbmZvICgpO1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzIChtYXJrZXRzWydwYWlycyddKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGtleXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGtleXNbcF07XG4gICAgICAgICAgICBsZXQgbWFya2V0ID0gbWFya2V0c1sncGFpcnMnXVtpZF07XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gaWQudG9VcHBlckNhc2UgKCkucmVwbGFjZSAoJ18nLCAnLycpO1xuICAgICAgICAgICAgbGV0IFsgYmFzZSwgcXVvdGUgXSA9IHN5bWJvbC5zcGxpdCAoJy8nKTtcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLmNvbW1vbkN1cnJlbmN5Q29kZSAoYmFzZSk7XG4gICAgICAgICAgICBxdW90ZSA9IHRoaXMuY29tbW9uQ3VycmVuY3lDb2RlIChxdW90ZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAoe1xuICAgICAgICAgICAgICAgICdpZCc6IGlkLFxuICAgICAgICAgICAgICAgICdzeW1ib2wnOiBzeW1ib2wsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnOiBiYXNlLFxuICAgICAgICAgICAgICAgICdxdW90ZSc6IHF1b3RlLFxuICAgICAgICAgICAgICAgICdpbmZvJzogbWFya2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hCYWxhbmNlIChwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRhcGlQb3N0R2V0SW5mbyAoKTtcbiAgICAgICAgbGV0IGJhbGFuY2VzID0gcmVzcG9uc2VbJ3JldHVybiddO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyAnaW5mbyc6IGJhbGFuY2VzIH07XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGhpcy5jdXJyZW5jaWVzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVuY3kgPSB0aGlzLmN1cnJlbmNpZXNbY107XG4gICAgICAgICAgICBsZXQgbG93ZXJjYXNlID0gY3VycmVuY3kudG9Mb3dlckNhc2UgKCk7XG4gICAgICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMuYWNjb3VudCAoKTtcbiAgICAgICAgICAgIGlmICgnZnVuZHMnIGluIGJhbGFuY2VzKVxuICAgICAgICAgICAgICAgIGlmIChsb3dlcmNhc2UgaW4gYmFsYW5jZXNbJ2Z1bmRzJ10pXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ2ZyZWUnXSA9IGJhbGFuY2VzWydmdW5kcyddW2xvd2VyY2FzZV07XG4gICAgICAgICAgICBpZiAoJ2Z1bmRzX2luY2xfb3JkZXJzJyBpbiBiYWxhbmNlcylcbiAgICAgICAgICAgICAgICBpZiAobG93ZXJjYXNlIGluIGJhbGFuY2VzWydmdW5kc19pbmNsX29yZGVycyddKVxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50Wyd0b3RhbCddID0gYmFsYW5jZXNbJ2Z1bmRzX2luY2xfb3JkZXJzJ11bbG93ZXJjYXNlXTtcbiAgICAgICAgICAgIGlmIChhY2NvdW50Wyd0b3RhbCddICYmIGFjY291bnRbJ2ZyZWUnXSlcbiAgICAgICAgICAgICAgICBhY2NvdW50Wyd1c2VkJ10gPSBhY2NvdW50Wyd0b3RhbCddIC0gYWNjb3VudFsnZnJlZSddO1xuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbmN5XSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaUdldERlcHRoUGFpcnMgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcnMnOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICBsZXQgb3JkZXJib29rID0gcmVzcG9uc2VbbWFya2V0WydpZCddXTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICBsZXQgYmlkcyA9ICgnYmlkcycgaW4gb3JkZXJib29rKSA/IG9yZGVyYm9va1snYmlkcyddIDogW107XG4gICAgICAgIGxldCBhc2tzID0gKCdhc2tzJyBpbiBvcmRlcmJvb2spID8gb3JkZXJib29rWydhc2tzJ10gOiBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdiaWRzJzogYmlkcyxcbiAgICAgICAgICAgICdhc2tzJzogYXNrcyxcbiAgICAgICAgICAgICd0aW1lc3RhbXAnOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICAnZGF0ZXRpbWUnOiB0aGlzLmlzbzg2MDEgKHRpbWVzdGFtcCksXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChzeW1ib2wpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgdGlja2VycyA9IGF3YWl0IHRoaXMuYXBpR2V0VGlja2VyUGFpcnMgKHtcbiAgICAgICAgICAgICdwYWlycyc6IG1hcmtldFsnaWQnXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCB0aWNrZXIgPSB0aWNrZXJzW21hcmtldFsnaWQnXV07XG4gICAgICAgIGxldCB0aW1lc3RhbXAgPSB0aWNrZXJbJ3VwZGF0ZWQnXSAqIDEwMDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ2hpZ2gnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2hpZ2gnXSksXG4gICAgICAgICAgICAnbG93JzogcGFyc2VGbG9hdCAodGlja2VyWydsb3cnXSksXG4gICAgICAgICAgICAnYmlkJzogcGFyc2VGbG9hdCAodGlja2VyWydidXknXSksXG4gICAgICAgICAgICAnYXNrJzogcGFyc2VGbG9hdCAodGlja2VyWydzZWxsJ10pLFxuICAgICAgICAgICAgJ3Z3YXAnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnb3Blbic6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdjbG9zZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdmaXJzdCc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdsYXN0JzogcGFyc2VGbG9hdCAodGlja2VyWydsYXN0J10pLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiBwYXJzZUZsb2F0ICh0aWNrZXJbJ2F2ZyddKSxcbiAgICAgICAgICAgICdiYXNlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2xfY3VyJ10pLFxuICAgICAgICAgICAgJ3F1b3RlVm9sdW1lJzogcGFyc2VGbG9hdCAodGlja2VyWyd2b2wnXSksXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ3RpbWVzdGFtcCddICogMTAwMDtcbiAgICAgICAgbGV0IHNpZGUgPSAodHJhZGVbJ3R5cGUnXSA9PSAnYmlkJykgPyAnYnV5JyA6ICdzZWxsJztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpbmZvJzogdHJhZGUsXG4gICAgICAgICAgICAnaWQnOiB0cmFkZVsndGlkJ10udG9TdHJpbmcgKCksXG4gICAgICAgICAgICAndGltZXN0YW1wJzogdGltZXN0YW1wLFxuICAgICAgICAgICAgJ2RhdGV0aW1lJzogdGhpcy5pc284NjAxICh0aW1lc3RhbXApLFxuICAgICAgICAgICAgJ3N5bWJvbCc6IG1hcmtldFsnc3ltYm9sJ10sXG4gICAgICAgICAgICAndHlwZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IHRyYWRlWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IHRyYWRlWydhbW91bnQnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hUcmFkZXMgKHN5bWJvbCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaUdldFRyYWRlc1BhaXJzICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXJzJzogbWFya2V0WydpZCddLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcmFkZXMgKHJlc3BvbnNlW21hcmtldFsnaWQnXV0sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgcmF0ZSA9IHByaWNlLnRvU3RyaW5nICgpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRhcGlQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAncGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAndHlwZSc6IHNpZGUsXG4gICAgICAgICAgICAnYW1vdW50JzogYW1vdW50LFxuICAgICAgICAgICAgJ3JhdGUnOiBwcmljZS50b0ZpeGVkICg4KSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3JldHVybiddWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcGlQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIGFzeW5jIHdpdGhkcmF3IChjdXJyZW5jeSwgYW1vdW50LCBhZGRyZXNzLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRNYXJrZXRzICgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy50YXBpUG9zdFdpdGhkcmF3Q29pbnNUb0FkZHJlc3MgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY29pbk5hbWUnOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2luZm8nOiByZXN1bHQsXG4gICAgICAgICAgICAnaWQnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIHJlcXVlc3QgKHBhdGgsIGFwaSA9ICdhcGknLCBtZXRob2QgPSAnR0VUJywgcGFyYW1zID0ge30sIGhlYWRlcnMgPSB1bmRlZmluZWQsIGJvZHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMudXJsc1snYXBpJ10gKyAnLycgKyBhcGk7XG4gICAgICAgIGlmIChhcGkgPT0gJ2FwaScpIHtcbiAgICAgICAgICAgIHVybCArPSAnLycgKyB0aGlzLnZlcnNpb24gKyAnLycgKyB0aGlzLmltcGxvZGVQYXJhbXMgKHBhdGgsIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLm9taXQgKHBhcmFtcywgdGhpcy5leHRyYWN0UGFyYW1zIChwYXRoKSk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMgKHF1ZXJ5KS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/JyArIHRoaXMudXJsZW5jb2RlIChxdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbm9uY2UgPSB0aGlzLm5vbmNlICgpO1xuICAgICAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5leHRlbmQgKHsgJ21ldGhvZCc6IHBhdGgsICdub25jZSc6IG5vbmNlIH0sIHBhcmFtcyk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHF1ZXJ5KTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdrZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnc2lnbic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHl1bmJpID0gZXh0ZW5kIChhY3gsIHtcblxuICAgICdpZCc6ICd5dW5iaScsXG4gICAgJ25hbWUnOiAnWVVOQkknLFxuICAgICdjb3VudHJpZXMnOiAnQ04nLFxuICAgICdyYXRlTGltaXQnOiAxMDAwLFxuICAgICd2ZXJzaW9uJzogJ3YyJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICdoYXNGZXRjaFRpY2tlcnMnOiB0cnVlLFxuICAgICdoYXNGZXRjaE9ITENWJzogdHJ1ZSxcbiAgICAndGltZWZyYW1lcyc6IHtcbiAgICAgICAgJzFtJzogJzEnLFxuICAgICAgICAnNW0nOiAnNScsXG4gICAgICAgICcxNW0nOiAnMTUnLFxuICAgICAgICAnMzBtJzogJzMwJyxcbiAgICAgICAgJzFoJzogJzYwJyxcbiAgICAgICAgJzJoJzogJzEyMCcsXG4gICAgICAgICc0aCc6ICcyNDAnLFxuICAgICAgICAnMTJoJzogJzcyMCcsXG4gICAgICAgICcxZCc6ICcxNDQwJyxcbiAgICAgICAgJzNkJzogJzQzMjAnLFxuICAgICAgICAnMXcnOiAnMTAwODAnLFxuICAgIH0sXG4gICAgJ3VybHMnOiB7XG4gICAgICAgICdsb2dvJzogJ2h0dHBzOi8vdXNlci1pbWFnZXMuZ2l0aHVidXNlcmNvbnRlbnQuY29tLzEyOTQ0NTQvMjg1NzA1NDgtNGQ2NDZjNDAtNzE0Ny0xMWU3LTljZjYtODM5YjkzZTZkNjIyLmpwZycsXG4gICAgICAgICdhcGknOiAnaHR0cHM6Ly95dW5iaS5jb20nLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8veXVuYmkuY29tJyxcbiAgICAgICAgJ2RvYyc6IFtcbiAgICAgICAgICAgICdodHRwczovL3l1bmJpLmNvbS9kb2N1bWVudHMvYXBpL2d1aWRlJyxcbiAgICAgICAgICAgICdodHRwczovL3l1bmJpLmNvbS9zd2FnZ2VyLycsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICAnYXBpJzoge1xuICAgICAgICAncHVibGljJzoge1xuICAgICAgICAgICAgJ2dldCc6IFtcbiAgICAgICAgICAgICAgICAndGlja2VycycsXG4gICAgICAgICAgICAgICAgJ3RpY2tlcnMve21hcmtldH0nLFxuICAgICAgICAgICAgICAgICdtYXJrZXRzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXJfYm9vaycsXG4gICAgICAgICAgICAgICAgJ2snLFxuICAgICAgICAgICAgICAgICdkZXB0aCcsXG4gICAgICAgICAgICAgICAgJ3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ2tfd2l0aF9wZW5kaW5nX3RyYWRlcycsXG4gICAgICAgICAgICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAgICAgICAgICAgJ2FkZHJlc3Nlcy97YWRkcmVzc30nLFxuICAgICAgICAgICAgICAgICdwYXJ0bmVycy9vcmRlcnMve2lkfS90cmFkZXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgJ3ByaXZhdGUnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdkZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgJ21lbWJlcnMvbWUnLFxuICAgICAgICAgICAgICAgICdkZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdF9hZGRyZXNzJyxcbiAgICAgICAgICAgICAgICAnb3JkZXInLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICd0cmFkZXMvbXknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdvcmRlci9kZWxldGUnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMnLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvbXVsdGknLFxuICAgICAgICAgICAgICAgICdvcmRlcnMvY2xlYXInLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICB9LFxufSlcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgemFpZiA9IHtcblxuICAgICdpZCc6ICd6YWlmJyxcbiAgICAnbmFtZSc6ICdaYWlmJyxcbiAgICAnY291bnRyaWVzJzogJ0pQJyxcbiAgICAncmF0ZUxpbWl0JzogMjAwMCxcbiAgICAndmVyc2lvbic6ICcxJyxcbiAgICAnaGFzQ09SUyc6IGZhbHNlLFxuICAgICd1cmxzJzoge1xuICAgICAgICAnbG9nbyc6ICdodHRwczovL3VzZXItaW1hZ2VzLmdpdGh1YnVzZXJjb250ZW50LmNvbS8xMjk0NDU0LzI3NzY2OTI3LTM5Y2EyYWRhLTVlZWItMTFlNy05NzJmLTFiNDE5OTUxOGNhNi5qcGcnLFxuICAgICAgICAnYXBpJzogJ2h0dHBzOi8vYXBpLnphaWYuanAnLFxuICAgICAgICAnd3d3JzogJ2h0dHBzOi8vemFpZi5qcCcsXG4gICAgICAgICdkb2MnOiBbXG4gICAgICAgICAgICAnaHR0cDovL3RlY2hidXJlYXUtYXBpLWRvY3VtZW50LnJlYWR0aGVkb2NzLmlvL2phL2xhdGVzdC9pbmRleC5odG1sJyxcbiAgICAgICAgICAgICdodHRwczovL2NvcnAuemFpZi5qcC9hcGktZG9jcycsXG4gICAgICAgICAgICAnaHR0cHM6Ly9jb3JwLnphaWYuanAvYXBpLWRvY3MvYXBpX2xpbmtzJyxcbiAgICAgICAgICAgICdodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS96YWlmLmpwJyxcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20veW91MjE5Nzkvbm9kZS16YWlmJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgICdhcGknOiB7XG4gICAgICAgICdwdWJsaWMnOiB7XG4gICAgICAgICAgICAnZ2V0JzogW1xuICAgICAgICAgICAgICAgICdkZXB0aC97cGFpcn0nLFxuICAgICAgICAgICAgICAgICdjdXJyZW5jaWVzL3twYWlyfScsXG4gICAgICAgICAgICAgICAgJ2N1cnJlbmNpZXMvYWxsJyxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3lfcGFpcnMve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAnY3VycmVuY3lfcGFpcnMvYWxsJyxcbiAgICAgICAgICAgICAgICAnbGFzdF9wcmljZS97cGFpcn0nLFxuICAgICAgICAgICAgICAgICd0aWNrZXIve3BhaXJ9JyxcbiAgICAgICAgICAgICAgICAndHJhZGVzL3twYWlyfScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICAncHJpdmF0ZSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdhY3RpdmVfb3JkZXJzJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsX29yZGVyJyxcbiAgICAgICAgICAgICAgICAnZGVwb3NpdF9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnZ2V0X2lkX2luZm8nLFxuICAgICAgICAgICAgICAgICdnZXRfaW5mbycsXG4gICAgICAgICAgICAgICAgJ2dldF9pbmZvMicsXG4gICAgICAgICAgICAgICAgJ2dldF9wZXJzb25hbF9pbmZvJyxcbiAgICAgICAgICAgICAgICAndHJhZGUnLFxuICAgICAgICAgICAgICAgICd0cmFkZV9oaXN0b3J5JyxcbiAgICAgICAgICAgICAgICAnd2l0aGRyYXcnLFxuICAgICAgICAgICAgICAgICd3aXRoZHJhd19oaXN0b3J5JyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgICdlY2FwaSc6IHtcbiAgICAgICAgICAgICdwb3N0JzogW1xuICAgICAgICAgICAgICAgICdjcmVhdGVJbnZvaWNlJyxcbiAgICAgICAgICAgICAgICAnZ2V0SW52b2ljZScsXG4gICAgICAgICAgICAgICAgJ2dldEludm9pY2VJZHNCeU9yZGVyTnVtYmVyJyxcbiAgICAgICAgICAgICAgICAnY2FuY2VsSW52b2ljZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIH0sXG5cbiAgICBhc3luYyBmZXRjaE1hcmtldHMgKCkge1xuICAgICAgICBsZXQgbWFya2V0cyA9IGF3YWl0IHRoaXMucHVibGljR2V0Q3VycmVuY3lQYWlyc0FsbCAoKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG1hcmtldHMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXQgPSBtYXJrZXRzW3BdO1xuICAgICAgICAgICAgbGV0IGlkID0gbWFya2V0WydjdXJyZW5jeV9wYWlyJ107XG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gbWFya2V0WyduYW1lJ107XG4gICAgICAgICAgICBsZXQgWyBiYXNlLCBxdW90ZSBdID0gc3ltYm9sLnNwbGl0ICgnLycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHtcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAgICAgICAnc3ltYm9sJzogc3ltYm9sLFxuICAgICAgICAgICAgICAgICdiYXNlJzogYmFzZSxcbiAgICAgICAgICAgICAgICAncXVvdGUnOiBxdW90ZSxcbiAgICAgICAgICAgICAgICAnaW5mbyc6IG1hcmtldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQmFsYW5jZSAocGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wcml2YXRlUG9zdEdldEluZm8gKCk7XG4gICAgICAgIGxldCBiYWxhbmNlcyA9IHJlc3BvbnNlWydyZXR1cm4nXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgJ2luZm8nOiBiYWxhbmNlcyB9O1xuICAgICAgICBsZXQgY3VycmVuY2llcyA9IE9iamVjdC5rZXlzIChiYWxhbmNlc1snZnVuZHMnXSk7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY3VycmVuY2llcy5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llc1tjXTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYmFsYW5jZXNbJ2Z1bmRzJ11bY3VycmVuY3ldO1xuICAgICAgICAgICAgbGV0IHVwcGVyY2FzZSA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlICgpO1xuICAgICAgICAgICAgbGV0IGFjY291bnQgPSB7XG4gICAgICAgICAgICAgICAgJ2ZyZWUnOiBiYWxhbmNlLFxuICAgICAgICAgICAgICAgICd1c2VkJzogMC4wLFxuICAgICAgICAgICAgICAgICd0b3RhbCc6IGJhbGFuY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCdkZXBvc2l0JyBpbiBiYWxhbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeSBpbiBiYWxhbmNlc1snZGVwb3NpdCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRbJ3RvdGFsJ10gPSBiYWxhbmNlc1snZGVwb3NpdCddW2N1cnJlbmN5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudFsndXNlZCddID0gYWNjb3VudFsndG90YWwnXSAtIGFjY291bnRbJ2ZyZWUnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbdXBwZXJjYXNlXSA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcmRlckJvb2sgKG1hcmtldCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IG9yZGVyYm9vayA9IGF3YWl0IHRoaXMucHVibGljR2V0RGVwdGhQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlckJvb2sgKG9yZGVyYm9vayk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVGlja2VyIChtYXJrZXQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkTWFya2V0cyAoKTtcbiAgICAgICAgbGV0IHRpY2tlciA9IGF3YWl0IHRoaXMucHVibGljR2V0VGlja2VyUGFpciAoe1xuICAgICAgICAgICAgJ3BhaXInOiB0aGlzLm1hcmtldElkIChtYXJrZXQpLFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRpbWVzdGFtcCA9IHRoaXMubWlsbGlzZWNvbmRzICgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdoaWdoJzogdGlja2VyWydoaWdoJ10sXG4gICAgICAgICAgICAnbG93JzogdGlja2VyWydsb3cnXSxcbiAgICAgICAgICAgICdiaWQnOiB0aWNrZXJbJ2JpZCddLFxuICAgICAgICAgICAgJ2Fzayc6IHRpY2tlclsnYXNrJ10sXG4gICAgICAgICAgICAndndhcCc6IHRpY2tlclsndndhcCddLFxuICAgICAgICAgICAgJ29wZW4nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnY2xvc2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnZmlyc3QnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnbGFzdCc6IHRpY2tlclsnbGFzdCddLFxuICAgICAgICAgICAgJ2NoYW5nZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdwZXJjZW50YWdlJzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJ2F2ZXJhZ2UnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnYmFzZVZvbHVtZSc6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICdxdW90ZVZvbHVtZSc6IHRpY2tlclsndm9sdW1lJ10sXG4gICAgICAgICAgICAnaW5mbyc6IHRpY2tlcixcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgcGFyc2VUcmFkZSAodHJhZGUsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgc2lkZSA9ICh0cmFkZVsndHJhZGVfdHlwZSddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gdHJhZGVbJ2RhdGUnXSAqIDEwMDA7XG4gICAgICAgIGxldCBpZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCdpZCcgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGlkID0gdHJhZGVbJ2lkJ107XG4gICAgICAgIH0gZWxzZSBpZiAoJ3RpZCcgaW4gdHJhZGUpIHtcbiAgICAgICAgICAgIGlkID0gdHJhZGVbJ3RpZCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWFya2V0KVxuICAgICAgICAgICAgbWFya2V0ID0gdGhpcy5tYXJrZXRzX2J5X2lkW3RyYWRlWydjdXJyZW5jeV9wYWlyJ11dO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2lkJzogaWQudG9TdHJpbmcgKCksXG4gICAgICAgICAgICAnaW5mbyc6IHRyYWRlLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzeW1ib2wnOiBtYXJrZXRbJ3N5bWJvbCddLFxuICAgICAgICAgICAgJ3R5cGUnOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnc2lkZSc6IHNpZGUsXG4gICAgICAgICAgICAncHJpY2UnOiB0cmFkZVsncHJpY2UnXSxcbiAgICAgICAgICAgICdhbW91bnQnOiB0cmFkZVsnYW1vdW50J10sXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoVHJhZGVzIChzeW1ib2wsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wdWJsaWNHZXRUcmFkZXNQYWlyICh0aGlzLmV4dGVuZCAoe1xuICAgICAgICAgICAgJ3BhaXInOiBtYXJrZXRbJ2lkJ10sXG4gICAgICAgIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRyYWRlcyAocmVzcG9uc2UsIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNyZWF0ZU9yZGVyIChzeW1ib2wsIHR5cGUsIHNpZGUsIGFtb3VudCwgcHJpY2UgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmICh0eXBlID09ICdtYXJrZXQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2hhbmdlRXJyb3IgKHRoaXMuaWQgKyAnIGFsbG93cyBsaW1pdCBvcmRlcnMgb25seScpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0VHJhZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3lfcGFpcic6IHRoaXMubWFya2V0SWQgKHN5bWJvbCksXG4gICAgICAgICAgICAnYWN0aW9uJzogKHNpZGUgPT0gJ2J1eScpID8gJ2JpZCcgOiAnYXNrJyxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAncHJpY2UnOiBwcmljZSxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3BvbnNlLFxuICAgICAgICAgICAgJ2lkJzogcmVzcG9uc2VbJ3JldHVybiddWydvcmRlcl9pZCddLnRvU3RyaW5nICgpLFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjYW5jZWxPcmRlciAoaWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZhdGVQb3N0Q2FuY2VsT3JkZXIgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnb3JkZXJfaWQnOiBpZCxcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXIgKG9yZGVyLCBtYXJrZXQgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSAob3JkZXJbJ2FjdGlvbiddID09ICdiaWQnKSA/ICdidXknIDogJ3NlbGwnO1xuICAgICAgICBsZXQgdGltZXN0YW1wID0gcGFyc2VJbnQgKG9yZGVyWyd0aW1lc3RhbXAnXSkgKiAxMDAwO1xuICAgICAgICBpZiAoIW1hcmtldClcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0c19ieV9pZFtvcmRlclsnY3VycmVuY3lfcGFpciddXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdpZCc6IG9yZGVyWydpZCddLnRvU3RyaW5nICgpLFxuICAgICAgICAgICAgJ3RpbWVzdGFtcCc6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgICdkYXRldGltZSc6IHRoaXMuaXNvODYwMSAodGltZXN0YW1wKSxcbiAgICAgICAgICAgICdzdGF0dXMnOiAnb3BlbicsXG4gICAgICAgICAgICAnc3ltYm9sJzogbWFya2V0WydzeW1ib2wnXSxcbiAgICAgICAgICAgICd0eXBlJzogJ2xpbWl0JyxcbiAgICAgICAgICAgICdzaWRlJzogc2lkZSxcbiAgICAgICAgICAgICdwcmljZSc6IG9yZGVyWydwcmljZSddLFxuICAgICAgICAgICAgJ2Ftb3VudCc6IG9yZGVyWydhbW91bnQnXSxcbiAgICAgICAgICAgICd0cmFkZXMnOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHBhcnNlT3JkZXJzIChvcmRlcnMsIG1hcmtldCA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgaWRzID0gT2JqZWN0LmtleXMgKG9yZGVycyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpZCA9IGlkc1tpXTtcbiAgICAgICAgICAgIGxldCBvcmRlciA9IG9yZGVyc1tpZF07XG4gICAgICAgICAgICBsZXQgZXh0ZW5kZWQgPSB0aGlzLmV4dGVuZCAob3JkZXIsIHsgJ2lkJzogaWQgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAodGhpcy5wYXJzZU9yZGVyIChleHRlbmRlZCwgbWFya2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgYXN5bmMgZmV0Y2hPcGVuT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAvLyAgICAgJ2lzX3Rva2VuJzogZmFsc2UsXG4gICAgICAgIC8vICAgICAnaXNfdG9rZW5fYm90aCc6IGZhbHNlLFxuICAgICAgICAvLyB9O1xuICAgICAgICBsZXQgcmVxdWVzdCA9IHt9O1xuICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICBtYXJrZXQgPSB0aGlzLm1hcmtldCAoc3ltYm9sKTtcbiAgICAgICAgICAgIHJlcXVlc3RbJ2N1cnJlbmN5X3BhaXInXSA9IG1hcmtldFsnaWQnXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0QWN0aXZlT3JkZXJzICh0aGlzLmV4dGVuZCAocmVxdWVzdCwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3JkZXJzIChyZXNwb25zZVsncmV0dXJuJ10sIG1hcmtldCk7XG4gICAgfSxcblxuICAgIGFzeW5jIGZldGNoQ2xvc2VkT3JkZXJzIChzeW1ib2wgPSB1bmRlZmluZWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGxldCBtYXJrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIGxldCByZXF1ZXN0ID0ge1xuICAgICAgICAvLyAgICAgJ2Zyb20nOiAwLFxuICAgICAgICAvLyAgICAgJ2NvdW50JzogMTAwMCxcbiAgICAgICAgLy8gICAgICdmcm9tX2lkJzogMCxcbiAgICAgICAgLy8gICAgICdlbmRfaWQnOiAxMDAwLFxuICAgICAgICAvLyAgICAgJ29yZGVyJzogJ0RFU0MnLFxuICAgICAgICAvLyAgICAgJ3NpbmNlJzogMTUwMzgyMTA1MSxcbiAgICAgICAgLy8gICAgICdlbmQnOiAxNTAzODIxMDUxLFxuICAgICAgICAvLyAgICAgJ2lzX3Rva2VuJzogZmFsc2UsXG4gICAgICAgIC8vIH07XG4gICAgICAgIGxldCByZXF1ZXN0ID0ge307XG4gICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgIG1hcmtldCA9IHRoaXMubWFya2V0IChzeW1ib2wpO1xuICAgICAgICAgICAgcmVxdWVzdFsnY3VycmVuY3lfcGFpciddID0gbWFya2V0WydpZCddO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJpdmF0ZVBvc3RUcmFkZUhpc3RvcnkgKHRoaXMuZXh0ZW5kIChyZXF1ZXN0LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcmRlcnMgKHJlc3BvbnNlWydyZXR1cm4nXSwgbWFya2V0KTtcbiAgICB9LFxuXG4gICAgYXN5bmMgd2l0aGRyYXcgKGN1cnJlbmN5LCBhbW91bnQsIGFkZHJlc3MsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMubG9hZE1hcmtldHMgKCk7XG4gICAgICAgIGlmIChjdXJyZW5jeSA9PSAnSlBZJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNoYW5nZUVycm9yICh0aGlzLmlkICsgJyBkb2VzIG5vdCBhbGxvdyAnICsgY3VycmVuY3kgKyAnIHdpdGhkcmF3YWxzJyk7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCB0aGlzLnByaXZhdGVQb3N0V2l0aGRyYXcgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAnY3VycmVuY3knOiBjdXJyZW5jeSxcbiAgICAgICAgICAgICdhbW91bnQnOiBhbW91bnQsXG4gICAgICAgICAgICAnYWRkcmVzcyc6IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyAnbWVzc2FnZSc6ICdIaSEnLCAvLyBYRU0gb25seVxuICAgICAgICAgICAgLy8gJ29wdF9mZWUnOiAwLjAwMywgLy8gQlRDIGFuZCBNT05BIG9ubHlcbiAgICAgICAgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaW5mbyc6IHJlc3VsdCxcbiAgICAgICAgICAgICdpZCc6IHJlc3VsdFsncmV0dXJuJ11bJ3R4aWQnXSxcbiAgICAgICAgICAgICdmZWUnOiByZXN1bHRbJ3JldHVybiddWydmZWUnXSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcmVxdWVzdCAocGF0aCwgYXBpID0gJ2FwaScsIG1ldGhvZCA9ICdHRVQnLCBwYXJhbXMgPSB7fSwgaGVhZGVycyA9IHVuZGVmaW5lZCwgYm9keSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy51cmxzWydhcGknXSArICcvJztcbiAgICAgICAgaWYgKGFwaSA9PSAncHVibGljJykge1xuICAgICAgICAgICAgdXJsICs9ICdhcGkvJyArIHRoaXMudmVyc2lvbiArICcvJyArIHRoaXMuaW1wbG9kZVBhcmFtcyAocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybCArPSAoYXBpID09ICdlY2FwaScpID8gJ2VjYXBpJyA6ICd0YXBpJztcbiAgICAgICAgICAgIGxldCBub25jZSA9IHRoaXMubm9uY2UgKCk7XG4gICAgICAgICAgICBib2R5ID0gdGhpcy51cmxlbmNvZGUgKHRoaXMuZXh0ZW5kICh7XG4gICAgICAgICAgICAgICAgJ21ldGhvZCc6IHBhdGgsXG4gICAgICAgICAgICAgICAgJ25vbmNlJzogbm9uY2UsXG4gICAgICAgICAgICB9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICAgICAgICAgICdLZXknOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgICAgICAnU2lnbic6IHRoaXMuaG1hYyAodGhpcy5lbmNvZGUgKGJvZHkpLCB0aGlzLmVuY29kZSAodGhpcy5zZWNyZXQpLCAnc2hhNTEyJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2ggKHVybCwgbWV0aG9kLCBoZWFkZXJzLCBib2R5KTtcbiAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHJlc3BvbnNlWydlcnJvciddKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzJyBpbiByZXNwb25zZSlcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ3N1Y2Nlc3MnXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjaGFuZ2VFcnJvciAodGhpcy5pZCArICcgJyArIHRoaXMuanNvbiAocmVzcG9uc2UpKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG59XG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxudmFyIGV4Y2hhbmdlcyA9IHtcblxuICAgICdfMWJyb2tlcic6ICAgICAgICAgIF8xYnJva2VyLFxuICAgICdfMWJ0Y3hlJzogICAgICAgICAgIF8xYnRjeGUsXG4gICAgJ2FjeCc6ICAgICAgICAgICAgICAgIGFjeCxcbiAgICAnYW54cHJvJzogICAgICAgICAgICAgYW54cHJvLFxuICAgICdiaW5hbmNlJzogICAgICAgICAgICBiaW5hbmNlLFxuICAgICdiaXQyYyc6ICAgICAgICAgICAgICBiaXQyYyxcbiAgICAnYml0YmF5JzogICAgICAgICAgICAgYml0YmF5LFxuICAgICdiaXRjb2luY29pZCc6ICAgICAgICBiaXRjb2luY29pZCxcbiAgICAnYml0ZmluZXgnOiAgICAgICAgICAgYml0ZmluZXgsXG4gICAgJ2JpdGZpbmV4Mic6ICAgICAgICAgIGJpdGZpbmV4MixcbiAgICAnYml0Zmx5ZXInOiAgICAgICAgICAgYml0Zmx5ZXIsXG4gICAgJ2JpdGh1bWInOiAgICAgICAgICAgIGJpdGh1bWIsXG4gICAgJ2JpdGxpc2gnOiAgICAgICAgICAgIGJpdGxpc2gsXG4gICAgJ2JpdG1hcmtldCc6ICAgICAgICAgIGJpdG1hcmtldCxcbiAgICAnYml0bWV4JzogICAgICAgICAgICAgYml0bWV4LFxuICAgICdiaXRzbyc6ICAgICAgICAgICAgICBiaXRzbyxcbiAgICAnYml0c3RhbXAxJzogICAgICAgICAgYml0c3RhbXAxLFxuICAgICdiaXRzdGFtcCc6ICAgICAgICAgICBiaXRzdGFtcCxcbiAgICAnYml0dHJleCc6ICAgICAgICAgICAgYml0dHJleCxcbiAgICAnYmwzcCc6ICAgICAgICAgICAgICAgYmwzcCxcbiAgICAnYmxldXRyYWRlJzogICAgICAgICAgYmxldXRyYWRlLFxuICAgICdidGNjaGluYSc6ICAgICAgICAgICBidGNjaGluYSxcbiAgICAnYnRjZXhjaGFuZ2UnOiAgICAgICAgYnRjZXhjaGFuZ2UsXG4gICAgJ2J0Y21hcmtldHMnOiAgICAgICAgIGJ0Y21hcmtldHMsXG4gICAgJ2J0Y3RyYWRldWEnOiAgICAgICAgIGJ0Y3RyYWRldWEsXG4gICAgJ2J0Y3R1cmsnOiAgICAgICAgICAgIGJ0Y3R1cmssXG4gICAgJ2J0Y3gnOiAgICAgICAgICAgICAgIGJ0Y3gsXG4gICAgJ2J0ZXInOiAgICAgICAgICAgICAgIGJ0ZXIsXG4gICAgJ2J4aW50aCc6ICAgICAgICAgICAgIGJ4aW50aCxcbiAgICAnY2NleCc6ICAgICAgICAgICAgICAgY2NleCxcbiAgICAnY2V4JzogICAgICAgICAgICAgICAgY2V4LFxuICAgICdjaGJ0Yyc6ICAgICAgICAgICAgICBjaGJ0YyxcbiAgICAnY2hpbGViaXQnOiAgICAgICAgICAgY2hpbGViaXQsXG4gICAgJ2NvaW5jaGVjayc6ICAgICAgICAgIGNvaW5jaGVjayxcbiAgICAnY29pbmZsb29yJzogICAgICAgICAgY29pbmZsb29yLFxuICAgICdjb2luZ2knOiAgICAgICAgICAgICBjb2luZ2ksXG4gICAgJ2NvaW5tYXJrZXRjYXAnOiAgICAgIGNvaW5tYXJrZXRjYXAsXG4gICAgJ2NvaW5tYXRlJzogICAgICAgICAgIGNvaW5tYXRlLFxuICAgICdjb2luc2VjdXJlJzogICAgICAgICBjb2luc2VjdXJlLFxuICAgICdjb2luc3BvdCc6ICAgICAgICAgICBjb2luc3BvdCxcbiAgICAnY3J5cHRvcGlhJzogICAgICAgICAgY3J5cHRvcGlhLFxuICAgICdkc3gnOiAgICAgICAgICAgICAgICBkc3gsXG4gICAgJ2V4bW8nOiAgICAgICAgICAgICAgIGV4bW8sXG4gICAgJ2Zsb3didGMnOiAgICAgICAgICAgIGZsb3didGMsXG4gICAgJ2ZveGJpdCc6ICAgICAgICAgICAgIGZveGJpdCxcbiAgICAnZnlic2UnOiAgICAgICAgICAgICAgZnlic2UsXG4gICAgJ2Z5YnNnJzogICAgICAgICAgICAgIGZ5YnNnLFxuICAgICdnYXRlY29pbic6ICAgICAgICAgICBnYXRlY29pbixcbiAgICAnZ2RheCc6ICAgICAgICAgICAgICAgZ2RheCxcbiAgICAnZ2VtaW5pJzogICAgICAgICAgICAgZ2VtaW5pLFxuICAgICdoaXRidGMnOiAgICAgICAgICAgICBoaXRidGMsXG4gICAgJ2hpdGJ0YzInOiAgICAgICAgICAgIGhpdGJ0YzIsXG4gICAgJ2h1b2JpJzogICAgICAgICAgICAgIGh1b2JpLFxuICAgICdodW9iaWNueSc6ICAgICAgICAgICBodW9iaWNueSxcbiAgICAnaHVvYmlwcm8nOiAgICAgICAgICAgaHVvYmlwcm8sXG4gICAgJ2luZGVwZW5kZW50cmVzZXJ2ZSc6IGluZGVwZW5kZW50cmVzZXJ2ZSxcbiAgICAnaXRiaXQnOiAgICAgICAgICAgICAgaXRiaXQsXG4gICAgJ2p1YmknOiAgICAgICAgICAgICAgIGp1YmksXG4gICAgJ2tyYWtlbic6ICAgICAgICAgICAgIGtyYWtlbixcbiAgICAnbGFrZWJ0Yyc6ICAgICAgICAgICAgbGFrZWJ0YyxcbiAgICAnbGl2ZWNvaW4nOiAgICAgICAgICAgbGl2ZWNvaW4sXG4gICAgJ2xpcXVpJzogICAgICAgICAgICAgIGxpcXVpLFxuICAgICdsdW5vJzogICAgICAgICAgICAgICBsdW5vLFxuICAgICdtZXJjYWRvJzogICAgICAgICAgICBtZXJjYWRvLFxuICAgICdtaXhjb2lucyc6ICAgICAgICAgICBtaXhjb2lucyxcbiAgICAnbm92YSc6ICAgICAgICAgICAgICAgbm92YSxcbiAgICAnb2tjb2luY255JzogICAgICAgICAgb2tjb2luY255LFxuICAgICdva2NvaW51c2QnOiAgICAgICAgICBva2NvaW51c2QsXG4gICAgJ29rZXgnOiAgICAgICAgICAgICAgIG9rZXgsXG4gICAgJ3BheW1pdW0nOiAgICAgICAgICAgIHBheW1pdW0sXG4gICAgJ3BvbG9uaWV4JzogICAgICAgICAgIHBvbG9uaWV4LFxuICAgICdxdWFkcmlnYWN4JzogICAgICAgICBxdWFkcmlnYWN4LFxuICAgICdxdW9pbmUnOiAgICAgICAgICAgICBxdW9pbmUsXG4gICAgJ3NvdXRoeGNoYW5nZSc6ICAgICAgIHNvdXRoeGNoYW5nZSxcbiAgICAnc3VyYml0Y29pbic6ICAgICAgICAgc3VyYml0Y29pbixcbiAgICAndGhlcm9jayc6ICAgICAgICAgICAgdGhlcm9jayxcbiAgICAndXJkdWJpdCc6ICAgICAgICAgICAgdXJkdWJpdCxcbiAgICAndmF1bHRvcm8nOiAgICAgICAgICAgdmF1bHRvcm8sXG4gICAgJ3ZidGMnOiAgICAgICAgICAgICAgIHZidGMsXG4gICAgJ3ZpcndveCc6ICAgICAgICAgICAgIHZpcndveCxcbiAgICAnd2V4JzogICAgICAgICAgICAgICAgd2V4LFxuICAgICd4YnRjZSc6ICAgICAgICAgICAgICB4YnRjZSxcbiAgICAneW9iaXQnOiAgICAgICAgICAgICAgeW9iaXQsXG4gICAgJ3l1bmJpJzogICAgICAgICAgICAgIHl1bmJpLFxuICAgICd6YWlmJzogICAgICAgICAgICAgICB6YWlmLFxufVxuXG5sZXQgZGVmaW5lQWxsRXhjaGFuZ2VzID0gZnVuY3Rpb24gKGV4Y2hhbmdlcykge1xuICAgIGxldCByZXN1bHQgPSB7fVxuICAgIGZvciAobGV0IGlkIGluIGV4Y2hhbmdlcykge1xuICAgICAgICByZXN1bHRbaWRdID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeGNoYW5nZSAoZXh0ZW5kIChleGNoYW5nZXNbaWRdLCBwYXJhbXMpKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5leGNoYW5nZXMgPSBPYmplY3Qua2V5cyAoZXhjaGFuZ2VzKVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBjY3h0ID0gT2JqZWN0LmFzc2lnbiAoZGVmaW5lQWxsRXhjaGFuZ2VzIChleGNoYW5nZXMpLCB7XG5cbiAgICB2ZXJzaW9uLFxuXG4gICAgLy8gRXhjaGFuZ2UgY29uc3RydWN0b3IgKGRvIG5vdCB1c2UgZGlyZWN0bHksIHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBjbGFzcyBzb29uKVxuXG4gICAgRXhjaGFuZ2UsXG5cbiAgICAvLyBleGNlcHRpb25zXG5cbiAgICBDQ1hURXJyb3IsXG4gICAgRXhjaGFuZ2VFcnJvcixcbiAgICBOb3RTdXBwb3J0ZWQsXG4gICAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgICBJbnN1ZmZpY2llbnRGdW5kcyxcbiAgICBOZXR3b3JrRXJyb3IsXG4gICAgRERvU1Byb3RlY3Rpb24sXG4gICAgUmVxdWVzdFRpbWVvdXQsXG4gICAgRXhjaGFuZ2VOb3RBdmFpbGFibGUsXG5cbiAgICAvLyBjb21tb24gdXRpbGl0eSBmdW5jdGlvbnNcblxuICAgIHNsZWVwLFxuICAgIHRpbWVvdXQsXG4gICAgY2FwaXRhbGl6ZSxcbiAgICBrZXlzb3J0LFxuICAgIGV4dGVuZCxcbiAgICBvbWl0LFxuICAgIGluZGV4QnksXG4gICAgc29ydEJ5LFxuICAgIGZsYXR0ZW4sXG4gICAgdW5pcXVlLFxuICAgIHBsdWNrLFxuICAgIHVybGVuY29kZSxcbiAgICBzdW0sXG4gICAgZGVjaW1hbCxcbiAgICBzYWZlRmxvYXQsXG5cbiAgICAvLyB1bmRlcnNjb3JlIGFsaWFzZXNcblxuICAgIGluZGV4X2J5OiBpbmRleEJ5LFxuICAgIHNvcnRfYnk6IHNvcnRCeSxcblxuICAgIC8vIGNyeXB0byBmdW5jdGlvbnNcblxuICAgIGJpbmFyeUNvbmNhdCxcbiAgICBzdHJpbmdUb0JpbmFyeSxcbiAgICBiaW5hcnlUb1N0cmluZyxcbiAgICBzdHJpbmdUb0Jhc2U2NCxcbiAgICB1dGYxNlRvQmFzZTY0LFxuICAgIGJhc2U2NFRvQmluYXJ5LFxuICAgIGJhc2U2NFRvU3RyaW5nLFxuICAgIHVybGVuY29kZUJhc2U2NCxcbiAgICBoYXNoLFxuICAgIGhtYWMsXG4gICAgand0LFxuXG59KVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmlmIChpc0NvbW1vbkpTKSB7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNjeHRcblxufSBlbHNlIHtcblxuICAgIHdpbmRvdy5jY3h0ID0gY2N4dFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbn0pICgpIC8vIGVuZCBvZiBuYW1lc3BhY2VcbiIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIExvb2t1cCB0YWJsZXNcblx0ICAgIHZhciBTQk9YID0gW107XG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBTVUJfTUlYXzMgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzIgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8zID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgbG9va3VwIHRhYmxlc1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxuXHQgICAgICAgIHZhciBkID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IGkgPDwgMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gV2FsayBHRigyXjgpXG5cdCAgICAgICAgdmFyIHggPSAwO1xuXHQgICAgICAgIHZhciB4aSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHNib3hcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XG5cdCAgICAgICAgICAgIHN4ID0gKHN4ID4+PiA4KSBeIChzeCAmIDB4ZmYpIF4gMHg2Mztcblx0ICAgICAgICAgICAgU0JPWFt4XSA9IHN4O1xuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbXVsdGlwbGljYXRpb25cblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcblx0ICAgICAgICAgICAgdmFyIHg0ID0gZFt4Ml07XG5cdCAgICAgICAgICAgIHZhciB4OCA9IGRbeDRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc3ViIGJ5dGVzLCBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoZFtzeF0gKiAweDEwMSkgXiAoc3ggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMVt4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMlt4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbnYgc3ViIGJ5dGVzLCBpbnYgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8wW3N4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMVtzeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuXHQgICAgICAgICAgICBpZiAoIXgpIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4aSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geDIgXiBkW2RbZFt4OCBeIHgyXV1dO1xuXHQgICAgICAgICAgICAgICAgeGkgXj0gZFtkW3hpXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBQcmVjb21wdXRlZCBSY29uIGxvb2t1cFxuXHQgICAgdmFyIFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBBRVMgPSBDX2FsZ28uQUVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTa2lwIHJlc2V0IG9mIG5Sb3VuZHMgaGFzIGJlZW4gc2V0IGJlZm9yZSBhbmQga2V5IGRpZCBub3QgY2hhbmdlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBrZXlTaXplID0ga2V5LnNpZ0J5dGVzIC8gNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXG5cdCAgICAgICAgICAgIHZhciBrZXlTY2hlZHVsZSA9IHRoaXMuX2tleVNjaGVkdWxlID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtzUm93ID0gMDsga3NSb3cgPCBrc1Jvd3M7IGtzUm93KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vZXZwa2RmXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2V2cGtkZlwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBYT1IgYmxvY2tzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGJsb2NrW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIENCQztcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3BhZCA9IEMucGFkID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogUEtDUyAjNS83IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQa2NzNyA9IENfcGFkLlBrY3M3ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KSB8IChuUGFkZGluZ0J5dGVzIDw8IDE2KSB8IChuUGFkZGluZ0J5dGVzIDw8IDgpIHwgblBhZGRpbmdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhZGRpbmdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSBXb3JkQXJyYXkuY3JlYXRlKHBhZGRpbmdXb3JkcywgblBhZGRpbmdCeXRlcyk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byB1bnBhZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnVucGFkKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBudW1iZXIgb2YgcGFkZGluZyBieXRlcyBmcm9tIGxhc3QgYnl0ZVxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgICAgIC8vIFJlbW92ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG1vZGU6IENCQyxcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZUVuY3J5cHRvcjtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09IG1vZGVDcmVhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLmluaXQodGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPSBtb2RlQ3JlYXRvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XG5cblx0ICAgICAgICAgICAgLy8gRmluYWxpemVcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xuXHQgICAgICAgICAgICAgICAgLy8gUGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcucGFkKHRoaXMuX2RhdGEsIHRoaXMuYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gY2lwaGVyUGFyYW1zLnNhbHQ7XG5cblx0ICAgICAgICAgICAgLy8gRm9ybWF0XG5cdCAgICAgICAgICAgIGlmIChzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgdmFyIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBzYWx0IGZyb20gY2lwaGVydGV4dFxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQuc2lnQnl0ZXMgLT0gMTY7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgU2VyaWFsaXphYmxlQ2lwaGVyID0gQ19saWIuU2VyaWFsaXphYmxlQ2lwaGVyID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBlbmNyeXB0b3IgPSBjaXBoZXIuY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dCxcblx0ICAgICAgICAgICAgICAgIGtleToga2V5LFxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcblx0ICAgICAgICAgICAgICAgIGFsZ29yaXRobTogY2lwaGVyLFxuXHQgICAgICAgICAgICAgICAgbW9kZTogY2lwaGVyQ2ZnLm1vZGUsXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcblx0ICAgICAgICAgICAgICAgIGJsb2NrU2l6ZTogY2lwaGVyLmJsb2NrU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogY2ZnLmZvcm1hdFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY2lwaGVyLmNyZWF0ZURlY3J5cHRvcihrZXksIGNmZykuZmluYWxpemUoY2lwaGVydGV4dC5jaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdG8gQ2lwaGVyUGFyYW1zLFxuXHQgICAgICAgICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSB1bnNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5wYXJzZShjaXBoZXJ0ZXh0LCB0aGlzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogS2V5IGRlcml2YXRpb24gZnVuY3Rpb24gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgKi9cblx0ICAgIHZhciBPcGVuU1NMS2RmID0gQ19rZGYuT3BlblNTTCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrZXlTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBrZXkgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGl2U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUgSVYgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBleGVjdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIGtleVNpemUsIGl2U2l6ZSwgc2FsdCkge1xuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxuXHQgICAgICAgICAgICBpZiAoIXNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkucmFuZG9tKDY0LzgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIFNlcGFyYXRlIGtleSBhbmQgSVZcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xuXHQgICAgICAgICAgICBrZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsga2V5OiBrZXksIGl2OiBpdiwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcblx0ICAgICAqIGFuZCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7S0RGfSBrZGYgVGhlIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSB0byBnZW5lcmF0ZSBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGtkZjogT3BlblNTTEtkZlxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIG1lc3NhZ2UsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIE1peCBpbiBkZXJpdmVkIHBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0Lm1peEluKGRlcml2ZWRQYXJhbXMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIG90aGVyIHBhcmFtc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IGNmZy5rZGYuZXhlY3V0ZShwYXNzd29yZCwgY2lwaGVyLmtleVNpemUsIGNpcGhlci5pdlNpemUsIGNpcGhlcnRleHQuc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBjaXBoZXJ0ZXh0LCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbCBvZiBPYmplY3QuY3JlYXRlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9O1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1fdyA9IG1fdztcblx0ICAgICAgICAgICAgICAgIHZhciBtX3ogPSAweDNhZGU2OGIxO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1feiA9ICgweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICgobV96IDw8IDB4MTApICsgbV93KSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gLjUgPyAxIDogLTEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcmNhY2hlOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuXHQgICAgICAgICAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKChfcigpICogMHgxMDAwMDAwMDApIHwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSAgICAgICA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAgICAgICAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUzID0gKHdvcmRzWyhpICsgMikgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAyKSAlIDQpICogOCkpICYgMHhmZjtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB3aGlsZSAoYmFzZTY0Q2hhcnMubGVuZ3RoICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnBhcnNlKGJhc2U2NFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChiYXNlNjRTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApIHtcblx0ICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgIHZhciBuQnl0ZXMgPSAwO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcblx0ICAgICAgICAgICAgICB2YXIgYml0czEgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkgLSAxKV0gPDwgKChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSAoYml0czEgfCBiaXRzMikgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgbkJ5dGVzKys7XG5cdCAgICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG5cdCAgICB9XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkJhc2U2NDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZjtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnBhcnNlKHV0ZjE2U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTE2IExFIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICBDX2VuYy5VdGYxNkxFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IExFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNkNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcblx0ICAgICAgICAgICAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmMTZTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXRmMTZTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc3dhcEVuZGlhbih3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuICgod29yZCA8PCA4KSAmIDB4ZmYwMGZmMDApIHwgKCh3b3JkID4+PiA4KSAmIDB4MDBmZjAwZmYpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5VdGYxNjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGExXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3NoYTFcIiwgXCIuL2htYWNcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDU7XG5cblx0ICAgIC8qKlxuXHQgICAgICogVGhpcyBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBpcyBtZWFudCB0byBjb25mb3JtIHdpdGggRVZQX0J5dGVzVG9LZXkuXG5cdCAgICAgKiB3d3cub3BlbnNzbC5vcmcvZG9jcy9jcnlwdG8vRVZQX0J5dGVzVG9LZXkuaHRtbFxuXHQgICAgICovXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGl0ZXJhdGlvbnMgVGhlIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm0uIERlZmF1bHQ6IDFcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2V5U2l6ZTogMTI4LzMyLFxuXHQgICAgICAgICAgICBoYXNoZXI6IE1ENSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuXHQgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGlvbnNcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkZXJpdmVkS2V5LmNvbmNhdChibG9jayk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5FdnBLREYgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLkV2cEtERjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcztcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleDtcblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0O1xuXG5cdCAgICB2YXIgSGV4Rm9ybWF0dGVyID0gQ19mb3JtYXQuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoZSBjaXBoZXJ0ZXh0IG9mIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0LnRvU3RyaW5nKEhleCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIGNpcGhlcnRleHQgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGlucHV0KSB7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuZm9ybWF0LkhleDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIiksIHJlcXVpcmUoXCIuL2xpYi10eXBlZGFycmF5c1wiKSwgcmVxdWlyZShcIi4vZW5jLXV0ZjE2XCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL3NoYTFcIiksIHJlcXVpcmUoXCIuL3NoYTI1NlwiKSwgcmVxdWlyZShcIi4vc2hhMjI0XCIpLCByZXF1aXJlKFwiLi9zaGE1MTJcIiksIHJlcXVpcmUoXCIuL3NoYTM4NFwiKSwgcmVxdWlyZShcIi4vc2hhM1wiKSwgcmVxdWlyZShcIi4vcmlwZW1kMTYwXCIpLCByZXF1aXJlKFwiLi9obWFjXCIpLCByZXF1aXJlKFwiLi9wYmtkZjJcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIiksIHJlcXVpcmUoXCIuL21vZGUtY2ZiXCIpLCByZXF1aXJlKFwiLi9tb2RlLWN0clwiKSwgcmVxdWlyZShcIi4vbW9kZS1jdHItZ2xhZG1hblwiKSwgcmVxdWlyZShcIi4vbW9kZS1vZmJcIiksIHJlcXVpcmUoXCIuL21vZGUtZWNiXCIpLCByZXF1aXJlKFwiLi9wYWQtYW5zaXg5MjNcIiksIHJlcXVpcmUoXCIuL3BhZC1pc28xMDEyNlwiKSwgcmVxdWlyZShcIi4vcGFkLWlzbzk3OTcxXCIpLCByZXF1aXJlKFwiLi9wYWQtemVyb3BhZGRpbmdcIiksIHJlcXVpcmUoXCIuL3BhZC1ub3BhZGRpbmdcIiksIHJlcXVpcmUoXCIuL2Zvcm1hdC1oZXhcIiksIHJlcXVpcmUoXCIuL2Flc1wiKSwgcmVxdWlyZShcIi4vdHJpcGxlZGVzXCIpLCByZXF1aXJlKFwiLi9yYzRcIiksIHJlcXVpcmUoXCIuL3JhYmJpdFwiKSwgcmVxdWlyZShcIi4vcmFiYml0LWxlZ2FjeVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi94NjQtY29yZVwiLCBcIi4vbGliLXR5cGVkYXJyYXlzXCIsIFwiLi9lbmMtdXRmMTZcIiwgXCIuL2VuYy1iYXNlNjRcIiwgXCIuL21kNVwiLCBcIi4vc2hhMVwiLCBcIi4vc2hhMjU2XCIsIFwiLi9zaGEyMjRcIiwgXCIuL3NoYTUxMlwiLCBcIi4vc2hhMzg0XCIsIFwiLi9zaGEzXCIsIFwiLi9yaXBlbWQxNjBcIiwgXCIuL2htYWNcIiwgXCIuL3Bia2RmMlwiLCBcIi4vZXZwa2RmXCIsIFwiLi9jaXBoZXItY29yZVwiLCBcIi4vbW9kZS1jZmJcIiwgXCIuL21vZGUtY3RyXCIsIFwiLi9tb2RlLWN0ci1nbGFkbWFuXCIsIFwiLi9tb2RlLW9mYlwiLCBcIi4vbW9kZS1lY2JcIiwgXCIuL3BhZC1hbnNpeDkyM1wiLCBcIi4vcGFkLWlzbzEwMTI2XCIsIFwiLi9wYWQtaXNvOTc5NzFcIiwgXCIuL3BhZC16ZXJvcGFkZGluZ1wiLCBcIi4vcGFkLW5vcGFkZGluZ1wiLCBcIi4vZm9ybWF0LWhleFwiLCBcIi4vYWVzXCIsIFwiLi90cmlwbGVkZXNcIiwgXCIuL3JjNFwiLCBcIi4vcmFiYml0XCIsIFwiLi9yYWJiaXQtbGVnYWN5XCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcblx0ICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgaW5pdFxuXHQgICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG5cdCAgICAvLyBBdWdtZW50IFdvcmRBcnJheS5pbml0IHRvIGhhbmRsZSB0eXBlZCBhcnJheXNcblx0ICAgIHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcblx0ICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgc3ViSW5pdC5wcm90b3R5cGUgPSBXb3JkQXJyYXk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXG5cdCAgICB2YXIgVCA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIE1ENSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE1ENSA9IENfYWxnby5NRDUgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksXG5cdCAgICAgICAgICAgICAgICAweDk4YmFkY2ZlLCAweDEwMzI1NDc2XG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG5cdCAgICAgICAgICAgICAgICB2YXIgTV9vZmZzZXRfaSA9IE1bb2Zmc2V0X2ldO1xuXG5cdCAgICAgICAgICAgICAgICBNW29mZnNldF9pXSA9IChcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpICB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzAgID0gTVtvZmZzZXQgKyAwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEgID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzMgID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzQgID0gTVtvZmZzZXQgKyA0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzYgID0gTVtvZmZzZXQgKyA2XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzcgID0gTVtvZmZzZXQgKyA3XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzkgID0gTVtvZmZzZXQgKyA5XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEwID0gTVtvZmZzZXQgKyAxMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTIgPSBNW29mZnNldCArIDEyXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEzID0gTVtvZmZzZXQgKyAxM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTUgPSBNW29mZnNldCArIDE1XTtcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA3LCAgVFswXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xLCAgMTIsIFRbMV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsICAyMiwgVFszXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNywgIFRbNF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNywgVFs2XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAgMjIsIFRbN10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzksICAxMiwgVFs5XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTcsIFRbMTBdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsICBUWzEyXSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF8xMywgMTIsIFRbMTNdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTUsIDIyLCBUWzE1XSk7XG5cblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfNiwgIDksICBUWzE3XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTQsIFRbMThdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDUsICBUWzIwXSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xMCwgOSwgIFRbMjFdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfNCwgIDIwLCBUWzIzXSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNSwgIFRbMjRdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE0LCBUWzI2XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF84LCAgMjAsIFRbMjddKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgIDksICBUWzI5XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTQsIFRbMzBdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNCwgIFRbMzJdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE2LCBUWzM0XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfNCwgIDExLCBUWzM3XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAgMTYsIFRbMzhdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsICBUWzQwXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8wLCAgMTEsIFRbNDFdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgIDIzLCBUWzQzXSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF85LCAgNCwgIFRbNDRdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8yLCAgMjMsIFRbNDddKTtcblxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDYsICBUWzQ4XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAgMTAsIFRbNDldKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgIDIxLCBUWzUxXSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNiwgIFRbNTJdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xLCAgMjEsIFRbNTVdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTUsIFRbNThdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDYsICBUWzYwXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xMSwgMTAsIFRbNjFdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfOSwgIDIxLCBUWzYzXSk7XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgIHwgKG5CaXRzVG90YWxMID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEwgPDwgMjQpIHwgKG5CaXRzVG90YWxMID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gKGRhdGFXb3Jkcy5sZW5ndGggKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2hhc2g7XG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBIX2kgPSBIW2ldO1xuXG5cdCAgICAgICAgICAgICAgICBIW2ldID0gKCgoSF9pIDw8IDgpICB8IChIX2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBGRihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBHRyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgZCkgfCAoYyAmIH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBJSShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY01ENShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuTUQ1O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIEZlZWRiYWNrIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkNGQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgQ0ZCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgQ0ZCLkVuY3J5cHRvciA9IENGQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcblxuXHQgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBDRkIuRGVjcnlwdG9yID0gQ0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGNpcGhlci5ibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgZ2VuZXJhdGVLZXlzdHJlYW1BbmRFbmNyeXB0LmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpO1xuXG5cdCAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQod29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSBpdi5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSB0aGlzLl9wcmV2QmxvY2s7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBDRkI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DRkI7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKiBAcHJlc2VydmVcblx0ICogQ291bnRlciBibG9jayBtb2RlIGNvbXBhdGlibGUgd2l0aCAgRHIgQnJpYW4gR2xhZG1hbiBmaWxlZW5jLmNcblx0ICogZGVyaXZlZCBmcm9tIENyeXB0b0pTLm1vZGUuQ1RSXG5cdCAqIEphbiBIcnVieSBqaHJ1Ynkud2ViQGdtYWlsLmNvbVxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBDVFJHbGFkbWFuID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHRcdGZ1bmN0aW9uIGluY1dvcmQod29yZClcblx0XHR7XG5cdFx0XHRpZiAoKCh3b3JkID4+IDI0KSAmIDB4ZmYpID09PSAweGZmKSB7IC8vb3ZlcmZsb3dcblx0XHRcdHZhciBiMSA9ICh3b3JkID4+IDE2KSYweGZmO1xuXHRcdFx0dmFyIGIyID0gKHdvcmQgPj4gOCkmMHhmZjtcblx0XHRcdHZhciBiMyA9IHdvcmQgJiAweGZmO1xuXG5cdFx0XHRpZiAoYjEgPT09IDB4ZmYpIC8vIG92ZXJmbG93IGIxXG5cdFx0XHR7XG5cdFx0XHRiMSA9IDA7XG5cdFx0XHRpZiAoYjIgPT09IDB4ZmYpXG5cdFx0XHR7XG5cdFx0XHRcdGIyID0gMDtcblx0XHRcdFx0aWYgKGIzID09PSAweGZmKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YjMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdCsrYjM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0KytiMjtcblx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdCsrYjE7XG5cdFx0XHR9XG5cblx0XHRcdHdvcmQgPSAwO1xuXHRcdFx0d29yZCArPSAoYjEgPDwgMTYpO1xuXHRcdFx0d29yZCArPSAoYjIgPDwgOCk7XG5cdFx0XHR3b3JkICs9IGIzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0d29yZCArPSAoMHgwMSA8PCAyNCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gd29yZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmNDb3VudGVyKGNvdW50ZXIpXG5cdFx0e1xuXHRcdFx0aWYgKChjb3VudGVyWzBdID0gaW5jV29yZChjb3VudGVyWzBdKSkgPT09IDApXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGVuY3JfZGF0YSBpbiBmaWxlZW5jLmMgZnJvbSAgRHIgQnJpYW4gR2xhZG1hbidzIGNvdW50cyBvbmx5IHdpdGggRFdPUkQgaiA8IDhcblx0XHRcdFx0Y291bnRlclsxXSA9IGluY1dvcmQoY291bnRlclsxXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY291bnRlcjtcblx0XHR9XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBDVFJHbGFkbWFuLkVuY3J5cHRvciA9IENUUkdsYWRtYW4uZXh0ZW5kKHtcblx0ICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblx0ICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cblx0XHRcdFx0aW5jQ291bnRlcihjb3VudGVyKTtcblxuXHRcdFx0XHR2YXIga2V5c3RyZWFtID0gY291bnRlci5zbGljZSgwKTtcblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENUUkdsYWRtYW4uRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gQ1RSR2xhZG1hbjtcblx0fSgpKTtcblxuXG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFJHbGFkbWFuO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ291bnRlciBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5DVFIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIENUUiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBDVFIuRW5jcnlwdG9yID0gQ1RSLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlciA9IGl2LnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIga2V5c3RyZWFtID0gY291bnRlci5zbGljZSgwKTtcblx0ICAgICAgICAgICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG5cdCAgICAgICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyXG5cdCAgICAgICAgICAgIGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gPSAoY291bnRlcltibG9ja1NpemUgLSAxXSArIDEpIHwgMFxuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENUUi5EZWNyeXB0b3IgPSBFbmNyeXB0b3I7XG5cblx0ICAgIHJldHVybiBDVFI7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubW9kZS5DVFI7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBFbGVjdHJvbmljIENvZGVib29rIGJsb2NrIG1vZGUuXG5cdCAqL1xuXHRDcnlwdG9KUy5tb2RlLkVDQiA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgRUNCID0gQ3J5cHRvSlMubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcblxuXHQgICAgRUNCLkVuY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgRUNCLkRlY3J5cHRvciA9IEVDQi5leHRlbmQoe1xuXHQgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIEVDQjtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5tb2RlLkVDQjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9jaXBoZXItY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9jaXBoZXItY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIE91dHB1dCBGZWVkYmFjayBibG9jayBtb2RlLlxuXHQgKi9cblx0Q3J5cHRvSlMubW9kZS5PRkIgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIE9GQiA9IENyeXB0b0pTLmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgIHZhciBFbmNyeXB0b3IgPSBPRkIuRW5jcnlwdG9yID0gT0ZCLmV4dGVuZCh7XG5cdCAgICAgICAgcHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5faXY7XG5cdCAgICAgICAgICAgIHZhciBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW07XG5cblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAga2V5c3RyZWFtID0gdGhpcy5fa2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuXHQgICAgICAgICAgICAvLyBFbmNyeXB0XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBPRkIuRGVjcnlwdG9yID0gRW5jcnlwdG9yO1xuXG5cdCAgICByZXR1cm4gT0ZCO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLm1vZGUuT0ZCO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQU5TSSBYLjkyMyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgKi9cblx0Q3J5cHRvSlMucGFkLkFuc2lYOTIzID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIGRhdGFTaWdCeXRlcyA9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YVNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAvLyBDb21wdXRlIGxhc3QgYnl0ZSBwb3NpdGlvblxuXHQgICAgICAgIHZhciBsYXN0Qnl0ZVBvcyA9IGRhdGFTaWdCeXRlcyArIG5QYWRkaW5nQnl0ZXMgLSAxO1xuXG5cdCAgICAgICAgLy8gUGFkXG5cdCAgICAgICAgZGF0YS5jbGFtcCgpO1xuXHQgICAgICAgIGRhdGEud29yZHNbbGFzdEJ5dGVQb3MgPj4+IDJdIHw9IG5QYWRkaW5nQnl0ZXMgPDwgKDI0IC0gKGxhc3RCeXRlUG9zICUgNCkgKiA4KTtcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzICs9IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLkFuc2l4OTIzO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogSVNPIDEwMTI2IHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuSXNvMTAxMjYgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBibG9ja1NpemVCeXRlcyAtIGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgIC8vIFBhZFxuXHQgICAgICAgIGRhdGEuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKG5QYWRkaW5nQnl0ZXMgLSAxKSkuXG5cdCAgICAgICAgICAgICBjb25jYXQoQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW25QYWRkaW5nQnl0ZXMgPDwgMjRdLCAxKSk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xuXG5cdCAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzEwMTI2O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogSVNPL0lFQyA5Nzk3LTEgUGFkZGluZyBNZXRob2QgMi5cblx0ICovXG5cdENyeXB0b0pTLnBhZC5Jc285Nzk3MSA9IHtcblx0ICAgIHBhZDogZnVuY3Rpb24gKGRhdGEsIGJsb2NrU2l6ZSkge1xuXHQgICAgICAgIC8vIEFkZCAweDgwIGJ5dGVcblx0ICAgICAgICBkYXRhLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHg4MDAwMDAwMF0sIDEpKTtcblxuXHQgICAgICAgIC8vIFplcm8gcGFkIHRoZSByZXN0XG5cdCAgICAgICAgQ3J5cHRvSlMucGFkLlplcm9QYWRkaW5nLnBhZChkYXRhLCBibG9ja1NpemUpO1xuXHQgICAgfSxcblxuXHQgICAgdW5wYWQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgLy8gUmVtb3ZlIHplcm8gcGFkZGluZ1xuXHQgICAgICAgIENyeXB0b0pTLnBhZC5aZXJvUGFkZGluZy51bnBhZChkYXRhKTtcblxuXHQgICAgICAgIC8vIFJlbW92ZSBvbmUgbW9yZSBieXRlIC0tIHRoZSAweDgwIGJ5dGVcblx0ICAgICAgICBkYXRhLnNpZ0J5dGVzLS07XG5cdCAgICB9XG5cdH07XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMucGFkLklzbzk3OTcxO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL2NpcGhlci1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQSBub29wIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuTm9QYWRkaW5nID0ge1xuXHQgICAgcGFkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKCkge1xuXHQgICAgfVxuXHR9O1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLnBhZC5Ob1BhZGRpbmc7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vY2lwaGVyLWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdC8qKlxuXHQgKiBaZXJvIHBhZGRpbmcgc3RyYXRlZ3kuXG5cdCAqL1xuXHRDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmcgPSB7XG5cdCAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAvLyBQYWRcblx0ICAgICAgICBkYXRhLmNsYW1wKCk7XG5cdCAgICAgICAgZGF0YS5zaWdCeXRlcyArPSBibG9ja1NpemVCeXRlcyAtICgoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKSB8fCBibG9ja1NpemVCeXRlcyk7XG5cdCAgICB9LFxuXG5cdCAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgLy8gVW5wYWRcblx0ICAgICAgICB2YXIgaSA9IGRhdGEuc2lnQnl0ZXMgLSAxO1xuXHQgICAgICAgIHdoaWxlICghKChkYXRhV29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmKSkge1xuXHQgICAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBpICsgMTtcblx0ICAgIH1cblx0fTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5wYWQuWmVyb1BhZGRpbmc7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhMVwiKSwgcmVxdWlyZShcIi4vaG1hY1wiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCIsIFwiLi9zaGExXCIsIFwiLi9obWFjXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEExID0gQ19hbGdvLlNIQTE7XG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgUEJLREYyID0gQ19hbGdvLlBCS0RGMiA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UuIERlZmF1bHQ6IFNIQTFcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogU0hBMSxcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uUEJLREYyLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb21wdXRlcyB0aGUgUGFzc3dvcmQtQmFzZWQgS2V5IERlcml2YXRpb24gRnVuY3Rpb24gMi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGtleSA9IGtkZi5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgSE1BQ1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IEhNQUMuY3JlYXRlKGNmZy5oYXNoZXIsIHBhc3N3b3JkKTtcblxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleSA9IFdvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrSW5kZXggPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAxXSk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tJbmRleFdvcmRzID0gYmxvY2tJbmRleC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBobWFjLnVwZGF0ZShzYWx0KS5maW5hbGl6ZShibG9ja0luZGV4KTtcblx0ICAgICAgICAgICAgICAgIGhtYWMucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tXb3JkcyA9IGJsb2NrLndvcmRzO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrV29yZHNMZW5ndGggPSBibG9ja1dvcmRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgdmFyIGludGVybWVkaWF0ZSA9IGJsb2NrO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSBobWFjLmZpbmFsaXplKGludGVybWVkaWF0ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaG1hYy5yZXNldCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJtZWRpYXRlV29yZHMgPSBpbnRlcm1lZGlhdGUud29yZHM7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBYT1IgaW50ZXJtZWRpYXRlIHdpdGggYmxvY2tcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrV29yZHNMZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1dvcmRzW2pdIF49IGludGVybWVkaWF0ZVdvcmRzW2pdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgYmxvY2tJbmRleFdvcmRzWzBdKys7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkZXJpdmVkS2V5O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBjb21wdXRhdGlvbi5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5QQktERjIocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAqL1xuXHQgICAgQy5QQktERjIgPSBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQsIGNmZykge1xuXHQgICAgICAgIHJldHVybiBQQktERjIuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlBCS0RGMjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFMgID0gW107XG5cdCAgICB2YXIgQ18gPSBbXTtcblx0ICAgIHZhciBHICA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGlzIGlzIGEgbGVnYWN5IHZlcnNpb24gdGhhdCBuZWdsZWN0ZWQgdG8gY29udmVydCB0aGUga2V5IHRvIGxpdHRsZS1lbmRpYW4uXG5cdCAgICAgKiBUaGlzIGVycm9yIGRvZXNuJ3QgYWZmZWN0IHRoZSBjaXBoZXIncyBzZWN1cml0eSxcblx0ICAgICAqIGJ1dCBpdCBkb2VzIGFmZmVjdCBpdHMgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cblx0ICAgICAqL1xuXHQgICAgdmFyIFJhYmJpdExlZ2FjeSA9IENfYWxnby5SYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEsgPSB0aGlzLl9rZXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuY2ZnLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWCA9IFtcblx0ICAgICAgICAgICAgICAgIEtbMF0sIChLWzNdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzFdLCAoS1swXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1syXSwgKEtbMV0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbM10sIChLWzJdIDw8IDE2KSB8IChLWzFdID4+PiAxNilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBDID0gdGhpcy5fQyA9IFtcblx0ICAgICAgICAgICAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gQ2FycnkgYml0XG5cdCAgICAgICAgICAgIHRoaXMuX2IgPSAwO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIENbaV0gXj0gWFsoaSArIDQpICYgN107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJViBzZXR1cFxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIElWID0gaXYud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMCA9IElWWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzEgPSBJVlsxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG5cdCAgICAgICAgICAgICAgICB2YXIgaTAgPSAoKChJVl8wIDw8IDgpIHwgKElWXzAgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzAgPDwgMjQpIHwgKElWXzAgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMSA9IChpMCA+Pj4gMTYpIHwgKGkyICYgMHhmZmZmMDAwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTMgPSAoaTIgPDwgMTYpICB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIENbMF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzFdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1syXSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbM10gXj0gaTM7XG5cdCAgICAgICAgICAgICAgICBDWzRdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1s1XSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbNl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzddIF49IGkzO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXHQgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIGtleXN0cmVhbSB3b3Jkc1xuXHQgICAgICAgICAgICBTWzBdID0gWFswXSBeIChYWzVdID4+PiAxNikgXiAoWFszXSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1syXSA9IFhbNF0gXiAoWFsxXSA+Pj4gMTYpIF4gKFhbN10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzNdID0gWFs2XSBeIChYWzNdID4+PiAxNikgXiAoWFsxXSA8PCAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSAgfCAoU1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXHQgICAgICAgIHZhciBDID0gdGhpcy5fQztcblxuXHQgICAgICAgIC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgQ19baV0gPSBDW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBDWzBdID0gKENbMF0gKyAweDRkMzRkMzRkICsgdGhpcy5fYikgfCAwO1xuXHQgICAgICAgIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbM10gPSAoQ1szXSArIDB4NGQzNGQzNGQgKyAoKENbMl0gPj4+IDApIDwgKENfWzJdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNl0gPSAoQ1s2XSArIDB4NGQzNGQzNGQgKyAoKENbNV0gPj4+IDApIDwgKENfWzVdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGctdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGd4ID0gWFtpXSArIENbaV07XG5cblx0ICAgICAgICAgICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdhID0gZ3ggJiAweGZmZmY7XG5cdCAgICAgICAgICAgIHZhciBnYiA9IGd4ID4+PiAxNjtcblxuXHQgICAgICAgICAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSAoKCgoZ2EgKiBnYSkgPj4+IDE3KSArIGdhICogZ2IpID4+PiAxNSkgKyBnYiAqIGdiO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSGlnaCBYT1IgbG93XG5cdCAgICAgICAgICAgIEdbaV0gPSBnaCBeIGdsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFsxXSA9IChHWzFdICsgKChHWzBdIDw8IDgpICB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuXHQgICAgICAgIFhbMl0gPSAoR1syXSArICgoR1sxXSA8PCAxNikgfCAoR1sxXSA+Pj4gMTYpKSArICgoR1swXSA8PCAxNikgfCAoR1swXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSAgfCAoR1syXSA+Pj4gMjQpKSArIEdbMV0pIHwgMDtcblx0ICAgICAgICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG5cdCAgICAgICAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs3XSA9IChHWzddICsgKChHWzZdIDw8IDgpICB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJhYmJpdExlZ2FjeS5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJhYmJpdExlZ2FjeS5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRMZWdhY3kpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJhYmJpdExlZ2FjeTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0c1xuXHQgICAgdmFyIFMgID0gW107XG5cdCAgICB2YXIgQ18gPSBbXTtcblx0ICAgIHZhciBHICA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobVxuXHQgICAgICovXG5cdCAgICB2YXIgUmFiYml0ID0gQ19hbGdvLlJhYmJpdCA9IFN0cmVhbUNpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSyA9IHRoaXMuX2tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGl2ID0gdGhpcy5jZmcuaXY7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIEtbaV0gPSAoKChLW2ldIDw8IDgpICB8IChLW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEtbaV0gPDwgMjQpIHwgKEtbaV0gPj4+IDgpKSAgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBYID0gdGhpcy5fWCA9IFtcblx0ICAgICAgICAgICAgICAgIEtbMF0sIChLWzNdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksXG5cdCAgICAgICAgICAgICAgICBLWzFdLCAoS1swXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLFxuXHQgICAgICAgICAgICAgICAgS1syXSwgKEtbMV0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSxcblx0ICAgICAgICAgICAgICAgIEtbM10sIChLWzJdIDw8IDE2KSB8IChLWzFdID4+PiAxNilcblx0ICAgICAgICAgICAgXTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBDID0gdGhpcy5fQyA9IFtcblx0ICAgICAgICAgICAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuXHQgICAgICAgICAgICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG5cdCAgICAgICAgICAgICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcblx0ICAgICAgICAgICAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpXG5cdCAgICAgICAgICAgIF07XG5cblx0ICAgICAgICAgICAgLy8gQ2FycnkgYml0XG5cdCAgICAgICAgICAgIHRoaXMuX2IgPSAwO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIENbaV0gXj0gWFsoaSArIDQpICYgN107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJViBzZXR1cFxuXHQgICAgICAgICAgICBpZiAoaXYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIElWID0gaXYud29yZHM7XG5cdCAgICAgICAgICAgICAgICB2YXIgSVZfMCA9IElWWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIElWXzEgPSBJVlsxXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgZm91ciBzdWJ2ZWN0b3JzXG5cdCAgICAgICAgICAgICAgICB2YXIgaTAgPSAoKChJVl8wIDw8IDgpIHwgKElWXzAgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8ICgoKElWXzAgPDwgMjQpIHwgKElWXzAgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpMSA9IChpMCA+Pj4gMTYpIHwgKGkyICYgMHhmZmZmMDAwMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgaTMgPSAoaTIgPDwgMTYpICB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIENbMF0gXj0gaTA7XG5cdCAgICAgICAgICAgICAgICBDWzFdIF49IGkxO1xuXHQgICAgICAgICAgICAgICAgQ1syXSBePSBpMjtcblx0ICAgICAgICAgICAgICAgIENbM10gXj0gaTM7XG5cdCAgICAgICAgICAgICAgICBDWzRdIF49IGkwO1xuXHQgICAgICAgICAgICAgICAgQ1s1XSBePSBpMTtcblx0ICAgICAgICAgICAgICAgIENbNl0gXj0gaTI7XG5cdCAgICAgICAgICAgICAgICBDWzddIF49IGkzO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXG5cdCAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuXHQgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBmb3VyIGtleXN0cmVhbSB3b3Jkc1xuXHQgICAgICAgICAgICBTWzBdID0gWFswXSBeIChYWzVdID4+PiAxNikgXiAoWFszXSA8PCAxNik7XG5cdCAgICAgICAgICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcblx0ICAgICAgICAgICAgU1syXSA9IFhbNF0gXiAoWFsxXSA+Pj4gMTYpIF4gKFhbN10gPDwgMTYpO1xuXHQgICAgICAgICAgICBTWzNdID0gWFs2XSBeIChYWzNdID4+PiAxNikgXiAoWFsxXSA8PCAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSAgfCAoU1tpXSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBuZXh0U3RhdGUoKSB7XG5cdCAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgdmFyIFggPSB0aGlzLl9YO1xuXHQgICAgICAgIHZhciBDID0gdGhpcy5fQztcblxuXHQgICAgICAgIC8vIFNhdmUgb2xkIGNvdW50ZXIgdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgQ19baV0gPSBDW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcblx0ICAgICAgICBDWzBdID0gKENbMF0gKyAweDRkMzRkMzRkICsgdGhpcy5fYikgfCAwO1xuXHQgICAgICAgIENbMV0gPSAoQ1sxXSArIDB4ZDM0ZDM0ZDMgKyAoKENbMF0gPj4+IDApIDwgKENfWzBdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbM10gPSAoQ1szXSArIDB4NGQzNGQzNGQgKyAoKENbMl0gPj4+IDApIDwgKENfWzJdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNF0gPSAoQ1s0XSArIDB4ZDM0ZDM0ZDMgKyAoKENbM10gPj4+IDApIDwgKENfWzNdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbNl0gPSAoQ1s2XSArIDB4NGQzNGQzNGQgKyAoKENbNV0gPj4+IDApIDwgKENfWzVdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIENbN10gPSAoQ1s3XSArIDB4ZDM0ZDM0ZDMgKyAoKENbNl0gPj4+IDApIDwgKENfWzZdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuXHQgICAgICAgIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cblx0ICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGctdmFsdWVzXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGd4ID0gWFtpXSArIENbaV07XG5cblx0ICAgICAgICAgICAgLy8gQ29uc3RydWN0IGhpZ2ggYW5kIGxvdyBhcmd1bWVudCBmb3Igc3F1YXJpbmdcblx0ICAgICAgICAgICAgdmFyIGdhID0gZ3ggJiAweGZmZmY7XG5cdCAgICAgICAgICAgIHZhciBnYiA9IGd4ID4+PiAxNjtcblxuXHQgICAgICAgICAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuXHQgICAgICAgICAgICB2YXIgZ2ggPSAoKCgoZ2EgKiBnYSkgPj4+IDE3KSArIGdhICogZ2IpID4+PiAxNSkgKyBnYiAqIGdiO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSAoKChneCAmIDB4ZmZmZjAwMDApICogZ3gpIHwgMCkgKyAoKChneCAmIDB4MDAwMGZmZmYpICogZ3gpIHwgMCk7XG5cblx0ICAgICAgICAgICAgLy8gSGlnaCBYT1IgbG93XG5cdCAgICAgICAgICAgIEdbaV0gPSBnaCBeIGdsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhdGUgdmFsdWVzXG5cdCAgICAgICAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFsxXSA9IChHWzFdICsgKChHWzBdIDw8IDgpICB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuXHQgICAgICAgIFhbMl0gPSAoR1syXSArICgoR1sxXSA8PCAxNikgfCAoR1sxXSA+Pj4gMTYpKSArICgoR1swXSA8PCAxNikgfCAoR1swXSA+Pj4gMTYpKSkgfCAwO1xuXHQgICAgICAgIFhbM10gPSAoR1szXSArICgoR1syXSA8PCA4KSAgfCAoR1syXSA+Pj4gMjQpKSArIEdbMV0pIHwgMDtcblx0ICAgICAgICBYWzRdID0gKEdbNF0gKyAoKEdbM10gPDwgMTYpIHwgKEdbM10gPj4+IDE2KSkgKyAoKEdbMl0gPDwgMTYpIHwgKEdbMl0gPj4+IDE2KSkpIHwgMDtcblx0ICAgICAgICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgIHwgKEdbNF0gPj4+IDI0KSkgKyBHWzNdKSB8IDA7XG5cdCAgICAgICAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG5cdCAgICAgICAgWFs3XSA9IChHWzddICsgKChHWzZdIDw8IDgpICB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJhYmJpdC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJhYmJpdC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5SYWJiaXQgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJhYmJpdDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSQzQgPSBDX2FsZ28uUkM0ID0gU3RyZWFtQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpZ0J5dGVzID0ga2V5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgc2JveFxuXHQgICAgICAgICAgICB2YXIgUyA9IHRoaXMuX1MgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgU1tpXSA9IGk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBLZXkgc2V0dXBcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCeXRlSW5kZXggPSBpICUga2V5U2lnQnl0ZXM7XG5cdCAgICAgICAgICAgICAgICB2YXIga2V5Qnl0ZSA9IChrZXlXb3Jkc1trZXlCeXRlSW5kZXggPj4+IDJdID4+PiAoMjQgLSAoa2V5Qnl0ZUluZGV4ICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICBqID0gKGogKyBTW2ldICsga2V5Qnl0ZSkgJSAyNTY7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXBcblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gU1tpXTtcblx0ICAgICAgICAgICAgICAgIFNbaV0gPSBTW2pdO1xuXHQgICAgICAgICAgICAgICAgU1tqXSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudGVyc1xuXHQgICAgICAgICAgICB0aGlzLl9pID0gdGhpcy5faiA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICBNW29mZnNldF0gXj0gZ2VuZXJhdGVLZXlzdHJlYW1Xb3JkLmNhbGwodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtV29yZCgpIHtcblx0ICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICB2YXIgUyA9IHRoaXMuX1M7XG5cdCAgICAgICAgdmFyIGkgPSB0aGlzLl9pO1xuXHQgICAgICAgIHZhciBqID0gdGhpcy5fajtcblxuXHQgICAgICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbSB3b3JkXG5cdCAgICAgICAgdmFyIGtleXN0cmVhbVdvcmQgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgNDsgbisrKSB7XG5cdCAgICAgICAgICAgIGkgPSAoaSArIDEpICUgMjU2O1xuXHQgICAgICAgICAgICBqID0gKGogKyBTW2ldKSAlIDI1NjtcblxuXHQgICAgICAgICAgICAvLyBTd2FwXG5cdCAgICAgICAgICAgIHZhciB0ID0gU1tpXTtcblx0ICAgICAgICAgICAgU1tpXSA9IFNbal07XG5cdCAgICAgICAgICAgIFNbal0gPSB0O1xuXG5cdCAgICAgICAgICAgIGtleXN0cmVhbVdvcmQgfD0gU1soU1tpXSArIFNbal0pICUgMjU2XSA8PCAoMjQgLSBuICogOCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gVXBkYXRlIGNvdW50ZXJzXG5cdCAgICAgICAgdGhpcy5faSA9IGk7XG5cdCAgICAgICAgdGhpcy5faiA9IGo7XG5cblx0ICAgICAgICByZXR1cm4ga2V5c3RyZWFtV29yZDtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SQzQuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzQuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUkM0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RpZmllZCBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSQzREcm9wID0gQ19hbGdvLlJDNERyb3AgPSBSQzQuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZHJvcCBUaGUgbnVtYmVyIG9mIGtleXN0cmVhbSB3b3JkcyB0byBkcm9wLiBEZWZhdWx0IDE5MlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogUkM0LmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBkcm9wOiAxOTJcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIFJDNC5fZG9SZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIERyb3Bcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuY2ZnLmRyb3A7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0RHJvcC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJDNERyb3AuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgKi9cblx0ICAgIEMuUkM0RHJvcCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNERyb3ApO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlJDNDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqIEBwcmVzZXJ2ZVxuXHQoYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuXHRSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cblx0ICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXHQgICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblx0VEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXHQqL1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIF96bCA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDAsICAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG5cdCAgICAgICAgNywgIDQsIDEzLCAgMSwgMTAsICA2LCAxNSwgIDMsIDEyLCAgMCwgIDksICA1LCAgMiwgMTQsIDExLCAgOCxcblx0ICAgICAgICAzLCAxMCwgMTQsICA0LCAgOSwgMTUsICA4LCAgMSwgIDIsICA3LCAgMCwgIDYsIDEzLCAxMSwgIDUsIDEyLFxuXHQgICAgICAgIDEsICA5LCAxMSwgMTAsICAwLCAgOCwgMTIsICA0LCAxMywgIDMsICA3LCAxNSwgMTQsICA1LCAgNiwgIDIsXG5cdCAgICAgICAgNCwgIDAsICA1LCAgOSwgIDcsIDEyLCAgMiwgMTAsIDE0LCAgMSwgIDMsICA4LCAxMSwgIDYsIDE1LCAxM10pO1xuXHQgICAgdmFyIF96ciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDUsIDE0LCAgNywgIDAsICA5LCAgMiwgMTEsICA0LCAxMywgIDYsIDE1LCAgOCwgIDEsIDEwLCAgMywgMTIsXG5cdCAgICAgICAgNiwgMTEsICAzLCAgNywgIDAsIDEzLCAgNSwgMTAsIDE0LCAxNSwgIDgsIDEyLCAgNCwgIDksICAxLCAgMixcblx0ICAgICAgICAxNSwgIDUsICAxLCAgMywgIDcsIDE0LCAgNiwgIDksIDExLCAgOCwgMTIsICAyLCAxMCwgIDAsICA0LCAxMyxcblx0ICAgICAgICA4LCAgNiwgIDQsICAxLCAgMywgMTEsIDE1LCAgMCwgIDUsIDEyLCAgMiwgMTMsICA5LCAgNywgMTAsIDE0LFxuXHQgICAgICAgIDEyLCAxNSwgMTAsICA0LCAgMSwgIDUsICA4LCAgNywgIDYsICAyLCAxMywgMTQsICAwLCAgMywgIDksIDExXSk7XG5cdCAgICB2YXIgX3NsID0gV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgIDExLCAxNCwgMTUsIDEyLCAgNSwgIDgsICA3LCAgOSwgMTEsIDEzLCAxNCwgMTUsICA2LCAgNywgIDksICA4LFxuXHQgICAgICAgIDcsIDYsICAgOCwgMTMsIDExLCAgOSwgIDcsIDE1LCAgNywgMTIsIDE1LCAgOSwgMTEsICA3LCAxMywgMTIsXG5cdCAgICAgICAgMTEsIDEzLCAgNiwgIDcsIDE0LCAgOSwgMTMsIDE1LCAxNCwgIDgsIDEzLCAgNiwgIDUsIDEyLCAgNywgIDUsXG5cdCAgICAgICAgICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCAgOSwgIDgsICA5LCAxNCwgIDUsICA2LCAgOCwgIDYsICA1LCAxMixcblx0ICAgICAgICA5LCAxNSwgIDUsIDExLCAgNiwgIDgsIDEzLCAxMiwgIDUsIDEyLCAxMywgMTQsIDExLCAgOCwgIDUsICA2IF0pO1xuXHQgICAgdmFyIF9zciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuXHQgICAgICAgIDgsICA5LCAgOSwgMTEsIDEzLCAxNSwgMTUsICA1LCAgNywgIDcsICA4LCAxMSwgMTQsIDE0LCAxMiwgIDYsXG5cdCAgICAgICAgOSwgMTMsIDE1LCAgNywgMTIsICA4LCAgOSwgMTEsICA3LCAgNywgMTIsICA3LCAgNiwgMTUsIDEzLCAxMSxcblx0ICAgICAgICA5LCAgNywgMTUsIDExLCAgOCwgIDYsICA2LCAxNCwgMTIsIDEzLCAgNSwgMTQsIDEzLCAxMywgIDcsICA1LFxuXHQgICAgICAgIDE1LCAgNSwgIDgsIDExLCAxNCwgMTQsICA2LCAxNCwgIDYsICA5LCAxMiwgIDksIDEyLCAgNSwgMTUsICA4LFxuXHQgICAgICAgIDgsICA1LCAxMiwgIDksIDEyLCAgNSwgMTQsICA2LCAgOCwgMTMsICA2LCAgNSwgMTUsIDEzLCAxMSwgMTEgXSk7XG5cblx0ICAgIHZhciBfaGwgPSAgV29yZEFycmF5LmNyZWF0ZShbIDB4MDAwMDAwMDAsIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsIDB4OEYxQkJDREMsIDB4QTk1M0ZENEVdKTtcblx0ICAgIHZhciBfaHIgPSAgV29yZEFycmF5LmNyZWF0ZShbIDB4NTBBMjhCRTYsIDB4NUM0REQxMjQsIDB4NkQ3MDNFRjMsIDB4N0E2RDc2RTksIDB4MDAwMDAwMDBdKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBSSVBFTUQxNjAgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBSSVBFTUQxNjAgPSBDX2FsZ28uUklQRU1EMTYwID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCAgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggID0gdGhpcy5faGFzaC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGhsID0gX2hsLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgaHIgPSBfaHIud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB6bCA9IF96bC53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHpyID0gX3pyLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2wgPSBfc2wud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzciA9IF9zci53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYWwsIGJsLCBjbCwgZGwsIGVsO1xuXHQgICAgICAgICAgICB2YXIgYXIsIGJyLCBjciwgZHIsIGVyO1xuXG5cdCAgICAgICAgICAgIGFyID0gYWwgPSBIWzBdO1xuXHQgICAgICAgICAgICBiciA9IGJsID0gSFsxXTtcblx0ICAgICAgICAgICAgY3IgPSBjbCA9IEhbMl07XG5cdCAgICAgICAgICAgIGRyID0gZGwgPSBIWzNdO1xuXHQgICAgICAgICAgICBlciA9IGVsID0gSFs0XTtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgdmFyIHQ7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuXHQgICAgICAgICAgICAgICAgdCA9IChhbCArICBNW29mZnNldCt6bFtpXV0pfDA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaTwxNil7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjEoYmwsY2wsZGwpICsgaGxbMF07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8MzIpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmMihibCxjbCxkbCkgKyBobFsxXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYzKGJsLGNsLGRsKSArIGhsWzJdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDY0KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjQoYmwsY2wsZGwpICsgaGxbM107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjUoYmwsY2wsZGwpICsgaGxbNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0ID0gdHwwO1xuXHQgICAgICAgICAgICAgICAgdCA9ICByb3RsKHQsc2xbaV0pO1xuXHQgICAgICAgICAgICAgICAgdCA9ICh0K2VsKXwwO1xuXHQgICAgICAgICAgICAgICAgYWwgPSBlbDtcblx0ICAgICAgICAgICAgICAgIGVsID0gZGw7XG5cdCAgICAgICAgICAgICAgICBkbCA9IHJvdGwoY2wsIDEwKTtcblx0ICAgICAgICAgICAgICAgIGNsID0gYmw7XG5cdCAgICAgICAgICAgICAgICBibCA9IHQ7XG5cblx0ICAgICAgICAgICAgICAgIHQgPSAoYXIgKyBNW29mZnNldCt6cltpXV0pfDA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaTwxNil7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjUoYnIsY3IsZHIpICsgaHJbMF07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGk8MzIpIHtcblx0XHQgICAgICAgICAgICB0ICs9ICBmNChicixjcixkcikgKyBoclsxXTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaTw0OCkge1xuXHRcdCAgICAgICAgICAgIHQgKz0gIGYzKGJyLGNyLGRyKSArIGhyWzJdO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpPDY0KSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjIoYnIsY3IsZHIpICsgaHJbM107XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Ugey8vIGlmIChpPDgwKSB7XG5cdFx0ICAgICAgICAgICAgdCArPSAgZjEoYnIsY3IsZHIpICsgaHJbNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0ID0gdHwwO1xuXHQgICAgICAgICAgICAgICAgdCA9ICByb3RsKHQsc3JbaV0pIDtcblx0ICAgICAgICAgICAgICAgIHQgPSAodCtlcil8MDtcblx0ICAgICAgICAgICAgICAgIGFyID0gZXI7XG5cdCAgICAgICAgICAgICAgICBlciA9IGRyO1xuXHQgICAgICAgICAgICAgICAgZHIgPSByb3RsKGNyLCAxMCk7XG5cdCAgICAgICAgICAgICAgICBjciA9IGJyO1xuXHQgICAgICAgICAgICAgICAgYnIgPSB0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIHQgICAgPSAoSFsxXSArIGNsICsgZHIpfDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsyXSArIGRsICsgZXIpfDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFszXSArIGVsICsgYXIpfDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFs0XSArIGFsICsgYnIpfDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFswXSArIGJsICsgY3IpfDA7XG5cdCAgICAgICAgICAgIEhbMF0gPSAgdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWwgPDwgOCkgIHwgKG5CaXRzVG90YWwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcFxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXG5cdCAgICBmdW5jdGlvbiBmMSh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoeCkgXiAoeSkgXiAoeikpO1xuXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGYyKHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkmKHkpKSB8ICgofngpJih6KSkpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmMyh4LCB5LCB6KSB7XG5cdCAgICAgICAgcmV0dXJuICgoKHgpIHwgKH4oeSkpKSBeICh6KSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGY0KHgsIHksIHopIHtcblx0ICAgICAgICByZXR1cm4gKCgoeCkgJiAoeikpIHwgKCh5KSYofih6KSkpKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZjUoeCwgeSwgeikge1xuXHQgICAgICAgIHJldHVybiAoKHgpIF4gKCh5KSB8KH4oeikpKSk7XG5cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcm90bCh4LG4pIHtcblx0ICAgICAgICByZXR1cm4gKHg8PG4pIHwgKHg+Pj4oMzItbikpO1xuXHQgICAgfVxuXG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5SSVBFTUQxNjAoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlJJUEVNRDE2MCA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFJJUEVNRDE2MCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjUklQRU1EMTYwKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1JJUEVNRDE2MCA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihSSVBFTUQxNjApO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5SSVBFTUQxNjA7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMSA9IENfYWxnby5TSEExID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3Nixcblx0ICAgICAgICAgICAgICAgIDB4YzNkMmUxZjBcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXHQgICAgICAgICAgICB2YXIgZSA9IEhbNF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgV1tpXSA9IChuIDw8IDEpIHwgKG4gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIHQgPSAoKGEgPDwgNSkgfCAoYSA+Pj4gMjcpKSArIGUgKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpIDwgNDApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpKSAtIDB4NzBlNDQzMjQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKGkgPCA4MCkgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcblx0ICAgICAgICAgICAgICAgIGQgPSBjO1xuXHQgICAgICAgICAgICAgICAgYyA9IChiIDw8IDMwKSB8IChiID4+PiAyKTtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9IHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMSk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9zaGEyNTZcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vc2hhMjU2XCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yMjQgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyMjQgPSBDX2FsZ28uU0hBMjI0ID0gU0hBMjU2LmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuXHQgICAgICAgICAgICAgICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNFxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSBTSEEyNTYuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICBoYXNoLnNpZ0J5dGVzIC09IDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyMjQoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSGVscGVyKFNIQTIyNCk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjI0KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTIyNCA9IFNIQTI1Ni5fY3JlYXRlSG1hY0hlbHBlcihTSEEyMjQpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTIyNDtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiXSwgZmFjdG9yeSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2xvYmFsIChicm93c2VyKVxuXHRcdGZhY3Rvcnkocm9vdC5DcnlwdG9KUyk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTsiLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5LCB1bmRlZikge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSwgcmVxdWlyZShcIi4veDY0LWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4veDY0LWNvcmVcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX3g2NCA9IEMueDY0O1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlc1xuXHQgICAgdmFyIFJIT19PRkZTRVRTID0gW107XG5cdCAgICB2YXIgUElfSU5ERVhFUyAgPSBbXTtcblx0ICAgIHZhciBST1VORF9DT05TVEFOVFMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBDb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSByaG8gb2Zmc2V0IGNvbnN0YW50c1xuXHQgICAgICAgIHZhciB4ID0gMSwgeSA9IDA7XG5cdCAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG5cdCAgICAgICAgICAgIFJIT19PRkZTRVRTW3ggKyA1ICogeV0gPSAoKHQgKyAxKSAqICh0ICsgMikgLyAyKSAlIDY0O1xuXG5cdCAgICAgICAgICAgIHZhciBuZXdYID0geSAlIDU7XG5cdCAgICAgICAgICAgIHZhciBuZXdZID0gKDIgKiB4ICsgMyAqIHkpICUgNTtcblx0ICAgICAgICAgICAgeCA9IG5ld1g7XG5cdCAgICAgICAgICAgIHkgPSBuZXdZO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbXB1dGUgcGkgaW5kZXggY29uc3RhbnRzXG5cdCAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgIFBJX0lOREVYRVNbeCArIDUgKiB5XSA9IHkgKyAoKDIgKiB4ICsgMyAqIHkpICUgNSkgKiA1O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gQ29tcHV0ZSByb3VuZCBjb25zdGFudHNcblx0ICAgICAgICB2YXIgTEZTUiA9IDB4MDE7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50TXN3ID0gMDtcblx0ICAgICAgICAgICAgdmFyIHJvdW5kQ29uc3RhbnRMc3cgPSAwO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoTEZTUiAmIDB4MDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYml0UG9zaXRpb24gPSAoMSA8PCBqKSAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJpdFBvc2l0aW9uIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRDb25zdGFudExzdyBePSAxIDw8IGJpdFBvc2l0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAoYml0UG9zaXRpb24gPj0gMzIpICovIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRDb25zdGFudE1zdyBePSAxIDw8IChiaXRQb3NpdGlvbiAtIDMyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBMRlNSXG5cdCAgICAgICAgICAgICAgICBpZiAoTEZTUiAmIDB4ODApIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQcmltaXRpdmUgcG9seW5vbWlhbCBvdmVyIEdGKDIpOiB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyAxXG5cdCAgICAgICAgICAgICAgICAgICAgTEZTUiA9IChMRlNSIDw8IDEpIF4gMHg3MTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgTEZTUiA8PD0gMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIFJPVU5EX0NPTlNUQU5UU1tpXSA9IFg2NFdvcmQuY3JlYXRlKHJvdW5kQ29uc3RhbnRNc3csIHJvdW5kQ29uc3RhbnRMc3cpO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdHMgZm9yIHRlbXBvcmFyeSB2YWx1ZXNcblx0ICAgIHZhciBUID0gW107XG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gWDY0V29yZC5jcmVhdGUoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0zIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBMyA9IENfYWxnby5TSEEzID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG91dHB1dExlbmd0aFxuXHQgICAgICAgICAqICAgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIG91dHB1dCBoYXNoLlxuXHQgICAgICAgICAqICAgT25seSB2YWx1ZXMgcGVybWl0dGVkIGFyZTogMjI0LCAyNTYsIDM4NCwgNTEyLlxuXHQgICAgICAgICAqICAgRGVmYXVsdDogNTEyXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBIYXNoZXIuY2ZnLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIG91dHB1dExlbmd0aDogNTEyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZSA9IFtdXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgc3RhdGVbaV0gPSBuZXcgWDY0V29yZC5pbml0KCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9ICgxNjAwIC0gMiAqIHRoaXMuY2ZnLm91dHB1dExlbmd0aCkgLyAzMjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja1NpemVMYW5lcyA9IHRoaXMuYmxvY2tTaXplIC8gMjtcblxuXHQgICAgICAgICAgICAvLyBBYnNvcmJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQmxvY2tTaXplTGFuZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgTTJpICA9IE1bb2Zmc2V0ICsgMiAqIGldO1xuXHQgICAgICAgICAgICAgICAgdmFyIE0yaTEgPSBNW29mZnNldCArIDIgKiBpICsgMV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgICAgICBNMmkgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpIDw8IDgpICB8IChNMmkgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpIDw8IDI0KSB8IChNMmkgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgIE0yaTEgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTTJpMSA8PCA4KSAgfCAoTTJpMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNMmkxIDw8IDI0KSB8IChNMmkxID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEFic29yYiBtZXNzYWdlIGludG8gc3RhdGVcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbaV07XG5cdCAgICAgICAgICAgICAgICBsYW5lLmhpZ2ggXj0gTTJpMTtcblx0ICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSBNMmk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBUaGV0YVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBNaXggY29sdW1uIGxhbmVzXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSAwLCB0THN3ID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDU7IHkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRNc3cgXj0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0THN3IF49IGxhbmUubG93O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHggPSBUW3hdO1xuXHQgICAgICAgICAgICAgICAgICAgIFR4LmhpZ2ggPSB0TXN3O1xuXHQgICAgICAgICAgICAgICAgICAgIFR4LmxvdyAgPSB0THN3O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA1OyB4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHg0ID0gVFsoeCArIDQpICUgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFR4MSA9IFRbKHggKyAxKSAlIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUeDFNc3cgPSBUeDEuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTHN3ID0gVHgxLmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE1peCBzdXJyb3VuZGluZyBjb2x1bW5zXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRNc3cgPSBUeDQuaGlnaCBeICgoVHgxTXN3IDw8IDEpIHwgKFR4MUxzdyA+Pj4gMzEpKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IFR4NC5sb3cgIF4gKChUeDFMc3cgPDwgMSkgfCAoVHgxTXN3ID4+PiAzMSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgNTsgeSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbeCArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5oaWdoIF49IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhbmUubG93ICBePSB0THN3O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmhvIFBpXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBsYW5lSW5kZXggPSAxOyBsYW5lSW5kZXggPCAyNTsgbGFuZUluZGV4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVNc3cgPSBsYW5lLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmhvT2Zmc2V0ID0gUkhPX09GRlNFVFNbbGFuZUluZGV4XTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyaG9PZmZzZXQgPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IChsYW5lTXN3IDw8IHJob09mZnNldCkgfCAobGFuZUxzdyA+Pj4gKDMyIC0gcmhvT2Zmc2V0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0THN3ID0gKGxhbmVMc3cgPDwgcmhvT2Zmc2V0KSB8IChsYW5lTXN3ID4+PiAoMzIgLSByaG9PZmZzZXQpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHJob09mZnNldCA+PSAzMikgKi8ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdE1zdyA9IChsYW5lTHN3IDw8IChyaG9PZmZzZXQgLSAzMikpIHwgKGxhbmVNc3cgPj4+ICg2NCAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdExzdyA9IChsYW5lTXN3IDw8IChyaG9PZmZzZXQgLSAzMikpIHwgKGxhbmVMc3cgPj4+ICg2NCAtIHJob09mZnNldCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zcG9zZSBsYW5lc1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBUUGlMYW5lID0gVFtQSV9JTkRFWEVTW2xhbmVJbmRleF1dO1xuXHQgICAgICAgICAgICAgICAgICAgIFRQaUxhbmUuaGlnaCA9IHRNc3c7XG5cdCAgICAgICAgICAgICAgICAgICAgVFBpTGFuZS5sb3cgID0gdExzdztcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmhvIHBpIGF0IHggPSB5ID0gMFxuXHQgICAgICAgICAgICAgICAgdmFyIFQwID0gVFswXTtcblx0ICAgICAgICAgICAgICAgIHZhciBzdGF0ZTAgPSBzdGF0ZVswXTtcblx0ICAgICAgICAgICAgICAgIFQwLmhpZ2ggPSBzdGF0ZTAuaGlnaDtcblx0ICAgICAgICAgICAgICAgIFQwLmxvdyAgPSBzdGF0ZTAubG93O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBDaGlcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyB5KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lSW5kZXggPSB4ICsgNSAqIHk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gc3RhdGVbbGFuZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFRMYW5lID0gVFtsYW5lSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgVHgxTGFuZSA9IFRbKCh4ICsgMSkgJSA1KSArIDUgKiB5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFR4MkxhbmUgPSBUWygoeCArIDIpICUgNSkgKyA1ICogeV07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IHJvd3Ncblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5oaWdoID0gVExhbmUuaGlnaCBeICh+VHgxTGFuZS5oaWdoICYgVHgyTGFuZS5oaWdoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGFuZS5sb3cgID0gVExhbmUubG93ICBeICh+VHgxTGFuZS5sb3cgICYgVHgyTGFuZS5sb3cpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW90YVxuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVswXTtcblx0ICAgICAgICAgICAgICAgIHZhciByb3VuZENvbnN0YW50ID0gUk9VTkRfQ09OU1RBTlRTW3JvdW5kXTtcblx0ICAgICAgICAgICAgICAgIGxhbmUuaGlnaCBePSByb3VuZENvbnN0YW50LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICBsYW5lLmxvdyAgXj0gcm91bmRDb25zdGFudC5sb3c7O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCaXRzID0gdGhpcy5ibG9ja1NpemUgKiAzMjtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDEgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKChNYXRoLmNlaWwoKG5CaXRzTGVmdCArIDEpIC8gYmxvY2tTaXplQml0cykgKiBibG9ja1NpemVCaXRzKSA+Pj4gNSkgLSAxXSB8PSAweDgwO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcblx0ICAgICAgICAgICAgdmFyIG91dHB1dExlbmd0aEJ5dGVzID0gdGhpcy5jZmcub3V0cHV0TGVuZ3RoIC8gODtcblx0ICAgICAgICAgICAgdmFyIG91dHB1dExlbmd0aExhbmVzID0gb3V0cHV0TGVuZ3RoQnl0ZXMgLyA4O1xuXG5cdCAgICAgICAgICAgIC8vIFNxdWVlemVcblx0ICAgICAgICAgICAgdmFyIGhhc2hXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dExlbmd0aExhbmVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBzdGF0ZVtpXTtcblx0ICAgICAgICAgICAgICAgIHZhciBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxhbmVMc3cgPSBsYW5lLmxvdztcblxuXHQgICAgICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgICAgIGxhbmVNc3cgPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZU1zdyA8PCA4KSAgfCAobGFuZU1zdyA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChsYW5lTXN3IDw8IDI0KSB8IChsYW5lTXN3ID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgICAgICBsYW5lTHN3ID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKGxhbmVMc3cgPDwgOCkgIHwgKGxhbmVMc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgobGFuZUxzdyA8PCAyNCkgfCAobGFuZUxzdyA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBTcXVlZXplIHN0YXRlIHRvIHJldHJpZXZlIGhhc2hcblx0ICAgICAgICAgICAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO1xuXHQgICAgICAgICAgICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZU1zdyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KGhhc2hXb3Jkcywgb3V0cHV0TGVuZ3RoQnl0ZXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICB2YXIgc3RhdGUgPSBjbG9uZS5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5zbGljZSgwKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZVtpXSA9IHN0YXRlW2ldLmNsb25lKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzKHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMyA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTMpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTMobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMyA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEzKTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMztcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi94NjQtY29yZVwiKSwgcmVxdWlyZShcIi4vc2hhNTEyXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCIsIFwiLi9zaGE1MTJcIl0sIGZhY3RvcnkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEdsb2JhbCAoYnJvd3Nlcilcblx0XHRmYWN0b3J5KHJvb3QuQ3J5cHRvSlMpO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ194NjQgPSBDLng2NDtcblx0ICAgIHZhciBYNjRXb3JkID0gQ194NjQuV29yZDtcblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIFNIQTUxMiA9IENfYWxnby5TSEE1MTI7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTM4NCBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTM4NCA9IENfYWxnby5TSEEzODQgPSBTSEE1MTIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheS5pbml0KFtcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCksIG5ldyBYNjRXb3JkLmluaXQoMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcpLCBuZXcgWDY0V29yZC5pbml0KDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzkpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDY3MzMyNjY3LCAweGZmYzAwYjMxKSwgbmV3IFg2NFdvcmQuaW5pdCgweDhlYjQ0YTg3LCAweDY4NTgxNTExKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyksIG5ldyBYNjRXb3JkLmluaXQoMHg0N2I1NDgxZCwgMHhiZWZhNGZhNClcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gU0hBNTEyLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgaGFzaC5zaWdCeXRlcyAtPSAxNjtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTM4NCgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIZWxwZXIoU0hBMzg0KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzODQobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjU0hBMzg0ID0gU0hBNTEyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTM4NCk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMzg0O1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSwgdW5kZWYpIHtcblx0aWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCIuL2NvcmVcIiksIHJlcXVpcmUoXCIuL3g2NC1jb3JlXCIpKTtcblx0fVxuXHRlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXCIuL2NvcmVcIiwgXCIuL3g2NC1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfeDY0ID0gQy54NjQ7XG5cdCAgICB2YXIgWDY0V29yZCA9IENfeDY0LldvcmQ7XG5cdCAgICB2YXIgWDY0V29yZEFycmF5ID0gQ194NjQuV29yZEFycmF5O1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgZnVuY3Rpb24gWDY0V29yZF9jcmVhdGUoKSB7XG5cdCAgICAgICAgcmV0dXJuIFg2NFdvcmQuY3JlYXRlLmFwcGx5KFg2NFdvcmQsIGFyZ3VtZW50cyk7XG5cdCAgICB9XG5cblx0ICAgIC8vIENvbnN0YW50c1xuXHQgICAgdmFyIEsgPSBbXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiksIFg2NFdvcmRfY3JlYXRlKDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYpLCBYNjRXb3JkX2NyZWF0ZSgweGU5YjVkYmE1LCAweDgxODlkYmJjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDM5NTZjMjViLCAweGYzNDhiNTM4KSwgWDY0V29yZF9jcmVhdGUoMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5MjNmODJhNCwgMHhhZjE5NGY5YiksIFg2NFdvcmRfY3JlYXRlKDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLCBYNjRXb3JkX2NyZWF0ZSgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDI0MzE4NWJlLCAweDRlZTRiMjhjKSwgWDY0V29yZF9jcmVhdGUoMHg1NTBjN2RjMywgMHhkNWZmYjRlMiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiksIFg2NFdvcmRfY3JlYXRlKDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUpLCBYNjRXb3JkX2NyZWF0ZSgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGU0OWI2OWMxLCAweDllZjE0YWQyKSwgWDY0V29yZF9jcmVhdGUoMHhlZmJlNDc4NiwgMHgzODRmMjVlMyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwZmMxOWRjNiwgMHg4YjhjZDViNSksIFg2NFdvcmRfY3JlYXRlKDB4MjQwY2ExY2MsIDB4NzdhYzljNjUpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLCBYNjRXb3JkX2NyZWF0ZSgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDVjYjBhOWRjLCAweGJkNDFmYmQ0KSwgWDY0V29yZF9jcmVhdGUoMHg3NmY5ODhkYSwgMHg4MzExNTNiNSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiksIFg2NFdvcmRfY3JlYXRlKDB4YTgzMWM2NmQsIDB4MmRiNDMyMTApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YjAwMzI3YzgsIDB4OThmYjIxM2YpLCBYNjRXb3JkX2NyZWF0ZSgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGM2ZTAwYmYzLCAweDNkYTg4ZmMyKSwgWDY0V29yZF9jcmVhdGUoMHhkNWE3OTE0NywgMHg5MzBhYTcyNSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiksIFg2NFdvcmRfY3JlYXRlKDB4MTQyOTI5NjcsIDB4MGEwZTZlNzApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDRkMmM2ZGZjLCAweDVhYzQyYWVkKSwgWDY0V29yZF9jcmVhdGUoMHg1MzM4MGQxMywgMHg5ZDk1YjNkZiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSksIFg2NFdvcmRfY3JlYXRlKDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYpLCBYNjRXb3JkX2NyZWF0ZSgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGEyYmZlOGExLCAweDRjZjEwMzY0KSwgWDY0V29yZF9jcmVhdGUoMHhhODFhNjY0YiwgMHhiYzQyMzAwMSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSksIFg2NFdvcmRfY3JlYXRlKDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzApLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLCBYNjRXb3JkX2NyZWF0ZSgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGY0MGUzNTg1LCAweDU3NzEyMDJhKSwgWDY0V29yZF9jcmVhdGUoMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgxOWE0YzExNiwgMHhiOGQyZDBjOCksIFg2NFdvcmRfY3JlYXRlKDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTkpLCBYNjRXb3JkX2NyZWF0ZSgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDM5MWMwY2IzLCAweGM1Yzk1YTYzKSwgWDY0V29yZF9jcmVhdGUoMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1YjljY2E0ZiwgMHg3NzYzZTM3MyksIFg2NFdvcmRfY3JlYXRlKDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLCBYNjRXb3JkX2NyZWF0ZSgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDg0Yzg3ODE0LCAweGExZjBhYjcyKSwgWDY0V29yZF9jcmVhdGUoMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCksIFg2NFdvcmRfY3JlYXRlKDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTkpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUpLCBYNjRXb3JkX2NyZWF0ZSgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweGNhMjczZWNlLCAweGVhMjY2MTljKSwgWDY0V29yZF9jcmVhdGUoMHhkMTg2YjhjNywgMHgyMWMwYzIwNyksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSksIFg2NFdvcmRfY3JlYXRlKDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLCBYNjRXb3JkX2NyZWF0ZSgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDExM2Y5ODA0LCAweGJlZjkwZGFlKSwgWDY0V29yZF9jcmVhdGUoMHgxYjcxMGIzNSwgMHgxMzFjNDcxYiksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCksIFg2NFdvcmRfY3JlYXRlKDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMpLFxuXHQgICAgICAgIFg2NFdvcmRfY3JlYXRlKDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMpLCBYNjRXb3JkX2NyZWF0ZSgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSxcblx0ICAgICAgICBYNjRXb3JkX2NyZWF0ZSgweDRjYzVkNGJlLCAweGNiM2U0MmI2KSwgWDY0V29yZF9jcmVhdGUoMHg1OTdmMjk5YywgMHhmYzY1N2UyYSksXG5cdCAgICAgICAgWDY0V29yZF9jcmVhdGUoMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYyksIFg2NFdvcmRfY3JlYXRlKDB4NmM0NDE5OGMsIDB4NGE0NzU4MTcpXG5cdCAgICBdO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3RzXG5cdCAgICB2YXIgVyA9IFtdO1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgV1tpXSA9IFg2NFdvcmRfY3JlYXRlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtNTEyIGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgU0hBNTEyID0gQ19hbGdvLlNIQTUxMiA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDZhMDllNjY3LCAweGYzYmNjOTA4KSwgbmV3IFg2NFdvcmQuaW5pdCgweGJiNjdhZTg1LCAweDg0Y2FhNzNiKSxcblx0ICAgICAgICAgICAgICAgIG5ldyBYNjRXb3JkLmluaXQoMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiksIG5ldyBYNjRXb3JkLmluaXQoMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSksXG5cdCAgICAgICAgICAgICAgICBuZXcgWDY0V29yZC5pbml0KDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEpLCBuZXcgWDY0V29yZC5pbml0KDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYpLFxuXHQgICAgICAgICAgICAgICAgbmV3IFg2NFdvcmQuaW5pdCgweDFmODNkOWFiLCAweGZiNDFiZDZiKSwgbmV3IFg2NFdvcmQuaW5pdCgweDViZTBjZDE5LCAweDEzN2UyMTc5KVxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgSCA9IHRoaXMuX2hhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIEgwID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIEgxID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIEgyID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIEgzID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIEg0ID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIEg1ID0gSFs1XTtcblx0ICAgICAgICAgICAgdmFyIEg2ID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIEg3ID0gSFs3XTtcblxuXHQgICAgICAgICAgICB2YXIgSDBoID0gSDAuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgwbCA9IEgwLmxvdztcblx0ICAgICAgICAgICAgdmFyIEgxaCA9IEgxLmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIMWwgPSBIMS5sb3c7XG5cdCAgICAgICAgICAgIHZhciBIMmggPSBIMi5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDJsID0gSDIubG93O1xuXHQgICAgICAgICAgICB2YXIgSDNoID0gSDMuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEgzbCA9IEgzLmxvdztcblx0ICAgICAgICAgICAgdmFyIEg0aCA9IEg0LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBINGwgPSBINC5sb3c7XG5cdCAgICAgICAgICAgIHZhciBINWggPSBINS5oaWdoO1xuXHQgICAgICAgICAgICB2YXIgSDVsID0gSDUubG93O1xuXHQgICAgICAgICAgICB2YXIgSDZoID0gSDYuaGlnaDtcblx0ICAgICAgICAgICAgdmFyIEg2bCA9IEg2Lmxvdztcblx0ICAgICAgICAgICAgdmFyIEg3aCA9IEg3LmhpZ2g7XG5cdCAgICAgICAgICAgIHZhciBIN2wgPSBINy5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcblx0ICAgICAgICAgICAgdmFyIGFoID0gSDBoO1xuXHQgICAgICAgICAgICB2YXIgYWwgPSBIMGw7XG5cdCAgICAgICAgICAgIHZhciBiaCA9IEgxaDtcblx0ICAgICAgICAgICAgdmFyIGJsID0gSDFsO1xuXHQgICAgICAgICAgICB2YXIgY2ggPSBIMmg7XG5cdCAgICAgICAgICAgIHZhciBjbCA9IEgybDtcblx0ICAgICAgICAgICAgdmFyIGRoID0gSDNoO1xuXHQgICAgICAgICAgICB2YXIgZGwgPSBIM2w7XG5cdCAgICAgICAgICAgIHZhciBlaCA9IEg0aDtcblx0ICAgICAgICAgICAgdmFyIGVsID0gSDRsO1xuXHQgICAgICAgICAgICB2YXIgZmggPSBINWg7XG5cdCAgICAgICAgICAgIHZhciBmbCA9IEg1bDtcblx0ICAgICAgICAgICAgdmFyIGdoID0gSDZoO1xuXHQgICAgICAgICAgICB2YXIgZ2wgPSBINmw7XG5cdCAgICAgICAgICAgIHZhciBoaCA9IEg3aDtcblx0ICAgICAgICAgICAgdmFyIGhsID0gSDdsO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgV2kgPSBXW2ldO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBFeHRlbmQgbWVzc2FnZVxuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaS5oaWdoID0gTVtvZmZzZXQgKyBpICogMl0gICAgIHwgMDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2lsID0gV2kubG93ICA9IE1bb2Zmc2V0ICsgaSAqIDIgKyAxXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdhbW1hMFxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ICA9IFdbaSAtIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweGggPSBnYW1tYTB4LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHhsID0gZ2FtbWEweC5sb3c7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMGggID0gKChnYW1tYTB4aCA+Pj4gMSkgfCAoZ2FtbWEweGwgPDwgMzEpKSBeICgoZ2FtbWEweGggPj4+IDgpIHwgKGdhbW1hMHhsIDw8IDI0KSkgXiAoZ2FtbWEweGggPj4+IDcpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTBsICA9ICgoZ2FtbWEweGwgPj4+IDEpIHwgKGdhbW1hMHhoIDw8IDMxKSkgXiAoKGdhbW1hMHhsID4+PiA4KSB8IChnYW1tYTB4aCA8PCAyNCkpIF4gKChnYW1tYTB4bCA+Pj4gNykgfCAoZ2FtbWEweGggPDwgMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIEdhbW1hMVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4ICA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTF4aCA9IGdhbW1hMXguaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeGwgPSBnYW1tYTF4Lmxvdztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExaCAgPSAoKGdhbW1hMXhoID4+PiAxOSkgfCAoZ2FtbWExeGwgPDwgMTMpKSBeICgoZ2FtbWExeGggPDwgMykgfCAoZ2FtbWExeGwgPj4+IDI5KSkgXiAoZ2FtbWExeGggPj4+IDYpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTFsICA9ICgoZ2FtbWExeGwgPj4+IDE5KSB8IChnYW1tYTF4aCA8PCAxMykpIF4gKChnYW1tYTF4bCA8PCAzKSB8IChnYW1tYTF4aCA+Pj4gMjkpKSBeICgoZ2FtbWExeGwgPj4+IDYpIHwgKGdhbW1hMXhoIDw8IDI2KSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2k3ICA9IFdbaSAtIDddO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTdoID0gV2k3LmhpZ2g7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpN2wgPSBXaTcubG93O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpMTYgID0gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaTE2aCA9IFdpMTYuaGlnaDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2kxNmwgPSBXaTE2LmxvdztcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWwgPSBnYW1tYTBsICsgV2k3bDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgV2loID0gZ2FtbWEwaCArIFdpN2ggKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWEwbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpbCArIGdhbW1hMWw7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpaCA9IFdpaCArIGdhbW1hMWggKyAoKFdpbCA+Pj4gMCkgPCAoZ2FtbWExbCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIFdpbCA9IFdpbCArIFdpMTZsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBXaWggPSBXaWggKyBXaTE2aCArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXaS5oaWdoID0gV2loO1xuXHQgICAgICAgICAgICAgICAgICAgIFdpLmxvdyAgPSBXaWw7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaGggID0gKGVoICYgZmgpIF4gKH5laCAmIGdoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGwgID0gKGVsICYgZmwpIF4gKH5lbCAmIGdsKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWpoID0gKGFoICYgYmgpIF4gKGFoICYgY2gpIF4gKGJoICYgY2gpO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hamwgPSAoYWwgJiBibCkgXiAoYWwgJiBjbCkgXiAoYmwgJiBjbCk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTBoID0gKChhaCA+Pj4gMjgpIHwgKGFsIDw8IDQpKSAgXiAoKGFoIDw8IDMwKSAgfCAoYWwgPj4+IDIpKSBeICgoYWggPDwgMjUpIHwgKGFsID4+PiA3KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwbCA9ICgoYWwgPj4+IDI4KSB8IChhaCA8PCA0KSkgIF4gKChhbCA8PCAzMCkgIHwgKGFoID4+PiAyKSkgXiAoKGFsIDw8IDI1KSB8IChhaCA+Pj4gNykpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ21hMWggPSAoKGVoID4+PiAxNCkgfCAoZWwgPDwgMTgpKSBeICgoZWggPj4+IDE4KSB8IChlbCA8PCAxNCkpIF4gKChlaCA8PCAyMykgfCAoZWwgPj4+IDkpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTFsID0gKChlbCA+Pj4gMTQpIHwgKGVoIDw8IDE4KSkgXiAoKGVsID4+PiAxOCkgfCAoZWggPDwgMTQpKSBeICgoZWwgPDwgMjMpIHwgKGVoID4+PiA5KSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV1cblx0ICAgICAgICAgICAgICAgIHZhciBLaSAgPSBLW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIEtpaCA9IEtpLmhpZ2g7XG5cdCAgICAgICAgICAgICAgICB2YXIgS2lsID0gS2kubG93O1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gaGwgKyBzaWdtYTFsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IGhoICsgc2lnbWExaCArICgodDFsID4+PiAwKSA8IChobCA+Pj4gMCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFsID0gdDFsICsgY2hsO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxaCA9IHQxaCArIGNoaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxbCA9IHQxbCArIEtpbDtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWggPSB0MWggKyBLaWggKyAoKHQxbCA+Pj4gMCkgPCAoS2lsID4+PiAwKSA/IDEgOiAwKTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MWwgPSB0MWwgKyBXaWw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDFoID0gdDFoICsgV2loICsgKCh0MWwgPj4+IDApIDwgKFdpbCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIHQyID0gc2lnbWEwICsgbWFqXG5cdCAgICAgICAgICAgICAgICB2YXIgdDJsID0gc2lnbWEwbCArIG1hamw7XG5cdCAgICAgICAgICAgICAgICB2YXIgdDJoID0gc2lnbWEwaCArIG1hamggKyAoKHQybCA+Pj4gMCkgPCAoc2lnbWEwbCA+Pj4gMCkgPyAxIDogMCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICAgICAgaGggPSBnaDtcblx0ICAgICAgICAgICAgICAgIGhsID0gZ2w7XG5cdCAgICAgICAgICAgICAgICBnaCA9IGZoO1xuXHQgICAgICAgICAgICAgICAgZ2wgPSBmbDtcblx0ICAgICAgICAgICAgICAgIGZoID0gZWg7XG5cdCAgICAgICAgICAgICAgICBmbCA9IGVsO1xuXHQgICAgICAgICAgICAgICAgZWwgPSAoZGwgKyB0MWwpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGVoID0gKGRoICsgdDFoICsgKChlbCA+Pj4gMCkgPCAoZGwgPj4+IDApID8gMSA6IDApKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkaCA9IGNoO1xuXHQgICAgICAgICAgICAgICAgZGwgPSBjbDtcblx0ICAgICAgICAgICAgICAgIGNoID0gYmg7XG5cdCAgICAgICAgICAgICAgICBjbCA9IGJsO1xuXHQgICAgICAgICAgICAgICAgYmggPSBhaDtcblx0ICAgICAgICAgICAgICAgIGJsID0gYWw7XG5cdCAgICAgICAgICAgICAgICBhbCA9ICh0MWwgKyB0MmwpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGFoID0gKHQxaCArIHQyaCArICgoYWwgPj4+IDApIDwgKHQxbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEgwbCA9IEgwLmxvdyAgPSAoSDBsICsgYWwpO1xuXHQgICAgICAgICAgICBIMC5oaWdoID0gKEgwaCArIGFoICsgKChIMGwgPj4+IDApIDwgKGFsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgxbCA9IEgxLmxvdyAgPSAoSDFsICsgYmwpO1xuXHQgICAgICAgICAgICBIMS5oaWdoID0gKEgxaCArIGJoICsgKChIMWwgPj4+IDApIDwgKGJsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgybCA9IEgyLmxvdyAgPSAoSDJsICsgY2wpO1xuXHQgICAgICAgICAgICBIMi5oaWdoID0gKEgyaCArIGNoICsgKChIMmwgPj4+IDApIDwgKGNsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEgzbCA9IEgzLmxvdyAgPSAoSDNsICsgZGwpO1xuXHQgICAgICAgICAgICBIMy5oaWdoID0gKEgzaCArIGRoICsgKChIM2wgPj4+IDApIDwgKGRsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg0bCA9IEg0LmxvdyAgPSAoSDRsICsgZWwpO1xuXHQgICAgICAgICAgICBINC5oaWdoID0gKEg0aCArIGVoICsgKChINGwgPj4+IDApIDwgKGVsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg1bCA9IEg1LmxvdyAgPSAoSDVsICsgZmwpO1xuXHQgICAgICAgICAgICBINS5oaWdoID0gKEg1aCArIGZoICsgKChINWwgPj4+IDApIDwgKGZsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg2bCA9IEg2LmxvdyAgPSAoSDZsICsgZ2wpO1xuXHQgICAgICAgICAgICBINi5oaWdoID0gKEg2aCArIGdoICsgKChINmwgPj4+IDApIDwgKGdsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgICAgIEg3bCA9IEg3LmxvdyAgPSAoSDdsICsgaGwpO1xuXHQgICAgICAgICAgICBINy5oaWdoID0gKEg3aCArIGhoICsgKChIN2wgPj4+IDApIDwgKGhsID4+PiAwKSA/IDEgOiAwKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMwXSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMxXSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBoYXNoIHRvIDMyLWJpdCB3b3JkIGFycmF5IGJlZm9yZSByZXR1cm5pbmdcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoLnRvWDMyKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTAyNC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEE1MTIoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTUxMiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTUxMik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBNTEyKG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTUxMiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEE1MTIpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTUxMjtcblxufSkpOyIsIjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnksIHVuZGVmKSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiLi9jb3JlXCIpLCByZXF1aXJlKFwiLi9lbmMtYmFzZTY0XCIpLCByZXF1aXJlKFwiLi9tZDVcIiksIHJlcXVpcmUoXCIuL2V2cGtkZlwiKSwgcmVxdWlyZShcIi4vY2lwaGVyLWNvcmVcIikpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcIi4vY29yZVwiLCBcIi4vZW5jLWJhc2U2NFwiLCBcIi4vbWQ1XCIsIFwiLi9ldnBrZGZcIiwgXCIuL2NpcGhlci1jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBQZXJtdXRlZCBDaG9pY2UgMSBjb25zdGFudHNcblx0ICAgIHZhciBQQzEgPSBbXG5cdCAgICAgICAgNTcsIDQ5LCA0MSwgMzMsIDI1LCAxNywgOSwgIDEsXG5cdCAgICAgICAgNTgsIDUwLCA0MiwgMzQsIDI2LCAxOCwgMTAsIDIsXG5cdCAgICAgICAgNTksIDUxLCA0MywgMzUsIDI3LCAxOSwgMTEsIDMsXG5cdCAgICAgICAgNjAsIDUyLCA0NCwgMzYsIDYzLCA1NSwgNDcsIDM5LFxuXHQgICAgICAgIDMxLCAyMywgMTUsIDcsICA2MiwgNTQsIDQ2LCAzOCxcblx0ICAgICAgICAzMCwgMjIsIDE0LCA2LCAgNjEsIDUzLCA0NSwgMzcsXG5cdCAgICAgICAgMjksIDIxLCAxMywgNSwgIDI4LCAyMCwgMTIsIDRcblx0ICAgIF07XG5cblx0ICAgIC8vIFBlcm11dGVkIENob2ljZSAyIGNvbnN0YW50c1xuXHQgICAgdmFyIFBDMiA9IFtcblx0ICAgICAgICAxNCwgMTcsIDExLCAyNCwgMSwgIDUsXG5cdCAgICAgICAgMywgIDI4LCAxNSwgNiwgIDIxLCAxMCxcblx0ICAgICAgICAyMywgMTksIDEyLCA0LCAgMjYsIDgsXG5cdCAgICAgICAgMTYsIDcsICAyNywgMjAsIDEzLCAyLFxuXHQgICAgICAgIDQxLCA1MiwgMzEsIDM3LCA0NywgNTUsXG5cdCAgICAgICAgMzAsIDQwLCA1MSwgNDUsIDMzLCA0OCxcblx0ICAgICAgICA0NCwgNDksIDM5LCA1NiwgMzQsIDUzLFxuXHQgICAgICAgIDQ2LCA0MiwgNTAsIDM2LCAyOSwgMzJcblx0ICAgIF07XG5cblx0ICAgIC8vIEN1bXVsYXRpdmUgYml0IHNoaWZ0IGNvbnN0YW50c1xuXHQgICAgdmFyIEJJVF9TSElGVFMgPSBbMSwgIDIsICA0LCAgNiwgIDgsICAxMCwgMTIsIDE0LCAxNSwgMTcsIDE5LCAyMSwgMjMsIDI1LCAyNywgMjhdO1xuXG5cdCAgICAvLyBTQk9YZXMgYW5kIHJvdW5kIHBlcm11dGF0aW9uIGNvbnN0YW50c1xuXHQgICAgdmFyIFNCT1hfUCA9IFtcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDAwMDA6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwMDAwMDogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4MzAwMDAwMDA6IDB4Mixcblx0ICAgICAgICAgICAgMHg0MDAwMDAwMDogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDA6IDB4ODA4MjAyLFxuXHQgICAgICAgICAgICAweDYwMDAwMDAwOiAweDgwMDIwMixcblx0ICAgICAgICAgICAgMHg3MDAwMDAwMDogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDA6IDB4MjAyLFxuXHQgICAgICAgICAgICAweDkwMDAwMDAwOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhhMDAwMDAwMDogMHg4MjAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDAwOiAweDgwODAwMCxcblx0ICAgICAgICAgICAgMHhjMDAwMDAwMDogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGQwMDAwMDAwOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhlMDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGYwMDAwMDAwOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDE4MDAwMDAwOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHgyODAwMDAwMDogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDM4MDAwMDAwOiAweDgwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDA6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDAwOiAweDIwMCxcblx0ICAgICAgICAgICAgMHg2ODAwMDAwMDogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4NzgwMDAwMDA6IDB4Mixcblx0ICAgICAgICAgICAgMHg4ODAwMDAwMDogMHg4MDAyMDAsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDA6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDAwMDogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwMDA6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweGM4MDAwMDAwOiAweDgwMDAwMixcblx0ICAgICAgICAgICAgMHhkODAwMDAwMDogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGU4MDAwMDAwOiAweDIwMixcblx0ICAgICAgICAgICAgMHhmODAwMDAwMDogMHg4MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTogMHg4MDAwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDAxOiAweDIsXG5cdCAgICAgICAgICAgIDB4MjAwMDAwMDE6IDB4ODA4MjAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDAxOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwMDAwMTogMHg4MDgwMDIsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwMDE6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHg2MDAwMDAwMTogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDE6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAxOiAweDgwODIwMixcblx0ICAgICAgICAgICAgMHg5MDAwMDAwMTogMHg4MDgwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDE6IDB4ODAwMDAyLFxuXHQgICAgICAgICAgICAweGIwMDAwMDAxOiAweDgyMDIsXG5cdCAgICAgICAgICAgIDB4YzAwMDAwMDE6IDB4MjAyLFxuXHQgICAgICAgICAgICAweGQwMDAwMDAxOiAweDgwMDIwMCxcblx0ICAgICAgICAgICAgMHhlMDAwMDAwMTogMHg4MDAyLFxuXHQgICAgICAgICAgICAweGYwMDAwMDAxOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTogMHg4MDgyMDIsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDE6IDB4ODA4MDAwLFxuXHQgICAgICAgICAgICAweDI4MDAwMDAxOiAweDgwMDAwMCxcblx0ICAgICAgICAgICAgMHgzODAwMDAwMTogMHgyMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwMDE6IDB4ODAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwMDAwMTogMHg4MDAwMDIsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDE6IDB4Mixcblx0ICAgICAgICAgICAgMHg3ODAwMDAwMTogMHg4MjAyLFxuXHQgICAgICAgICAgICAweDg4MDAwMDAxOiAweDgwMDIsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDE6IDB4ODAwMjAyLFxuXHQgICAgICAgICAgICAweGE4MDAwMDAxOiAweDIwMixcblx0ICAgICAgICAgICAgMHhiODAwMDAwMTogMHg4MDgyMDAsXG5cdCAgICAgICAgICAgIDB4YzgwMDAwMDE6IDB4ODAwMjAwLFxuXHQgICAgICAgICAgICAweGQ4MDAwMDAxOiAweDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDAwMDE6IDB4ODIwMCxcblx0ICAgICAgICAgICAgMHhmODAwMDAwMTogMHg4MDgwMDJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgMHgwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHgyMDAwMDAwOiAweDgwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDA6IDB4NDAwODAwMTAsXG5cdCAgICAgICAgICAgIDB4NDAwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHg1MDAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDYwMDAwMDA6IDB4NDAwMDQwMDAsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwMDogMHgxMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwOiAweDg0MDAwLFxuXHQgICAgICAgICAgICAweDkwMDAwMDA6IDB4NDAwMDQwMTAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHhiMDAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweGMwMDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGUwMDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHhmMDAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDI4MDAwMDA6IDB4MTAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwMDogMHg0MDAwNDAxMCxcblx0ICAgICAgICAgICAgMHg0ODAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDU4MDAwMDA6IDB4NDAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NjgwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHg3ODAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDg4MDAwMDA6IDB4ODAwMTAsXG5cdCAgICAgICAgICAgIDB4OTgwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGE4MDAwMDA6IDB4NDAwMCxcblx0ICAgICAgICAgICAgMHhiODAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweGM4MDAwMDA6IDB4NDAwMDAwMTAsXG5cdCAgICAgICAgICAgIDB4ZDgwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHhlODAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweGY4MDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDExMDAwMDAwOiAweDQwMDgwMDEwLFxuXHQgICAgICAgICAgICAweDEyMDAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDE0MDAwMDAwOiAweDQwMDgwMDAwLFxuXHQgICAgICAgICAgICAweDE1MDAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDE2MDAwMDAwOiAweDg0MDEwLFxuXHQgICAgICAgICAgICAweDE3MDAwMDAwOiAweDQwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxOTAwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDAwMDogMHg4MDAxMCxcblx0ICAgICAgICAgICAgMHgxYjAwMDAwMDogMHg0MDAwMDAxMCxcblx0ICAgICAgICAgICAgMHgxYzAwMDAwMDogMHg4NDAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDAwMDogMHg0MDAwNDAwMCxcblx0ICAgICAgICAgICAgMHgxZTAwMDAwMDogMHg0MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjAwMDAwMDogMHg0MDA4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMDgwMDAwMDogMHg4NDAxMCxcblx0ICAgICAgICAgICAgMHgxMTgwMDAwMDogMHg4MDAwMCxcblx0ICAgICAgICAgICAgMHgxMjgwMDAwMDogMHg0MDA4MDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDAwMDogMHg0MDAwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDAwOiAweDQwMDA0MDAwLFxuXHQgICAgICAgICAgICAweDE1ODAwMDAwOiAweDQwMDg0MDEwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDAwOiAweDEwLFxuXHQgICAgICAgICAgICAweDE3ODAwMDAwOiAweDQwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODAwMDAwOiAweDQwMDg0MDAwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDAwOiAweDQwMDAwMDEwLFxuXHQgICAgICAgICAgICAweDFhODAwMDAwOiAweDQwMDA0MDEwLFxuXHQgICAgICAgICAgICAweDFiODAwMDAwOiAweDgwMDEwLFxuXHQgICAgICAgICAgICAweDFjODAwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwMDA6IDB4NDAxMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDAwMDogMHg0MDA4MDAxMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDAwMDogMHg4NDAwMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDEwMDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweDIwMDAwMDogMHg0MDAwMTAwLFxuXHQgICAgICAgICAgICAweDMwMDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHg0MDAwMDA6IDB4MTAwMDQsXG5cdCAgICAgICAgICAgIDB4NTAwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4NjAwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4NzAwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4OTAwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweGIwMDAwMDogMHg0MDEwMDA0LFxuXHQgICAgICAgICAgICAweGMwMDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweGQwMDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHhlMDAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHhmMDAwMDA6IDB4MTAwLFxuXHQgICAgICAgICAgICAweDgwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MjgwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDAwOiAweDQwMDAxMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4NTgwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDY4MDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHg3ODAwMDA6IDB4MTA0LFxuXHQgICAgICAgICAgICAweDg4MDAwMDogMHg0LFxuXHQgICAgICAgICAgICAweDk4MDAwMDogMHgxMDAsXG5cdCAgICAgICAgICAgIDB4YTgwMDAwOiAweDQwMTAwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweGM4MDAwMDogMHgxMDEwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDA6IDB4NDAwMDEwNCxcblx0ICAgICAgICAgICAgMHhlODAwMDA6IDB4NDAxMDEwNCxcblx0ICAgICAgICAgICAgMHhmODAwMDA6IDB4NDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMDAwMDAwOiAweDQwMTAxMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwMDogMHgxMDAwNCxcblx0ICAgICAgICAgICAgMHgxMjAwMDAwOiAweDEwMDAwLFxuXHQgICAgICAgICAgICAweDEzMDAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgxNDAwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHgxNTAwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4MTYwMDAwMDogMHg0MDAwMDA0LFxuXHQgICAgICAgICAgICAweDE3MDAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxODAwMDAwOiAweDQwMDAxMDQsXG5cdCAgICAgICAgICAgIDB4MTkwMDAwMDogMHg0MDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwMDA6IDB4NCxcblx0ICAgICAgICAgICAgMHgxYjAwMDAwOiAweDEwMTAwLFxuXHQgICAgICAgICAgICAweDFjMDAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHgxZDAwMDAwOiAweDEwNCxcblx0ICAgICAgICAgICAgMHgxZTAwMDAwOiAweDEwMTA0LFxuXHQgICAgICAgICAgICAweDFmMDAwMDA6IDB4NDAxMDAwNCxcblx0ICAgICAgICAgICAgMHgxMDgwMDAwOiAweDQwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTE4MDAwMDogMHgxMDQsXG5cdCAgICAgICAgICAgIDB4MTI4MDAwMDogMHg0MDEwMTAwLFxuXHQgICAgICAgICAgICAweDEzODAwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxNDgwMDAwOiAweDEwMDA0LFxuXHQgICAgICAgICAgICAweDE1ODAwMDA6IDB4NDAwMDEwMCxcblx0ICAgICAgICAgICAgMHgxNjgwMDAwOiAweDEwMCxcblx0ICAgICAgICAgICAgMHgxNzgwMDAwOiAweDQwMTAwMDQsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwMDogMHgxMDAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwMDAwOiAweDQwMTAxMDQsXG5cdCAgICAgICAgICAgIDB4MWE4MDAwMDogMHgxMDEwNCxcblx0ICAgICAgICAgICAgMHgxYjgwMDAwOiAweDQwMDAwMDQsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwMDogMHg0MDAwMTA0LFxuXHQgICAgICAgICAgICAweDFkODAwMDA6IDB4NDAxMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDAwOiAweDQsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwMDogMHgxMDEwMFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODA0MDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MjAwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweDMwMDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDQwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NTAwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDYwMDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDcwMDAwOiAweDQwMDA0MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg5MDAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4YjAwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4YzAwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHhlMDAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweGYwMDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDgwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MjgwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MzgwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDU4MDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDY4MDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODgwMDA6IDB4MTAwMCxcblx0ICAgICAgICAgICAgMHg5ODAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHhhODAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4YjgwMDA6IDB4MTA0MCxcblx0ICAgICAgICAgICAgMHhjODAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHhkODAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDA6IDB4NDAxMDQwLFxuXHQgICAgICAgICAgICAweGY4MDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDEwMDAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDAwOiAweDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxMjAwMDA6IDB4ODAwMDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MTQwMDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTUwMDAwOiAweDgwNDAwMDQwLFxuXHQgICAgICAgICAgICAweDE2MDAwMDogMHg4MDQwMTAwMCxcblx0ICAgICAgICAgICAgMHgxNzAwMDA6IDB4ODAwMDEwNDAsXG5cdCAgICAgICAgICAgIDB4MTgwMDAwOiAweDgwNDAxMDQwLFxuXHQgICAgICAgICAgICAweDE5MDAwMDogMHg4MDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTAwMDA6IDB4ODA0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWIwMDAwOiAweDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxYzAwMDA6IDB4ODAwMDEwMDAsXG5cdCAgICAgICAgICAgIDB4MWQwMDAwOiAweDQwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZTAwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MWYwMDAwOiAweDEwMDAsXG5cdCAgICAgICAgICAgIDB4MTA4MDAwOiAweDgwNDAwMDAwLFxuXHQgICAgICAgICAgICAweDExODAwMDogMHg4MDQwMTA0MCxcblx0ICAgICAgICAgICAgMHgxMjgwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxMzgwMDA6IDB4NDAxMDAwLFxuXHQgICAgICAgICAgICAweDE0ODAwMDogMHg0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MTU4MDAwOiAweDgwMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE2ODAwMDogMHg4MDAwMTA0MCxcblx0ICAgICAgICAgICAgMHgxNzgwMDA6IDB4NDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDAwOiAweDgwMDAwMDQwLFxuXHQgICAgICAgICAgICAweDE5ODAwMDogMHgxMDAwLFxuXHQgICAgICAgICAgICAweDFhODAwMDogMHg4MDAwMTAwMCxcblx0ICAgICAgICAgICAgMHgxYjgwMDA6IDB4ODA0MDAwNDAsXG5cdCAgICAgICAgICAgIDB4MWM4MDAwOiAweDEwNDAsXG5cdCAgICAgICAgICAgIDB4MWQ4MDAwOiAweDgwNDAxMDAwLFxuXHQgICAgICAgICAgICAweDFlODAwMDogMHg0MDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWY4MDAwOiAweDQwMTA0MFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTAwMDogMHgxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDIwMDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MzAwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg0MDAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDUwMDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHg2MDAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDcwMDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4ODAwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDkwMDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4YTAwMDogMHgyMDAwMDA4MCxcblx0ICAgICAgICAgICAgMHhiMDAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGMwMDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDAwMDogMHgwLFxuXHQgICAgICAgICAgICAweGUwMDA6IDB4MTA0MDA4MCxcblx0ICAgICAgICAgICAgMHhmMDAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE4MDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MjgwMDogMHg4MCxcblx0ICAgICAgICAgICAgMHgzODAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHg1ODAwOiAweDIwMDQwMDgwLFxuXHQgICAgICAgICAgICAweDY4MDA6IDB4MjEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4NzgwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4ODAwOiAweDIwMDQwMDAwLFxuXHQgICAgICAgICAgICAweDk4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHhhODAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweGI4MDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHhjODAwOiAweDIwMDAwMDgwLFxuXHQgICAgICAgICAgICAweGQ4MDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweGY4MDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MTAwMDA6IDB4NDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTEwMDA6IDB4ODAsXG5cdCAgICAgICAgICAgIDB4MTIwMDA6IDB4MjAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTMwMDA6IDB4MjEwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MTQwMDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxNTAwMDogMHgyMTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxNjAwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNzAwMDogMHgxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE4MDAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE5MDAwOiAweDIxMDAwMDAwLFxuXHQgICAgICAgICAgICAweDFhMDAwOiAweDEwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWIwMDA6IDB4MjAwNDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDA6IDB4NDAwODAsXG5cdCAgICAgICAgICAgIDB4MWQwMDA6IDB4MjAwMDAwODAsXG5cdCAgICAgICAgICAgIDB4MWUwMDA6IDB4MCxcblx0ICAgICAgICAgICAgMHgxZjAwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDEwODAwOiAweDIxMDAwMDgwLFxuXHQgICAgICAgICAgICAweDExODAwOiAweDEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDA6IDB4MTA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxMzgwMDogMHgyMDA0MDA4MCxcblx0ICAgICAgICAgICAgMHgxNDgwMDogMHgyMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxNTgwMDogMHgxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDE2ODAwOiAweDgwLFxuXHQgICAgICAgICAgICAweDE3ODAwOiAweDIxMDQwMDAwLFxuXHQgICAgICAgICAgICAweDE4ODAwOiAweDQwMDgwLFxuXHQgICAgICAgICAgICAweDE5ODAwOiAweDIxMDQwMDgwLFxuXHQgICAgICAgICAgICAweDFhODAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWI4MDA6IDB4MjEwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWM4MDA6IDB4MTAwMDA4MCxcblx0ICAgICAgICAgICAgMHgxZDgwMDogMHg0MDAwMCxcblx0ICAgICAgICAgICAgMHgxZTgwMDogMHgyMDA0MDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwMDogMHgyMDAwMDA4MFxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4MTAwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4MjAwOiAweDEwMjAwMDAwLFxuXHQgICAgICAgICAgICAweDMwMDogMHgxMDIwMjAwOCxcblx0ICAgICAgICAgICAgMHg0MDA6IDB4MTAwMDIwMDAsXG5cdCAgICAgICAgICAgIDB4NTAwOiAweDIwMDAwMCxcblx0ICAgICAgICAgICAgMHg2MDA6IDB4MjAwMDA4LFxuXHQgICAgICAgICAgICAweDcwMDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDA6IDB4MCxcblx0ICAgICAgICAgICAgMHg5MDA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4YTAwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhiMDA6IDB4OCxcblx0ICAgICAgICAgICAgMHhjMDA6IDB4MTAyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4ZDAwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHhlMDA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHhmMDA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ODA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTgwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDI4MDogMHg4LFxuXHQgICAgICAgICAgICAweDM4MDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NDgwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHg1ODA6IDB4MTAwMDAwMDgsXG5cdCAgICAgICAgICAgIDB4NjgwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDc4MDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDg4MDogMHgyMDAwMDgsXG5cdCAgICAgICAgICAgIDB4OTgwOiAweDIwMDAsXG5cdCAgICAgICAgICAgIDB4YTgwOiAweDEwMDAyMDA4LFxuXHQgICAgICAgICAgICAweGI4MDogMHgxMDIwMDAwOCxcblx0ICAgICAgICAgICAgMHhjODA6IDB4MCxcblx0ICAgICAgICAgICAgMHhkODA6IDB4MTAyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4ZTgwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHhmODA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTAwMDogMHgxMDAwMjAwMCxcblx0ICAgICAgICAgICAgMHgxMTAwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweDEyMDA6IDB4MTAyMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MTMwMDogMHgyMDA4LFxuXHQgICAgICAgICAgICAweDE0MDA6IDB4MjAwMDAwLFxuXHQgICAgICAgICAgICAweDE1MDA6IDB4MTAwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTYwMDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxNzAwOiAweDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxODAwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxOTAwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWEwMDogMHg4LFxuXHQgICAgICAgICAgICAweDFiMDA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWMwMDogMHgyMDAwLFxuXHQgICAgICAgICAgICAweDFkMDA6IDB4MTAwMDIwMDgsXG5cdCAgICAgICAgICAgIDB4MWUwMDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxZjAwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxMDgwOiAweDgsXG5cdCAgICAgICAgICAgIDB4MTE4MDogMHgyMDIwMDAsXG5cdCAgICAgICAgICAgIDB4MTI4MDogMHgyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTM4MDogMHgxMDAwMDAwOCxcblx0ICAgICAgICAgICAgMHgxNDgwOiAweDEwMDAyMDAwLFxuXHQgICAgICAgICAgICAweDE1ODA6IDB4MjAwOCxcblx0ICAgICAgICAgICAgMHgxNjgwOiAweDEwMjAyMDA4LFxuXHQgICAgICAgICAgICAweDE3ODA6IDB4MTAyMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTg4MDogMHgxMDIwMjAwMCxcblx0ICAgICAgICAgICAgMHgxOTgwOiAweDEwMjAwMDA4LFxuXHQgICAgICAgICAgICAweDFhODA6IDB4MjAwMCxcblx0ICAgICAgICAgICAgMHgxYjgwOiAweDIwMjAwOCxcblx0ICAgICAgICAgICAgMHgxYzgwOiAweDIwMDAwOCxcblx0ICAgICAgICAgICAgMHgxZDgwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWU4MDogMHgxMDAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxZjgwOiAweDEwMDAyMDA4XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB7XG5cdCAgICAgICAgICAgIDB4MDogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTA6IDB4MjAwMDQwMSxcblx0ICAgICAgICAgICAgMHgyMDogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MzA6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDQwOiAweDIxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4NTA6IDB4MCxcblx0ICAgICAgICAgICAgMHg2MDogMHgxLFxuXHQgICAgICAgICAgICAweDcwOiAweDIxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4ODA6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHg5MDogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4YTA6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHhiMDogMHgyMTAwNDAwLFxuXHQgICAgICAgICAgICAweGMwOiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ZDA6IDB4NDAxLFxuXHQgICAgICAgICAgICAweGUwOiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHhmMDogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDg6IDB4MjEwMDAwMSxcblx0ICAgICAgICAgICAgMHgxODogMHgwLFxuXHQgICAgICAgICAgICAweDI4OiAweDIwMDA0MDEsXG5cdCAgICAgICAgICAgIDB4Mzg6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHg0ODogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4NTg6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHg2ODogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDc4OiAweDQwMSxcblx0ICAgICAgICAgICAgMHg4ODogMHgxMDA0MDEsXG5cdCAgICAgICAgICAgIDB4OTg6IDB4MjAwMDQwMCxcblx0ICAgICAgICAgICAgMHhhODogMHgyMTAwMDAwLFxuXHQgICAgICAgICAgICAweGI4OiAweDEwMDAwMSxcblx0ICAgICAgICAgICAgMHhjODogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4ZDg6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHhlODogMHgxLFxuXHQgICAgICAgICAgICAweGY4OiAweDEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxMDA6IDB4MjAwMDAwMCxcblx0ICAgICAgICAgICAgMHgxMTA6IDB4MTAwMDAwLFxuXHQgICAgICAgICAgICAweDEyMDogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDEzMDogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDE0MDogMHgxMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MTUwOiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTYwOiAweDIxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MTcwOiAweDEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxODA6IDB4NDAxLFxuXHQgICAgICAgICAgICAweDE5MDogMHgyMTAwNDAxLFxuXHQgICAgICAgICAgICAweDFhMDogMHgxMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MWIwOiAweDEsXG5cdCAgICAgICAgICAgIDB4MWMwOiAweDAsXG5cdCAgICAgICAgICAgIDB4MWQwOiAweDIxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MWUwOiAweDIwMDAwMDEsXG5cdCAgICAgICAgICAgIDB4MWYwOiAweDQwMCxcblx0ICAgICAgICAgICAgMHgxMDg6IDB4MTAwNDAwLFxuXHQgICAgICAgICAgICAweDExODogMHgyMDAwNDAxLFxuXHQgICAgICAgICAgICAweDEyODogMHgyMTAwMDAxLFxuXHQgICAgICAgICAgICAweDEzODogMHgxLFxuXHQgICAgICAgICAgICAweDE0ODogMHgyMDAwMDAwLFxuXHQgICAgICAgICAgICAweDE1ODogMHgxMDAwMDAsXG5cdCAgICAgICAgICAgIDB4MTY4OiAweDQwMSxcblx0ICAgICAgICAgICAgMHgxNzg6IDB4MjEwMDQwMCxcblx0ICAgICAgICAgICAgMHgxODg6IDB4MjAwMDAwMSxcblx0ICAgICAgICAgICAgMHgxOTg6IDB4MjEwMDAwMCxcblx0ICAgICAgICAgICAgMHgxYTg6IDB4MCxcblx0ICAgICAgICAgICAgMHgxYjg6IDB4MjEwMDQwMSxcblx0ICAgICAgICAgICAgMHgxYzg6IDB4MTAwNDAxLFxuXHQgICAgICAgICAgICAweDFkODogMHg0MDAsXG5cdCAgICAgICAgICAgIDB4MWU4OiAweDIwMDA0MDAsXG5cdCAgICAgICAgICAgIDB4MWY4OiAweDEwMDAwMVxuXHQgICAgICAgIH0sXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgICAweDA6IDB4ODAwMDgyMCxcblx0ICAgICAgICAgICAgMHgxOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDI6IDB4ODAwMDAwMCxcblx0ICAgICAgICAgICAgMHgzOiAweDIwLFxuXHQgICAgICAgICAgICAweDQ6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4NTogMHg4MDIwODIwLFxuXHQgICAgICAgICAgICAweDY6IDB4ODAyMDgwMCxcblx0ICAgICAgICAgICAgMHg3OiAweDgwMCxcblx0ICAgICAgICAgICAgMHg4OiAweDgwMjAwMDAsXG5cdCAgICAgICAgICAgIDB4OTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweGE6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4YjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweGM6IDB4ODIwLFxuXHQgICAgICAgICAgICAweGQ6IDB4MCxcblx0ICAgICAgICAgICAgMHhlOiAweDgwMDAwMjAsXG5cdCAgICAgICAgICAgIDB4ZjogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMDogMHg4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDE6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwMjogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDAzOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMDQ6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNTogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNjogMHgyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwNzogMHgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwODogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDA5OiAweDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYTogMHgyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwYjogMHg4MDIwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBjOiAweDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMGQ6IDB4ODAyMDAyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAwZTogMHg4MDAwODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDBmOiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDEwOiAweDIwODIwLFxuXHQgICAgICAgICAgICAweDExOiAweDgwMjA4MDAsXG5cdCAgICAgICAgICAgIDB4MTI6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4MTM6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDE0OiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4MTU6IDB4ODAwMDAyMCxcblx0ICAgICAgICAgICAgMHgxNjogMHg4MDIwMDIwLFxuXHQgICAgICAgICAgICAweDE3OiAweDIwMDAwLFxuXHQgICAgICAgICAgICAweDE4OiAweDAsXG5cdCAgICAgICAgICAgIDB4MTk6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4MWE6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHgxYjogMHg4MDAwODIwLFxuXHQgICAgICAgICAgICAweDFjOiAweDgwMjA4MjAsXG5cdCAgICAgICAgICAgIDB4MWQ6IDB4MjA4MDAsXG5cdCAgICAgICAgICAgIDB4MWU6IDB4ODIwLFxuXHQgICAgICAgICAgICAweDFmOiAweDgwMDAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTA6IDB4MjAwMDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTE6IDB4ODAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDEyOiAweDgwMjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTM6IDB4MjA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTQ6IDB4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTU6IDB4ODAyMDAwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxNjogMHg4MDAwMDAwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDE3OiAweDgwMDA4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMTg6IDB4ODAyMDgyMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxOTogMHg4MDAwMDIwLFxuXHQgICAgICAgICAgICAweDgwMDAwMDFhOiAweDgwMDA4MDAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWI6IDB4MCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxYzogMHgyMDgwMCxcblx0ICAgICAgICAgICAgMHg4MDAwMDAxZDogMHg4MjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWU6IDB4MjAwMjAsXG5cdCAgICAgICAgICAgIDB4ODAwMDAwMWY6IDB4ODAyMDgwMFxuXHQgICAgICAgIH1cblx0ICAgIF07XG5cblx0ICAgIC8vIE1hc2tzIHRoYXQgc2VsZWN0IHRoZSBTQk9YIGlucHV0XG5cdCAgICB2YXIgU0JPWF9NQVNLID0gW1xuXHQgICAgICAgIDB4ZjgwMDAwMDEsIDB4MWY4MDAwMDAsIDB4MDFmODAwMDAsIDB4MDAxZjgwMDAsXG5cdCAgICAgICAgMHgwMDAxZjgwMCwgMHgwMDAwMWY4MCwgMHgwMDAwMDFmOCwgMHg4MDAwMDAxZlxuXHQgICAgXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBERVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIERFUyA9IENfYWxnby5ERVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5O1xuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2VsZWN0IDU2IGJpdHMgYWNjb3JkaW5nIHRvIFBDMVxuXHQgICAgICAgICAgICB2YXIga2V5Qml0cyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBrZXlCaXRQb3MgPSBQQzFbaV0gLSAxO1xuXHQgICAgICAgICAgICAgICAga2V5Qml0c1tpXSA9IChrZXlXb3Jkc1trZXlCaXRQb3MgPj4+IDVdID4+PiAoMzEgLSBrZXlCaXRQb3MgJSAzMikpICYgMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFzc2VtYmxlIDE2IHN1YmtleXNcblx0ICAgICAgICAgICAgdmFyIHN1YktleXMgPSB0aGlzLl9zdWJLZXlzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5TdWJLZXkgPSAwOyBuU3ViS2V5IDwgMTY7IG5TdWJLZXkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN1YmtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IHN1YktleXNbblN1YktleV0gPSBbXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRTaGlmdCA9IEJJVF9TSElGVFNbblN1YktleV07XG5cblx0ICAgICAgICAgICAgICAgIC8vIFNlbGVjdCA0OCBiaXRzIGFjY29yZGluZyB0byBQQzJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBmcm9tIHRoZSBsZWZ0IDI4IGtleSBiaXRzXG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5WyhpIC8gNikgfCAwXSB8PSBrZXlCaXRzWygoUEMyW2ldIC0gMSkgKyBiaXRTaGlmdCkgJSAyOF0gPDwgKDMxIC0gaSAlIDYpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZyb20gdGhlIHJpZ2h0IDI4IGtleSBiaXRzXG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5WzQgKyAoKGkgLyA2KSB8IDApXSB8PSBrZXlCaXRzWzI4ICsgKCgoUEMyW2kgKyAyNF0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4KV0gPDwgKDMxIC0gaSAlIDYpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBTaW5jZSBlYWNoIHN1YmtleSBpcyBhcHBsaWVkIHRvIGFuIGV4cGFuZGVkIDMyLWJpdCBpbnB1dCxcblx0ICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJrZXkgY2FuIGJlIGJyb2tlbiBpbnRvIDggdmFsdWVzIHNjYWxlZCB0byAzMi1iaXRzLFxuXHQgICAgICAgICAgICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBrZXkgdG8gYmUgdXNlZCB3aXRob3V0IGV4cGFuc2lvblxuXHQgICAgICAgICAgICAgICAgc3ViS2V5WzBdID0gKHN1YktleVswXSA8PCAxKSB8IChzdWJLZXlbMF0gPj4+IDMxKTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNzsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViS2V5W2ldID0gc3ViS2V5W2ldID4+PiAoKGkgLSAxKSAqIDQgKyAzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHN1YktleVs3XSA9IChzdWJLZXlbN10gPDwgNSkgfCAoc3ViS2V5WzddID4+PiAyNyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludmVyc2Ugc3Via2V5c1xuXHQgICAgICAgICAgICB2YXIgaW52U3ViS2V5cyA9IHRoaXMuX2ludlN1YktleXMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpbnZTdWJLZXlzW2ldID0gc3ViS2V5c1sxNSAtIGldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCB0aGlzLl9zdWJLZXlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVjcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludlN1YktleXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBzdWJLZXlzKSB7XG5cdCAgICAgICAgICAgIC8vIEdldCBpbnB1dFxuXHQgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSBNW29mZnNldF07XG5cdCAgICAgICAgICAgIHRoaXMuX3JCbG9jayA9IE1bb2Zmc2V0ICsgMV07XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCBwZXJtdXRhdGlvblxuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgIDB4MGYwZjBmMGYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgIDB4MzMzMzMzMzMpO1xuXHQgICAgICAgICAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgOCwgIDB4MDBmZjAwZmYpO1xuXHQgICAgICAgICAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgIDB4NTU1NTU1NTUpO1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgMTY7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IHN1YktleXNbcm91bmRdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGxCbG9jayA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgICAgIHZhciByQmxvY2sgPSB0aGlzLl9yQmxvY2s7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEZlaXN0ZWwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgIHZhciBmID0gMDtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZiB8PSBTQk9YX1BbaV1bKChyQmxvY2sgXiBzdWJLZXlbaV0pICYgU0JPWF9NQVNLW2ldKSA+Pj4gMF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sQmxvY2sgPSByQmxvY2s7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSBsQmxvY2sgXiBmO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVW5kbyBzd2FwIGZyb20gbGFzdCByb3VuZFxuXHQgICAgICAgICAgICB2YXIgdCA9IHRoaXMuX2xCbG9jaztcblx0ICAgICAgICAgICAgdGhpcy5fbEJsb2NrID0gdGhpcy5fckJsb2NrO1xuXHQgICAgICAgICAgICB0aGlzLl9yQmxvY2sgPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIHBlcm11dGF0aW9uXG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAgMHg1NTU1NTU1NSk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCA4LCAgMHgwMGZmMDBmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAgMHgzMzMzMzMzMyk7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxNiwgMHgwMDAwZmZmZik7XG5cdCAgICAgICAgICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAgMHgwZjBmMGYwZik7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gPSB0aGlzLl9sQmxvY2s7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0aGlzLl9yQmxvY2s7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDY0LzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvLyBTd2FwIGJpdHMgYWNyb3NzIHRoZSBsZWZ0IGFuZCByaWdodCB3b3Jkc1xuXHQgICAgZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsIG1hc2spIHtcblx0ICAgICAgICB2YXIgdCA9ICgodGhpcy5fbEJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fckJsb2NrKSAmIG1hc2s7XG5cdCAgICAgICAgdGhpcy5fckJsb2NrIF49IHQ7XG5cdCAgICAgICAgdGhpcy5fbEJsb2NrIF49IHQgPDwgb2Zmc2V0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBleGNoYW5nZVJMKG9mZnNldCwgbWFzaykge1xuXHQgICAgICAgIHZhciB0ID0gKCh0aGlzLl9yQmxvY2sgPj4+IG9mZnNldCkgXiB0aGlzLl9sQmxvY2spICYgbWFzaztcblx0ICAgICAgICB0aGlzLl9sQmxvY2sgXj0gdDtcblx0ICAgICAgICB0aGlzLl9yQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkRFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUcmlwbGUtREVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBUcmlwbGVERVMgPSBDX2FsZ28uVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBERVMgaW5zdGFuY2VzXG5cdCAgICAgICAgICAgIHRoaXMuX2RlczEgPSBERVMuY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5V29yZHMuc2xpY2UoMCwgMikpKTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMiA9IERFUy5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXlXb3Jkcy5zbGljZSgyLCA0KSkpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzID0gREVTLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleVdvcmRzLnNsaWNlKDQsIDYpKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMyLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgICAgICB0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMy5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMi5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAga2V5U2l6ZTogMTkyLzMyLFxuXG5cdCAgICAgICAgaXZTaXplOiA2NC8zMixcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNjQvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlRyaXBsZURFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlRyaXBsZURFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5UcmlwbGVERVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKFRyaXBsZURFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuVHJpcGxlREVTO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2U7XG5cdCAgICB2YXIgWDMyV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvKipcblx0ICAgICAqIHg2NCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX3g2NCA9IEMueDY0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSA2NC1iaXQgd29yZC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFg2NFdvcmQgPSBDX3g2NC5Xb3JkID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCA2NC1iaXQgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIDMyIGJpdHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IDMyIGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4NjRXb3JkID0gQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChoaWdoLCBsb3cpIHtcblx0ICAgICAgICAgICAgdGhpcy5oaWdoID0gaGlnaDtcblx0ICAgICAgICAgICAgdGhpcy5sb3cgPSBsb3c7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBOT1RzIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBuZWdhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG5lZ2F0ZWQgPSB4NjRXb3JkLm5vdCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIG5vdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IH50aGlzLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB+dGhpcy5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEJpdHdpc2UgQU5EcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIEFORCB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBBTkRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBhbmRlZCA9IHg2NFdvcmQuYW5kKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBhbmQ6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoICYgd29yZC5oaWdoO1xuXHQgICAgICAgICAgICAvLyB2YXIgbG93ID0gdGhpcy5sb3cgJiB3b3JkLmxvdztcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQml0d2lzZSBPUnMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBPUiB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBPUmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9yZWQgPSB4NjRXb3JkLm9yKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBvcjogZnVuY3Rpb24gKHdvcmQpIHtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSB0aGlzLmhpZ2ggfCB3b3JkLmhpZ2g7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSB0aGlzLmxvdyB8IHdvcmQubG93O1xuXG5cdCAgICAgICAgICAgIC8vIHJldHVybiBYNjRXb3JkLmNyZWF0ZShoaWdoLCBsb3cpO1xuXHQgICAgICAgIC8vIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBCaXR3aXNlIFhPUnMgdGhpcyB3b3JkIHdpdGggdGhlIHBhc3NlZCB3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtYNjRXb3JkfSB3b3JkIFRoZSB4NjQtV29yZCB0byBYT1Igd2l0aCB0aGlzIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgWE9SaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgeG9yZWQgPSB4NjRXb3JkLnhvcihhbm90aGVyWDY0V29yZCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgLy8geG9yOiBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMuaGlnaCBeIHdvcmQuaGlnaDtcblx0ICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IF4gd29yZC5sb3c7XG5cblx0ICAgICAgICAgICAgLy8gcmV0dXJuIFg2NFdvcmQuY3JlYXRlKGhpZ2gsIGxvdyk7XG5cdCAgICAgICAgLy8gfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFNoaWZ0cyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSBsZWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHNoaWZ0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc2hpZnRlZCA9IHg2NFdvcmQuc2hpZnRMKDI1KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBzaGlmdEw6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIGlmIChuIDwgMzIpIHtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gKHRoaXMuaGlnaCA8PCBuKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbikpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMubG93IDw8IG47XG5cdCAgICAgICAgICAgIC8vIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IHRoaXMubG93IDw8IChuIC0gMzIpO1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IDA7XG5cdCAgICAgICAgICAgIC8vIH1cblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogU2hpZnRzIHRoaXMgd29yZCBuIGJpdHMgdG8gdGhlIHJpZ2h0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHNoaWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7WDY0V29yZH0gQSBuZXcgeDY0LVdvcmQgb2JqZWN0IGFmdGVyIHNoaWZ0aW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc2hpZnRlZCA9IHg2NFdvcmQuc2hpZnRSKDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHNoaWZ0UjogZnVuY3Rpb24gKG4pIHtcblx0ICAgICAgICAgICAgLy8gaWYgKG4gPCAzMikge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9ICh0aGlzLmxvdyA+Pj4gbikgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG4pKTtcblx0ICAgICAgICAgICAgICAgIC8vIHZhciBoaWdoID0gdGhpcy5oaWdoID4+PiBuO1xuXHQgICAgICAgICAgICAvLyB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gdmFyIGxvdyA9IHRoaXMuaGlnaCA+Pj4gKG4gLSAzMik7XG5cdCAgICAgICAgICAgICAgICAvLyB2YXIgaGlnaCA9IDA7XG5cdCAgICAgICAgICAgIC8vIH1cblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUm90YXRlcyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSBsZWZ0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciByb3RhdGluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHJvdGF0ZWQgPSB4NjRXb3JkLnJvdEwoMjUpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHJvdEw6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLnNoaWZ0TChuKS5vcih0aGlzLnNoaWZ0Uig2NCAtIG4pKTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUm90YXRlcyB0aGlzIHdvcmQgbiBiaXRzIHRvIHRoZSByaWdodC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgYml0cyB0byByb3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkfSBBIG5ldyB4NjQtV29yZCBvYmplY3QgYWZ0ZXIgcm90YXRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciByb3RhdGVkID0geDY0V29yZC5yb3RSKDcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIC8vIHJvdFI6IGZ1bmN0aW9uIChuKSB7XG5cdCAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLnNoaWZ0UihuKS5vcih0aGlzLnNoaWZ0TCg2NCAtIG4pKTtcblx0ICAgICAgICAvLyB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyB0aGlzIHdvcmQgd2l0aCB0aGUgcGFzc2VkIHdvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1g2NFdvcmR9IHdvcmQgVGhlIHg2NC1Xb3JkIHRvIGFkZCB3aXRoIHRoaXMgd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1g2NFdvcmR9IEEgbmV3IHg2NC1Xb3JkIG9iamVjdCBhZnRlciBhZGRpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBhZGRlZCA9IHg2NFdvcmQuYWRkKGFub3RoZXJYNjRXb3JkKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICAvLyBhZGQ6IGZ1bmN0aW9uICh3b3JkKSB7XG5cdCAgICAgICAgICAgIC8vIHZhciBsb3cgPSAodGhpcy5sb3cgKyB3b3JkLmxvdykgfCAwO1xuXHQgICAgICAgICAgICAvLyB2YXIgY2FycnkgPSAobG93ID4+PiAwKSA8ICh0aGlzLmxvdyA+Pj4gMCkgPyAxIDogMDtcblx0ICAgICAgICAgICAgLy8gdmFyIGhpZ2ggPSAodGhpcy5oaWdoICsgd29yZC5oaWdoICsgY2FycnkpIHwgMDtcblxuXHQgICAgICAgICAgICAvLyByZXR1cm4gWDY0V29yZC5jcmVhdGUoaGlnaCwgbG93KTtcblx0ICAgICAgICAvLyB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiA2NC1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBYNjRXb3JkQXJyYXkgPSBDX3g2NC5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIENyeXB0b0pTLng2NC5Xb3JkIG9iamVjdHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG5cdCAgICAgICAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgxODE5MWExYiwgMHgxYzFkMWUxZilcblx0ICAgICAgICAgKiAgICAgXSk7XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KSxcblx0ICAgICAgICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuXHQgICAgICAgICAqICAgICBdLCAxMCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogODtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIDY0LWJpdCB3b3JkIGFycmF5IHRvIGEgMzItYml0IHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDcnlwdG9KUy5saWIuV29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkncyBkYXRhIGFzIGEgMzItYml0IHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB4MzJXb3JkQXJyYXkgPSB4NjRXb3JkQXJyYXkudG9YMzIoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1gzMjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHg2NFdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHg2NFdvcmRzTGVuZ3RoID0geDY0V29yZHMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHgzMldvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeDY0V29yZHNMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHg2NFdvcmQgPSB4NjRXb3Jkc1tpXTtcblx0ICAgICAgICAgICAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5oaWdoKTtcblx0ICAgICAgICAgICAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5sb3cpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIFgzMldvcmRBcnJheS5jcmVhdGUoeDMyV29yZHMsIHRoaXMuc2lnQnl0ZXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtYNjRXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0geDY0V29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIFwid29yZHNcIiBhcnJheVxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2xvbmUgZWFjaCBYNjRXb3JkIG9iamVjdFxuXHQgICAgICAgICAgICB2YXIgd29yZHNMZW5ndGggPSB3b3Jkcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHNMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaV0gPSB3b3Jkc1tpXS5jbG9uZSgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XG52YXIgcGVyY2VudFR3ZW50aWVzID0gLyUyMC9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAnZGVmYXVsdCc6ICdSRkMzOTg2JyxcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2UuY2FsbCh2YWx1ZSwgcGVyY2VudFR3ZW50aWVzLCAnKycpO1xuICAgICAgICB9LFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgUkZDMTczODogJ1JGQzE3MzgnLFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Jyk7XG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGFsbG93RG90czogZmFsc2UsXG4gICAgYWxsb3dQcm90b3R5cGVzOiBmYWxzZSxcbiAgICBhcnJheUxpbWl0OiAyMCxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXG4gICAgZGVsaW1pdGVyOiAnJicsXG4gICAgZGVwdGg6IDUsXG4gICAgcGFyYW1ldGVyTGltaXQ6IDEwMDAsXG4gICAgcGxhaW5PYmplY3RzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgcGFyc2VWYWx1ZXMgPSBmdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nVmFsdWVzKHN0ciwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgY2xlYW5TdHIgPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID8gc3RyLnJlcGxhY2UoL15cXD8vLCAnJykgOiBzdHI7XG4gICAgdmFyIGxpbWl0ID0gb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBvcHRpb25zLnBhcmFtZXRlckxpbWl0O1xuICAgIHZhciBwYXJ0cyA9IGNsZWFuU3RyLnNwbGl0KG9wdGlvbnMuZGVsaW1pdGVyLCBsaW1pdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XG4gICAgICAgIHZhciBwb3MgPSBicmFja2V0RXF1YWxzUG9zID09PSAtMSA/IHBhcnQuaW5kZXhPZignPScpIDogYnJhY2tldEVxdWFsc1BvcyArIDE7XG5cbiAgICAgICAgdmFyIGtleSwgdmFsO1xuICAgICAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgICAgICAga2V5ID0gb3B0aW9ucy5kZWNvZGVyKHBhcnQsIGRlZmF1bHRzLmRlY29kZXIpO1xuICAgICAgICAgICAgdmFsID0gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgPyBudWxsIDogJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuZGVjb2RlcihwYXJ0LnNsaWNlKHBvcyArIDEpLCBkZWZhdWx0cy5kZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IFtdLmNvbmNhdChvYmpba2V5XSkuY29uY2F0KHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgcGFyc2VPYmplY3QgPSBmdW5jdGlvbiBwYXJzZU9iamVjdFJlY3Vyc2l2ZShjaGFpbiwgdmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGNoYWluLnNoaWZ0KCk7XG5cbiAgICB2YXIgb2JqO1xuICAgIGlmIChyb290ID09PSAnW10nKSB7XG4gICAgICAgIG9iaiA9IFtdO1xuICAgICAgICBvYmogPSBvYmouY29uY2F0KHBhcnNlT2JqZWN0KGNoYWluLCB2YWwsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgdmFyIGNsZWFuUm9vdCA9IHJvb3QuY2hhckF0KDApID09PSAnWycgJiYgcm9vdC5jaGFyQXQocm9vdC5sZW5ndGggLSAxKSA9PT0gJ10nID8gcm9vdC5zbGljZSgxLCAtMSkgOiByb290O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjbGVhblJvb3QsIDEwKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxuICAgICAgICAgICAgJiYgcm9vdCAhPT0gY2xlYW5Sb290XG4gICAgICAgICAgICAmJiBTdHJpbmcoaW5kZXgpID09PSBjbGVhblJvb3RcbiAgICAgICAgICAgICYmIGluZGV4ID49IDBcbiAgICAgICAgICAgICYmIChvcHRpb25zLnBhcnNlQXJyYXlzICYmIGluZGV4IDw9IG9wdGlvbnMuYXJyYXlMaW1pdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICAgIG9ialtpbmRleF0gPSBwYXJzZU9iamVjdChjaGFpbiwgdmFsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gcGFyc2VPYmplY3QoY2hhaW4sIHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdpdmVuS2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gZG90IG5vdGF0aW9uIHRvIGJyYWNrZXQgbm90YXRpb25cbiAgICB2YXIga2V5ID0gb3B0aW9ucy5hbGxvd0RvdHMgPyBnaXZlbktleS5yZXBsYWNlKC9cXC4oW14uW10rKS9nLCAnWyQxXScpIDogZ2l2ZW5LZXk7XG5cbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXG5cbiAgICB2YXIgYnJhY2tldHMgPSAvKFxcW1teW1xcXV0qXSkvO1xuICAgIHZhciBjaGlsZCA9IC8oXFxbW15bXFxdXSpdKS9nO1xuXG4gICAgLy8gR2V0IHRoZSBwYXJlbnRcblxuICAgIHZhciBzZWdtZW50ID0gYnJhY2tldHMuZXhlYyhrZXkpO1xuICAgIHZhciBwYXJlbnQgPSBzZWdtZW50ID8ga2V5LnNsaWNlKDAsIHNlZ21lbnQuaW5kZXgpIDoga2V5O1xuXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcblxuICAgIHZhciBrZXlzID0gW107XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICAvLyBJZiB3ZSBhcmVuJ3QgdXNpbmcgcGxhaW4gb2JqZWN0cywgb3B0aW9uYWxseSBwcmVmaXgga2V5c1xuICAgICAgICAvLyB0aGF0IHdvdWxkIG92ZXJ3cml0ZSBvYmplY3QgcHJvdG90eXBlIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKCFvcHRpb25zLnBsYWluT2JqZWN0cyAmJiBoYXMuY2FsbChPYmplY3QucHJvdG90eXBlLCBwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAga2V5cy5wdXNoKHBhcmVudCk7XG4gICAgfVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGNoaWxkcmVuIGFwcGVuZGluZyB0byB0aGUgYXJyYXkgdW50aWwgd2UgaGl0IGRlcHRoXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKChzZWdtZW50ID0gY2hpbGQuZXhlYyhrZXkpKSAhPT0gbnVsbCAmJiBpIDwgb3B0aW9ucy5kZXB0aCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICghb3B0aW9ucy5wbGFpbk9iamVjdHMgJiYgaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc2VnbWVudFsxXS5zbGljZSgxLCAtMSkpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XG5cbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgb3B0cykge1xuICAgIHZhciBvcHRpb25zID0gb3B0cyA/IHV0aWxzLmFzc2lnbih7fSwgb3B0cykgOiB7fTtcblxuICAgIGlmIChvcHRpb25zLmRlY29kZXIgIT09IG51bGwgJiYgb3B0aW9ucy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdEZWNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaWdub3JlUXVlcnlQcmVmaXggPSBvcHRpb25zLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlO1xuICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gdHlwZW9mIG9wdGlvbnMuZGVsaW1pdGVyID09PSAnc3RyaW5nJyB8fCB1dGlscy5pc1JlZ0V4cChvcHRpb25zLmRlbGltaXRlcikgPyBvcHRpb25zLmRlbGltaXRlciA6IGRlZmF1bHRzLmRlbGltaXRlcjtcbiAgICBvcHRpb25zLmRlcHRoID0gdHlwZW9mIG9wdGlvbnMuZGVwdGggPT09ICdudW1iZXInID8gb3B0aW9ucy5kZXB0aCA6IGRlZmF1bHRzLmRlcHRoO1xuICAgIG9wdGlvbnMuYXJyYXlMaW1pdCA9IHR5cGVvZiBvcHRpb25zLmFycmF5TGltaXQgPT09ICdudW1iZXInID8gb3B0aW9ucy5hcnJheUxpbWl0IDogZGVmYXVsdHMuYXJyYXlMaW1pdDtcbiAgICBvcHRpb25zLnBhcnNlQXJyYXlzID0gb3B0aW9ucy5wYXJzZUFycmF5cyAhPT0gZmFsc2U7XG4gICAgb3B0aW9ucy5kZWNvZGVyID0gdHlwZW9mIG9wdGlvbnMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXI7XG4gICAgb3B0aW9ucy5hbGxvd0RvdHMgPSB0eXBlb2Ygb3B0aW9ucy5hbGxvd0RvdHMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuYWxsb3dEb3RzIDogZGVmYXVsdHMuYWxsb3dEb3RzO1xuICAgIG9wdGlvbnMucGxhaW5PYmplY3RzID0gdHlwZW9mIG9wdGlvbnMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cztcbiAgICBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9IHR5cGVvZiBvcHRpb25zLmFsbG93UHJvdG90eXBlcyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgOiBkZWZhdWx0cy5hbGxvd1Byb3RvdHlwZXM7XG4gICAgb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdCA9IHR5cGVvZiBvcHRpb25zLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdDtcbiAgICBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9IHR5cGVvZiBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcgOiBkZWZhdWx0cy5zdHJpY3ROdWxsSGFuZGxpbmc7XG5cbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIH1cblxuICAgIHZhciB0ZW1wT2JqID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBwYXJzZVZhbHVlcyhzdHIsIG9wdGlvbnMpIDogc3RyO1xuICAgIHZhciBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5cyBhbmQgc2V0dXAgdGhlIG5ldyBvYmplY3RcblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zKTtcbiAgICAgICAgb2JqID0gdXRpbHMubWVyZ2Uob2JqLCBuZXdPYmosIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5jb21wYWN0KG9iaik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgYXJyYXlQcmVmaXhHZW5lcmF0b3JzID0ge1xuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbXSc7XG4gICAgfSxcbiAgICBpbmRpY2VzOiBmdW5jdGlvbiBpbmRpY2VzKHByZWZpeCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSxcbiAgICByZXBlYXQ6IGZ1bmN0aW9uIHJlcGVhdChwcmVmaXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmdW5jLW5hbWUtbWF0Y2hpbmdcbiAgICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9XG59O1xuXG52YXIgdG9JU08gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZztcblxudmFyIGRlZmF1bHRzID0ge1xuICAgIGRlbGltaXRlcjogJyYnLFxuICAgIGVuY29kZTogdHJ1ZSxcbiAgICBlbmNvZGVyOiB1dGlscy5lbmNvZGUsXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXG4gICAgc2VyaWFsaXplRGF0ZTogZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShkYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gICAgICAgIHJldHVybiB0b0lTTy5jYWxsKGRhdGUpO1xuICAgIH0sXG4gICAgc2tpcE51bGxzOiBmYWxzZSxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmc6IGZhbHNlXG59O1xuXG52YXIgc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuICAgIG9iamVjdCxcbiAgICBwcmVmaXgsXG4gICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgc2tpcE51bGxzLFxuICAgIGVuY29kZXIsXG4gICAgZmlsdGVyLFxuICAgIHNvcnQsXG4gICAgYWxsb3dEb3RzLFxuICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgZm9ybWF0dGVyLFxuICAgIGVuY29kZVZhbHVlc09ubHlcbikge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqID0gZmlsdGVyKHByZWZpeCwgb2JqKTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzdHJpY3ROdWxsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVyICYmICFlbmNvZGVWYWx1ZXNPbmx5ID8gZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpIDogcHJlZml4O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHR5cGVvZiBvYmogPT09ICdib29sZWFuJyB8fCB1dGlscy5pc0J1ZmZlcihvYmopKSB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIpO1xuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyKSldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZm9ybWF0dGVyKHByZWZpeCkgKyAnPScgKyBmb3JtYXR0ZXIoU3RyaW5nKG9iaikpXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gW107XG5cbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICB2YXIgb2JqS2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgICAgIG9iaktleXMgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBvYmpLZXlzID0gc29ydCA/IGtleXMuc29ydChzb3J0KSA6IGtleXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeChwcmVmaXgsIGtleSksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChzdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgb2JqW2tleV0sXG4gICAgICAgICAgICAgICAgcHJlZml4ICsgKGFsbG93RG90cyA/ICcuJyArIGtleSA6ICdbJyArIGtleSArICddJyksXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgICAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXG4gICAgICAgICAgICAgICAgc2tpcE51bGxzLFxuICAgICAgICAgICAgICAgIGVuY29kZXIsXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICAgIHNvcnQsXG4gICAgICAgICAgICAgICAgYWxsb3dEb3RzLFxuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLFxuICAgICAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHlcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgb3B0cykge1xuICAgIHZhciBvYmogPSBvYmplY3Q7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzID8gdXRpbHMuYXNzaWduKHt9LCBvcHRzKSA6IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZW5jb2RlciAhPT0gbnVsbCAmJiBvcHRpb25zLmVuY29kZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VuY29kZXIgaGFzIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlbGltaXRlciA9IHR5cGVvZiBvcHRpb25zLmRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5kZWxpbWl0ZXIgOiBvcHRpb25zLmRlbGltaXRlcjtcbiAgICB2YXIgc3RyaWN0TnVsbEhhbmRsaW5nID0gdHlwZW9mIG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZztcbiAgICB2YXIgc2tpcE51bGxzID0gdHlwZW9mIG9wdGlvbnMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscztcbiAgICB2YXIgZW5jb2RlID0gdHlwZW9mIG9wdGlvbnMuZW5jb2RlID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZSA6IGRlZmF1bHRzLmVuY29kZTtcbiAgICB2YXIgZW5jb2RlciA9IHR5cGVvZiBvcHRpb25zLmVuY29kZXIgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVuY29kZXIgOiBkZWZhdWx0cy5lbmNvZGVyO1xuICAgIHZhciBzb3J0ID0gdHlwZW9mIG9wdGlvbnMuc29ydCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc29ydCA6IG51bGw7XG4gICAgdmFyIGFsbG93RG90cyA9IHR5cGVvZiBvcHRpb25zLmFsbG93RG90cyA9PT0gJ3VuZGVmaW5lZCcgPyBmYWxzZSA6IG9wdGlvbnMuYWxsb3dEb3RzO1xuICAgIHZhciBzZXJpYWxpemVEYXRlID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuc2VyaWFsaXplRGF0ZSA6IGRlZmF1bHRzLnNlcmlhbGl6ZURhdGU7XG4gICAgdmFyIGVuY29kZVZhbHVlc09ubHkgPSB0eXBlb2Ygb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5ID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmVuY29kZVZhbHVlc09ubHkgOiBkZWZhdWx0cy5lbmNvZGVWYWx1ZXNPbmx5O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb3JtYXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0ID0gZm9ybWF0cy5kZWZhdWx0O1xuICAgIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JtYXRzLmZvcm1hdHRlcnMsIG9wdGlvbnMuZm9ybWF0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZXIgPSBmb3JtYXRzLmZvcm1hdHRlcnNbb3B0aW9ucy5mb3JtYXRdO1xuICAgIHZhciBvYmpLZXlzO1xuICAgIHZhciBmaWx0ZXI7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmlsdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xuICAgIGlmIChvcHRpb25zLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuYXJyYXlGb3JtYXQ7XG4gICAgfSBlbHNlIGlmICgnaW5kaWNlcycgaW4gb3B0aW9ucykge1xuICAgICAgICBhcnJheUZvcm1hdCA9IG9wdGlvbnMuaW5kaWNlcyA/ICdpbmRpY2VzJyA6ICdyZXBlYXQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5Rm9ybWF0ID0gJ2luZGljZXMnO1xuICAgIH1cblxuICAgIHZhciBnZW5lcmF0ZUFycmF5UHJlZml4ID0gYXJyYXlQcmVmaXhHZW5lcmF0b3JzW2FycmF5Rm9ybWF0XTtcblxuICAgIGlmICghb2JqS2V5cykge1xuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB9XG5cbiAgICBpZiAoc29ydCkge1xuICAgICAgICBvYmpLZXlzLnNvcnQoc29ydCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmpLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xuXG4gICAgICAgIGlmIChza2lwTnVsbHMgJiYgb2JqW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KHN0cmluZ2lmeShcbiAgICAgICAgICAgIG9ialtrZXldLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZ2VuZXJhdGVBcnJheVByZWZpeCxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcbiAgICAgICAgICAgIHNraXBOdWxscyxcbiAgICAgICAgICAgIGVuY29kZSA/IGVuY29kZXIgOiBudWxsLFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgc29ydCxcbiAgICAgICAgICAgIGFsbG93RG90cyxcbiAgICAgICAgICAgIHNlcmlhbGl6ZURhdGUsXG4gICAgICAgICAgICBmb3JtYXR0ZXIsXG4gICAgICAgICAgICBlbmNvZGVWYWx1ZXNPbmx5XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIHZhciBqb2luZWQgPSBrZXlzLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB2YXIgcHJlZml4ID0gb3B0aW9ucy5hZGRRdWVyeVByZWZpeCA9PT0gdHJ1ZSA/ICc/JyA6ICcnO1xuXG4gICAgcmV0dXJuIGpvaW5lZC5sZW5ndGggPiAwID8gcHJlZml4ICsgam9pbmVkIDogJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xufSgpKTtcblxuZXhwb3J0cy5hcnJheVRvT2JqZWN0ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIHZhciBvYmogPSBvcHRpb25zICYmIG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb2JqW2ldID0gc291cmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXQucHVzaChzb3VyY2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMgfHwgIWhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIG1lcmdlVGFyZ2V0ID0gZXhwb3J0cy5hcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgc291cmNlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbCh0YXJnZXQsIGkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFtpXSAmJiB0eXBlb2YgdGFyZ2V0W2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBleHBvcnRzLm1lcmdlKHRhcmdldFtpXSwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc291cmNlKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICAgIGlmIChoYXMuY2FsbChhY2MsIGtleSkpIHtcbiAgICAgICAgICAgIGFjY1trZXldID0gZXhwb3J0cy5tZXJnZShhY2Nba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIG1lcmdlVGFyZ2V0KTtcbn07XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gYXNzaWduU2luZ2xlU291cmNlKHRhcmdldCwgc291cmNlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICBhY2Nba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59O1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0ci5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxuICAgIC8vIEl0IGhhcyBiZWVuIGFkYXB0ZWQgaGVyZSBmb3Igc3RyaWN0ZXIgYWRoZXJlbmNlIHRvIFJGQyAzOTg2XG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgc3RyaW5nID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIgOiBTdHJpbmcoc3RyKTtcblxuICAgIHZhciBvdXQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGMgPT09IDB4MkQgICAgLy8gLVxuICAgICAgICAgICAgfHwgYyA9PT0gMHgyRSAvLyAuXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cbiAgICAgICAgICAgIHx8IGMgPT09IDB4N0UgLy8gflxuICAgICAgICAgICAgfHwgKGMgPj0gMHgzMCAmJiBjIDw9IDB4MzkpIC8vIDAtOVxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxuICAgICAgICAgICAgfHwgKGMgPj0gMHg2MSAmJiBjIDw9IDB4N0EpIC8vIEEtWlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dCArPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIG91dCA9IG91dCArIGhleFRhYmxlW2NdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjIDwgMHhEODAwIHx8IGMgPj0gMHhFMDAwKSB7XG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhFMCB8IChjID4+IDEyKV0gKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjID0gMHgxMDAwMCArICgoKGMgJiAweDNGRikgPDwgMTApIHwgKHN0cmluZy5jaGFyQ29kZUF0KGkpICYgMHgzRkYpKTtcbiAgICAgICAgb3V0ICs9IGhleFRhYmxlWzB4RjAgfCAoYyA+PiAxOCldXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV1cbiAgICAgICAgICAgICsgaGV4VGFibGVbMHg4MCB8IChjICYgMHgzRildO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5leHBvcnRzLmNvbXBhY3QgPSBmdW5jdGlvbiAob2JqLCByZWZlcmVuY2VzKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHZhciByZWZzID0gcmVmZXJlbmNlcyB8fCBbXTtcbiAgICB2YXIgbG9va3VwID0gcmVmcy5pbmRleE9mKG9iaik7XG4gICAgaWYgKGxvb2t1cCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlZnNbbG9va3VwXTtcbiAgICB9XG5cbiAgICByZWZzLnB1c2gob2JqKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdmFyIGNvbXBhY3RlZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAob2JqW2ldICYmIHR5cGVvZiBvYmpbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgY29tcGFjdGVkLnB1c2goZXhwb3J0cy5jb21wYWN0KG9ialtpXSwgcmVmcykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqW2ldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGFjdGVkO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvYmpba2V5XSA9IGV4cG9ydHMuY29tcGFjdChvYmpba2V5XSwgcmVmcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKSk7XG59O1xuIl19
